
        ##     ##   #	#	 ######
         ##   ##   ##  ##	 ##   ##		    ##
          ## ##   ### ###	 ##   ##
           ###     ##  ## #####  #####     #####    #####  ####   ####
          ## ##    ##  ##	 ##   ##       ##  ##	    ##   ##  ##
         ##   ##   ##  ##	 ##   ##   ######   ####    ##   ##
        ##     ##  ##  ##	 ##   ##  ##   ##      ##   ##   ##  ##
        ##     ##  ##  ##	 ######    ######  #####   ####   ####
 
        ###############################################################
  




X11-BASIC



                                 VERSION 1.19


                 (C) 1997-2012 by Markus Hooemann


                      (kollo@users.sourceforge.net)

                (see http://x11-basic.sourceforge.net/)


__________________________________________________________________________________________________



   X11-Basic is a dialect of the BASIC programming language with graphics capability that

integrates features like shell scripting, cgi-programming and full graphical visualisation into

the easy to learn BASIC language on modern computers.  The syntax is most similar to the

old GFA-Basic on ATARI-ST implementation. Old GFA-programs should run with only few

changes.



   About this document


This document describes the features of X11-Basic. You will ond information about the X11-

Basic interpreter (the program xbasic under Unix or xbasic.exe under Windows) and the

compiler (the program xbc under UNIX or xbc.exe under Windows) as well as the language

itself. For a more compact description you may want to read the x11basic(1) man-page or

the man-page of the X11-Basic compiler xbc(1).

   The latest information and updates and new versions of X11-Basic can be found at

http://x11-basic.sourceforge.net/.



2




Contents



1.  ABOUT X11-Basic                                                                        1


2.  Usage                                                                                     4

    2.1.  Installing X11-Basic   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    4

    2.2.  The X11-Basic Interpreter   . . . . . . . . . . . . . . . . . . . . . . . . . . .    8

    2.3.  Using Syntax highlighting with nedit   . . . . . . . . . . . . . . . . . . . . .    9

    2.4.  The xbc (pseudo) compiler  . . . . . . . . . . . . . . . . . . . . . . . . . . .   10

    2.5.  The WINDOWS Version of X11-Basic . . . . . . . . . . . . . . . . . . . . .   11

    2.6.  The Android Version of X11-Basic  . . . . . . . . . . . . . . . . . . . . . . .   11

    2.7.  The TomTom Version of X11-Basic   . . . . . . . . . . . . . . . . . . . . . .   13

    2.8.  The ANSI-Basic to X11-Basic converter  . . . . . . . . . . . . . . . . . . . .   13

    2.9.  Using GFA-BASIC programs  . . . . . . . . . . . . . . . . . . . . . . . . . .   13


3.  X11Basic: Getting Started                                                              15

    3.1.  Introduction to this Dialect of BASIC   . . . . . . . . . . . . . . . . . . . . .   15

    3.2.  Interpreter vs Compiler  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   16

    3.3.  Your orst X11-Basic program . . . . . . . . . . . . . . . . . . . . . . . . . .   16

    3.4.  General Syntax   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   17

    3.5.  The very BASIC commands: PRINT, INPUT, IF and GOTO   . . . . . . . . .   18

    3.6.  Variables   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   18

    3.7.  Arithmetics and Calculations  . . . . . . . . . . . . . . . . . . . . . . . . . .   21

    3.8.  Program structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   26

    3.9.  Simple Input/Output   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   29

    3.10. Flow Control   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   32

    3.11. Adress Spaces  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   36

    3.12. Graphics: Drawing and Painting   . . . . . . . . . . . . . . . . . . . . . . . .   36

    3.13. Reading from and Writing to Files  . . . . . . . . . . . . . . . . . . . . . . .   36

    3.14. Internet connections, special oles and sockets   . . . . . . . . . . . . . . . . .   36

    3.15. Data within the program   . . . . . . . . . . . . . . . . . . . . . . . . . . . .   40

    3.16. Dynamic-link libraries   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   41

    3.17. Memory management  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   43

    3.18. Other features  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   43

    3.19. Using the Graphical User Interface (GUI)   . . . . . . . . . . . . . . . . . . .   44

    3.20. WEB programming with X11-Basic   . . . . . . . . . . . . . . . . . . . . . .   57



                                                                                                 i

Contents__________________________________________________________________________________________



4.  Quick reference                                                                          67

    4.1.  reserved variable names . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   67

    4.2.  Abbreviations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   67

    4.3.  Commands   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   68

    4.4.  Graphic commands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   71

    4.5.  Math commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   72

    4.6.  Math functions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   72

    4.7.  String functions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   74

    4.8.  Graphic functions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   75

    4.9.  Other functions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   75

    4.10. Subroutines and Functions   . . . . . . . . . . . . . . . . . . . . . . . . . . .   76

    4.11. Error Messages  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   77



5.  X11-Basic command reference                                                         83

    5.1.  Syntax templates   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   83

    5.2.  A   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   84

    5.3.  B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  101

    5.4.  C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  118

    5.5.  D   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  150

    5.6.  E . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  173

    5.7.  F  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  200

    5.8.  G   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  222

    5.9.  H   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  238

    5.10. I  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  245

    5.11. J  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  260

    5.12. K   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  263

    5.13. L . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  265

    5.14. M   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  290

    5.15. N   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  312

    5.16. O   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  317

    5.17. P  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  331

    5.18. Q   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  356

    5.19. R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  358

    5.20. S  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  381

    5.21. T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  427

    5.22. U   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  438

    5.23. V   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  448

    5.24. W   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  455

    5.25. X   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  464



6.  Frequently asked Questions                                                          471



ii

     ___________________________________________________________________________________Contents____________



7.  Compatibility                                                                           472

    7.1.  General remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  472

    7.2.  GFA-Basic compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  473

    7.3.  Ideas for future releases of X11-Basic   . . . . . . . . . . . . . . . . . . . . .  480


A.  GNU Free Documentation License                                                    483


Index                                                                                        492



                                                                                                iii





1.     ABOUT  X11-Basic



X11-Basic is a dialect of the BASIC programming language with graphics1 and sound2 which

integrates features like shell scripting, cgi programming and full graphical visualisation into

the easy to learn basic language on modern computers.

   The syntax is most similar to GFA-Basic in its original ancient implementation of the

ATARI ST. Old GFA-programs should run with only few changes. Also DOS/QBASIC pro-

grammers will feel comfortable.

   X11-Basic is as well suited to novices as programming wizards, and is appropriate for

virtually all programming tasks. For science and engineering X11-Basic has already prooved

its capability of handling complex simulation and control problems.  For system programs,

X11-Basic has high level language replacements for low level programming features that are

much easier to read, understand, and maintain. For all applications, X11-Basic is designed to

support rapid development of compact, eOEcient, reliable, readable, portable, well structured

programs.

   The X11-Basic environment contains a library of GEM GUI functions. This makes writing

GUI programs in X11-Basic faster, easier and more portable than programming with native

GUI tools.



Structured programming



X11-Basic is a structured procedural programming language. Structure is a form of visual and

functional encapsulation in which multiple-line sections of program look and act like single

units. The beginning and end of blocks are marked by descriptive keyword delimiters. Lines

within blocks are generally indented to make the block visible.

   Unlike more traditional BASIC implementations, line numbers are not used in X11-Basic.

Every line holds only one instruction. Jumps with GOTO are possible but not necessary. All

the well-known loops are available including an additional command for discontinuation (

> EXIT IF). Procedures and functions with return values of any type can be deoned.  So a
     _____________________________________________
  1The actual implementation runs on UNIX workstations and Linux-systems with the X-Window system. In case

    where no X11 implementation is available, X11-Basic can be compiled with a frambuoeer-device graphics
    engine.  The Android version e.g.  uses the framebuoeer interface.  Also such a version for the TomTom
    Navigation devices is available. Porting X11-Basic to more embedded systems is possible. On UNIX and
    linux systems, the X11 graphics engine can be used as well as the SDL library, the framebuoeer devices or no
    graphics at all. The MS WINDOWS version supports only SDL (or no graphics at all).
  2On LINUX systems the ALSA sound engine can be used.



                                                                                                1

1.__ABOUT_X11-Basic_______________________________________________________________________________



program can contain a main part to call the subfunctions, for example in side of a loop. Whole

libraries can be added with the merge command (> MERGE).

   A converter (> bas2x11basic) allows to convert regular (with line numbers) ANSI-Basic

programs to X11-Basic.

   A third-party tool gfalist (the project name is ONS) by Peter Backes (not included in the

X11-Basic package) even allows to decode GFA-Basic .gfa oles to ASCII.



Speed of X11-Basic



How fast is X11-Basic? This Question can be answered in three steps, because the excecution

speed depends if the code is interpreted, run as bytecode in a virtual machine, or beeing

compiled to native machine language:



   1.  The interpreter is slow.

   2.  The bytecode is fast.

   3.  The compiled programs are even faster.



   Byte-coded programs are always interpreted faster than scripted programming languages.

The X11-Basic compiler can translate the X11-Basic bytecode to C, which then can be com-

piled to native machine language using any C-compiler (preferrably gcc on UNIX systems).

Obviously your programs will be slower than optimized C/C++ code and other compilers that

build machine language code, but it already comes close.

   If you need highest possible speed you can load and link a separate DLL/shared object with

the time critical part of your code written in another language (e.g.  C, but not ActiveX or

C++).

   A speed comparison was done with the Weatstone benchmark (> Whets.bas). This shows,

that bytecode-programs are about 19 times faster than the interpreted code and a natively

compiled program runs about 28 times faster.



Optimallity of code and code overhead



At a minimum the X11-Basic interpreter and the bytecode interpreter (virtual machine) require

about 300 KB of memory and another 300 kB of ole size, which includes the X11-Basic

runtime-library. So this is the overhead that all your programs will have. Compared to some

Windows programs, this isn't that bad. Most likely your bytecode is less than 50 kB anyway

(for a moderate/large application), plus any resources and graphics you may want to include

of course. In the end the code produced will be reasonnably small and light enough to be also

used on portable devices (e.g.  cell phones and navigation devices) which have only a small

amount of native memory (and a relatively slow processor).



2


     _______________________________________________________________________________________________________



Copyright information


Copyright (C) 1997-2012 by Markus Hooemann

   Permission is granted to copy, distribute and/or modify this document under the terms of

the GNU Free Documentation License, Version 1.2 or any later version published by the Free

Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover

Texts.  A copy of the license is included in the section entitled "GNU Free Documentation

License".

   X11-Basic is free software; you can redistribute it and/or modify it under the terms of the

GNU General Public License as published by the Free Software Foundation; either version 2

of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT ANY WAR-

RANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A

PARTICULAR PURPOSE. See the GNU General Public License for more details.

   Read the ole COPYING for details.

   (Basically that means, free, open source, use and modify as you like, don't incorporate it

into non-free software, no warranty of any sort, don't blame me if it doesn't work.)



                                                                                                3




2.     Usage



The X11-Basic interpreter is called xbasic (xbasic.exe under Windows).  The compiler

xbc (xbc.exe under Windows).  Under Unix these excecutables are usually installed in the

/usr/bin/ (if installed via the package management system) or in /usr/local/bin (if in-

stalled manually from the source package) path. Under Windows, the oles are installed nor-

mally under the directory C:"x11basic.



2.1.    Installing X11-Basic



SuSE-Linux and RedHat


If you got a Redhat-Package (RPM) e.g. the File X11Basic-1.19-1.i386.rpm, then you can

install this package (beeing root) with rpm  -i  X11Basic-1.19-1.i386.rpm.

   This is a very convienient way at least for the Linux distributions Feodora, SuSE and RedHat

(and many others) of installing the interpreter the compiler and its documentation, the man-

pages and a small collection of example programs.
   Following oles will be normally installed:

/usr/bin/xbasic        -- the interpreter
/usr/bin/xbc           -- the compiler
/usr/bin/xbbc          -- bytecode compiler
/usr/bin/xvbm          -- bytecode interpreter (virtual machine)
/usr/bin/xb2c          -- the bytecode to C translator
/usr/bin/bas2x11basic -- the ANSI BASIC to X11-Basic translator
/usr/lib/libx11basic.so -- the runtime library (shared object)
/usr/lib/libx11basic.a  -- the runtime library for static linking
/usr/include/x11basic/x11basic.h -- the header file for library API
/usr/include/x11basic/xb2csol.h  -- the header file for compilation of xb2c output
/usr/share/man/man1/x11basic.1 -- the man-page of X11-Basic
/usr/share/man/man1/xbasic.1    -- the man-page of the X11-Basic interpreter
/usr/share/man/man1/xbc.1    -- the man-page of the compiler
/usr/share/man/man1/xbbc.1  -- the man-page of the bytecode compiler
/usr/share/man/man1/xbvm.1  -- the man-page of the virtual machine
/usr/share/man/man1/xb2c.1  -- the man-page of the X11-Basic to C translator
/usr/share/man/man1/bas2x11basic.1 -- the man-page of the ANSI to X11-Basic  translator


   After having installed the package, you can execute the interpreter with xbasic or read the

man pages with man  xbasic or man  x11basic.
   The documentation will be installed in the /usr/share/doc/packages/X11Basic/ direc-
tory (at least on my system) and you can ond the following oles:



4

     __________________________________________________________________2.1.__Installing_X11-Basic___________



-rw-r--r--     1005  ACKNOWLEGEMENTS       -- acknowlegements
-rw-r--r--       46  AUTHORS                -- contact addresses of the author
-rw-r--r--    17982  COPYING                -- copyright information
-rw-r--r--     2960  INSTALL                -- installation instructions
-rw-r--r--     1752  README                 -- short description
-rw-r--r--      169  RELEASE_NOTES         -- release notes
-rw-r--r--  164366  X11-Basic-manual.txt -- the manual
drwxr-xr-x     1024  editors/               -- files for editors
drwxr-xr-x     1024  examples/              -- few example programs



Debian based distributions


As with Ubuntu linux the popularity of debian based linux distributions has dramatically in-

creased in the recent past. Therefore X11-Basic also comes in packages called (e.g.) x11basic_1.19-1_i386.deb.

Usually you can very easily install the ole from a ole browser with simply double clicking on

it. Also a dpkg  -i  x11basic_1.19-1_i386.deb will do. The ole system structure should

be similar to what is described in the previous chapter (explaining the RedHat packages), so

you should expect to ond the same oles at the same place.



Other linux and UNIX distributions


Maybe RPM is supported for your distribution, then you can follow the instructions above. If

not, you might look for a debian package. Some binary distributions come as a zip ole (like the

TomTom version). In these cases they are accompanied by a README or other instructions

how to install them.

   For all other systems you will have to get the source-package X11Basic-1.19.tar.gz and

compile the sources (which is very easy, by the way). This should work for all linux distribu-

tions, and probably with little modiocations also for HPUX, for DEC/alpha, for MAC/OSX,

for SUN/SOLARIS and FreeBSD and maybe others. Also X11-Basic compiles on Cygwin.

   In order to compile X11Basic, you will need the following:


    fflA C compiler, preferably GNU C (but some ANSI C compilers, like DEC's will do),

    ffla `csh'-compatible shell,

    fflX11R5 or R6 libraries (for the graphics) or a framebuoeer device or the SDL library,

    ffl(optionally) the readline ncurses and the termcap library,

    ffloptionally the ALSA sound library (libasound) and/or the SDL framework.


   These will suOEce to get you started. If one ore more of these libraries are not present on

your system, the configure and make scripts will try to compile a version, which does not

need them (hence leaving out some of the functionallity of X11-Basic.).



   1.  Unpack X11Basic-1.19.tar.gz with


       tar  xzf  X11Basic-1.19.tar.gz



                                                                                                5

2.__Usage_________________________________________________________________________________________



   2.  go into the X11Basic-1.19 directory and do a


       ./configure

       make

       sudo  make  install



Thats all you will have to do (for more detailed installation instructions read the ole INSTALL,

which comes with the package.).

   If the `conogure' script fails, please contact me (kollo@users.sourceforge.net) and

send me the output it generated (conog.log). I am going to try to help you to ox the problem.



Crosscompiling other Versions of X11Basic


The Makeole allows you to also produce the compiler (make  xbc), the bytecode compiler

(make  xbbc), the virtual machine (make  xbvm), and the X11-Basic to C translator (make  xb2c).

If you need the separate libraries you can do a make  x11basic.a and a make  libx11basic.so.

These libraries are f.ex. needed by the compiler xbc.

   If you want to make a version, which use the framebuoeer (instead of the X-Server) do a

make  fb. If you want a version using the SDL library, do a make  sdl.

   The TomTom distribution can be generated with make  TomTom.  (The ARM-linux cross-

compiler is needed).

   The MS WINDOWS distribution can be generated with make  windows. (The mingw cross-

compiler is needed).



The Bytecode Compiler and the Virtual Machine


First of all, if you just want to compile a BASIC program to fast machine language excecuta-

bles, you need not bother nor deal wit the programs mentioned. The compiler xbc will do all

for you (>-virtualm).

   Both programs xbbc and xbvm are part of the compilation process. The idea is to increase

the excecution speed of X11-Basic programs a lot by compiling it to a bytecode, this still

being portable.  The bytecode itself is interpreted by a bytecode interpreter (also called a

virtual machine). This virtual machine needs to be present on the target computer, and then

all bytecode programs can be used there.  Thus the X11-basic compiler need not deal with

dioeerent target machine architectures.

   The bytecode not only can be run much faster than the interpretted BASIC source code, but

the conversion to bytecode is a real compilation. The step to assembler or machine code is not

far. Also a conversion to C or to JAVA or any other language will be straigt forward, although

the code will practically not be readable to humans anymore. As with JAVA, the bytecode is

platform independant and can be run on any system, which has a virtual machine ported to.

   Also one point to mention (whether this is a feature or a disadvantage): X11-basic bytecode

can not be converted back into source code (.bas).



6

     __________________________________________________________________2.1.__Installing_X11-Basic___________



  Please try the bytecode compiler out and maybe you want to report errors etc. Quite a lot
of the example programs are known to work well with the bytecode compiler: e.g. mandel-
simple.bas.  The bytecode will execute about 10 times faster than the interpreted program.
Here is how to use it:


xbbc myprogram.bas -o b.b
xbvm b.b



Compiling via the X11-Basic to C translator


It is possible to translate the bytecode generated by xbbc to C source code and onally compile

this intermediate C-source to a native excetutable (e.g. with the GNU C compiler gcc). This

way the program will be a real native excecutable which again runs even a bit faster that the

bytecode interpretted by the virtual machine.

   Such programs can be linked against the dynamic library (.so or .dll) or the static library (.a

or .lib). In the end they run independently of any interpreter or virtual machine. In addition

to the pseudo-compile method (at the moment this is still the default method for xbc, if you

do not specify the -virtualm option), this is another real compilation which produces code,

which runs up to 60 times faster than the interpreted or pseudo-compiled programs.  This

makes X11-Basic really fast and much faster than other competitors.

   The C-sources depend on the header ole xb2csol.h (normally installed under /usr/include/x11basic/)

the x11basic.a or libx11basic.so libraries, which therefor should be present. The com-

piled programs will be much faster than the interpreted ones and even a bit faster that the

bytecode processed ones (see xbbc ) and ( xbvm).  However, some restrictions to the code

apply. Which means: not every program, which can be interpretted, can also be compiled.

   Xb2c processes one input ole.  The SuOEx of the input ole is usually .b (a bytecode ole

produced by xbbc(1) The default output ole name is 11.c but you can specify alternate names

with the -o option.

   Actually this compiler is really a translator.  This translator is not yet highly optimized.

There is no way to recreate the .bas source code from the c ole. But still the C ole is platform

independent and can be compiled on all platforms, where a C compiler is available (als the

x11basic library is ported to).
   Here is how to use it:


xbbc myprogram.bas -o b.b
xbvm b.b
xb2c b.b -o 11.c
gcc  11.c -lm -lX11 -lx11basic -lasound -lreadline -o a.out


   For convinience, a


xbc -virtualm myprogram.bas -o a.out


   will exactly do the same.



                                                                                                7

2.__Usage_________________________________________________________________________________________



Support


If you have trouble with X11-Basic, you may send me a mail or browse the faq. On Source-

forge there is a forum (bug reports, patches, request for help, feature requests), as well as a

WIKI about X11-Basic.

   If you have trouble with some X11-Basic-command or program, you should create a min-

imum sample program to reproduce the error; please keep this sample program as small as

possible. Then take the program and send it to me. Add a short description of you problem,

containing:



    fflWhich Operating system are you using: Windows (95, 98, me, xp, NT, 2000) or UNIX

       (linux, solaris, FreeBSD, HPUX ...) ?

    fflHow does the program behave on your computer? What did you expect?

    fflWhich version of X11-Basic are you using? Please try the latest one!



2.2.    The X11-Basic Interpreter



There are several ways to start the X11-Basic interpreter.

   The simplest way is to just start it by the command xbasic. Then you can use the interpreter

in interactive mode. Just try to enter some X11-Basic commands. The interpreter itself also

accepts several options via the commandline.  Please also read the man-page (man  xbasic)

for more details.



2.2.1.   Command line parameters


The X11-Basic Interpreter takes some command line parameters.

   Command line parameters are as follows:



xbasic <olename>                   run Basic-Programm [input.bas]

-l                                    load only, don't execute

-e  <command>                       excecute basic command

eval  <expression>               evaluate numerical expression

daemon                             swich ooe prompting and echoing

-h  help                            print a short help

help  <topic>                     Print help on a spcioc topic



   The program does not insist on its name, the person installing can name it xbasic, x11basic

or any other name. However xbasic is the preferred name for the executable. When you start

the program without arguments it tells you the dioeerent options.



8

     ________________________________________________2.3.__Using_Syntax_highlighting_with_nedit_____________



Examples:


   xbasic  testme.bas

   xbasic  -l  dontrunme.bas

   xbasic  -e  'alert  1,"Hallo  !",1,"  OK  ",b'

   xbasic  --eval  1+3-4*3



2.2.2.   X11-Basic as daemon


The commandline option daemon forces the interpreter to run in daemon-mode (with no

terminal connected). No prompt is given and the input is not echoed back.



Example:

To run the X11-Basic interpreter on a tcp-socket on port 1371 create a new user called xbasic
and insert


        --- in /etc/inetd.conf: ---
        xbasic stream tcp nowait xbasic /usr/sbin/tcpd /bin/xbasic --daemon
        --- in /etc/services: ---
        xbasic           1371/tcp
        ---



   Please note that this is not recommended since xbasic would open several security holes on

your system.



2.2.3.   X11-Basic as shell


X11-Basic programs can be excecuted like shell scripts. Make sure that the very orst line of

your X11-Basic program starts with the characters '#!' followed by the full pathname of the

X11-Basic inperpreter xbasic (e.g. '#!/usr/bin/xbasic'). This she-bang-line ensures, that

your UNIX will invoke xbasic to execute your program. Moreover, you will need to change the

permissions of your X11-Basic program, e.g. chmod  755  myprog. After that your program

can simply be executed from your shell and the interpreter works in the background like shells

do.



2.3.    Using Syntax highlighting with nedit


NEdit, the full featured, plain text Nirvana editor1 is a GUI style text editor for workstations

with the X Window System. NEdit provides all of the standard menu, dialog, editing, mouse

support, macro extension language, syntax highlighting, and a lot other nice features (and
     _____________________________________________
  1http://nedit.org/



                                                                                                9

  2.__Usage_________________________________________________________________________________________



Figure 2.1 :The Nirvana Editor with syntax high-
            lighting for a X11-Basic program.



  extensions for programmers). In short, it has everything you want to develop your X11-Basic

  programs.

     If you like to use nedit as your favorite editor, a nedit.defs ole comes with this package.

  This enables syntax highlighting for X11-Basic programs in nedit (see og. 2.1).



  2.4.    The xbc (pseudo) compiler


  The X11-Basic package is shipped with the X11-Basic compiler xbc, which makes stand-

  alone binaries out of Basic source code. It also can produce .o object oles, shared objects (or

  DLLs) and bytecode.

     There are three methods on how the compilation is done:


  1. The pseudo method:      The sourcecode is bundled together with the X11-Basic interpreter

         into one excecutable ole, which can be run.  Excecution speed is not faster than the

         interpretted sourcecode, but all programs will run and behave exactly the same as if

         they were run in the interpreter. Currently this method is not available for WINDOWS

         since gcc is used to do the compression and linking with the X11-Basic runtime library.

  2. The bytecode method:      The sourcecode is compiled into bytecode and this bytecode is

         bundled together with the X11-Basic virtual machine into one excecutable ole, which

         can be run.  Excecution speed is much faster than the interpretted sourcecode because

         now a real compilation has been don.  However, some restrictions to the compiled

         sourcecode apply, e.g. GOTOs across Procedures are not possible, as well as EVERY

         and AFTER will currently not work. So some obscure code will probably not compile

         correctly. However, this method is recommended as the preferred method.

  3. The independant method:       The sourcecode is compiled to bytecode and then translated to

         C sourcecode, which onally will be compiled using a C-Compiler (e.g. GNU gcc). This



  10

     _______________________________________________2.5.__The_WINDOWS_Version_of_X11-Basic__________________



       is the preferred method on UNIX systems where a development environment (gcc and

       development packages for libraries) is available. On WINDOWS this is usually not the

       case, so method 3 can not be used.  On ubuntu linux you will need to install at least

       following packages: gcc, libreadline-dev, ncurses-dev, libasound-dev and maybe others.

       If done so, the compiler with method 3 will work one. This is my preferred method.


In all three cases, another advantage is that it is quite hard to extract a full running *.bas File

from the binary, since even with method 1 the code is compressd in a way.

  To select method 3 on UNIX/linux systems, use the commandline option -virtualm. The

windows version of the compiler will autonmatically use method 2 only.

  The compiler xbc itself is written in X11-Basic and relies on the presence of xbbc and xv2c

(for methods 2 and 3). You can ond the compiler in examples/compiler/xbc.bas. Yes, the

compiler compiles itself. Yust make sure you have built the shared library libx11basic.so

and the library for static linking before (make  lib;  make  x11basic.a) and moved it to

/usr/lib. Then do


  xbasic xbc.bas


  See the man page xbc(1) for further information on the compiler.



2.5.    The WINDOWS Version of X11-Basic


After you have run the setup program, X11-Basic can be invoked in three ways:


   1.  Choose "X11-Basic" from the start-menu:  xbasic.exe will come up with a console

       window and the interpreter waits for commands to be typed in right away.

   2.  Click with the right mousebutton on your desktop.  Choose "new" from the context-

       menu that appears; this will create a new icon on your desktop. The context-menu of this

       icon has three entries "Execute", "Edit" and "View docu" (which shows the embedded

       documentation, if any); a double-click executes the program.

   3.  Create a ole containing your X11-Basic-program.  This ole should have the extension

       ".bas". Double-click on this ole then invokes X11-Basic, to execute your program.

   4.  the compiler can be invoked via the Start->Programs->X11-Basic menu. It has a rudi-

       mentary graphical user interface, which will ask for the .bas ole to be compiled and later

       for the name of the excecutable to be written to.



2.6.    The Android Version of X11-Basic


A version of X11-Basic ready to be installed on Android Smartphones and tablets is available

on the Android Market. The app registeres itself as a viewer to .bas and .b oles on the system.

So from any ole browser, basic programs can be started with a single touch. If you open the

X11-Basic app itself, you can directly type in commands with the virtual keyboard. Pressing



                                                                                               11

2.__Usage_________________________________________________________________________________________



the MENU button gives you the option to load and run Basic programs, Stop and continue ex-

cecution, open the keyboard (if its has vanished from the screen) and compile basic programs

into bytecode. The virtual machine is integrated, so bytecode compiled code can be run. De-

pending on the endianess of the processor architecture of the platform, bytecode may or may

not be compatible with thouse, produced on a LINUX PC or WINDOWS machine. Standard

output is rendered directly into the graphics screen with a VT100 compatible terminal emula-

tion. Not all graphics features have the same result than on a X11-Windows Installation, the

whole screen counts as a single fullscreen window. Finally shortcuts to X11-Basic programs

can be placed on the desktop, so they can be started with one click. Also X11-Basic is regis-

tered as a method to open oles (from a ole browser). A small selection of example programs

is included in the android package.  If you like to have some fun with a game, try to install

ballerburg.bas.



2.6.1.   Usage on Android devices


Android deviced usually have a BACK Butten, a HOME button and a MENU Button.



    fflThe HOME Button suspends X11-Basic and returns to the Android Desktop. Selecting

       the X11-Basic app again will resume it.

    fflWith the BACK button, a running BASIC program will be stopped.  If you press the

       back button again, the X11-Basic interpreter quits.

    fflThe MENU Button opens a menu with following options: About, LOAD Program, RUN

       program, STOP/CONT program, NEW, Keyboard, Paste from Clipboard, Info/Settings,

       Editor, Compile and Quit.


       About   Show information about he current version of X11-Basic, News ans Impressum.

       Load ... opens a oleselector which displays all .bas and all .b Programs in the Directory

            /mnt/sdcard/bas.  The selected program will be loaded into memory.  A program

            eventiually stored there before, will be overwritten.  You can display the source-

            code by entering LIST.

       Run  will simply start the excecution of a program which has been loaded before. (You

            can also enter RUN)

       STOP/CONT      will interrupt the excecution of the program or resume it.  (you can also

            press the BACK buton once to stop the program, and you can enter CONT to

            continue it).

       New   will delete the program from memory.

       Keyboard    will show or hide the on-screen virtual keyboard. If you have a hardware or

            external USB/Bloetooth keyboard, you can also enter commands with that.

       Paste from Clipboard     will paste any text you have copied to the clipboard (from any

            other Application) before.

       Info/Settings  will open a Dialog with additional Information, Links, and Preference

            Settings.



12

     __________________________________________________2.7.__The_TomTom_Version_of_X11-Basic________________



       Editor  will excecute a 3rd party Text editor (e.g. Ted if installed) to edit the program

            currently loaded. if no program was loaded, the default ole name will be new.bas.

            NOTE: After having saved and closed the Text editor, the modioed program needs

            to be reload (manually) into X11-Basic Interpreter.

       Compile   will compile the basic source code into bytecode which can be excecuted

            about 20 times faster.  The bytecode will be saved with .b extension in the bas/

            folder.

       Quit  will terminate the X11-Basic interpreter.

  To place a shourtcur to a X11-Basic program (.bas or .b) on the Desktop long-tap on the

desktop page, select X11-Basic - create shortcut. You can select a ole from the /mnt/sdcard/bas

folder which then is placed in the desktop.



2.7.    The TomTom Version of X11-Basic


On http://www.opentom.org/X11-Basic you will ond a Version of X11-basic which has

been specially compiled for tomtom navigation devices.  They run linux based on the ARM

processor.  No X11 Graphics is needed, since X11Basic comes with a native framebuoeer

graphics support.  Not all graphics features have the same result than on a X11-Installation,

but it is suOEcient to run most of the programs on the embedded devices.  A ready made

package as well as installation instructions can be found on that web-side.



2.8.    The ANSI-Basic to X11-Basic converter


You will ond a simple ANSI-Basic to X11-Basic converter (bas2x11basic.bas) in the examples/compiler/

directory. It helps convertig old (real) Basic Programs with line numbers and multiple com-

mands per line to the X11-Basic structure. Because there are so many dioeerent BASIC ver-

sions around, in most cases you will have to edit these oles produced manually. But most of

the work will already have been done by this converter.  For details on the compatibility to

other dialects of BASIC, please read chapter 7.

   Example:

xbasic  bas2x11basic.bas  ansibasic.bas  -o  newname.bas

   For further options try xbasic  bas2x11basic.bas  --help and read the man-page bas2x11basic(1).

   A compiled version of the ANSI-Basic to X11-Basic converter is included in the X11-Basic

binary packages.



2.9.    Using GFA-BASIC programs


GFA-Basic programs have a tokenized binary format and usually the suOEx .gfa. This binary

format has to be decoded to ASCII oles befor they can be used with X11-Basic.  This job



                                                                                               13

2.__Usage_________________________________________________________________________________________



is done by the utility gfalist (sometimes also called gfa2lst or ons-gfalist) by Peter

Backes1.

   The resulting GFA-Basic programs usually need some manual corrections.  Very simple

ones may well work one with X11-Basic without. For details on the compatibility, please read

chapter 7.2.



________________________________________
  1http://titan.plasma.xg8.de:8080/"rtc/



14




3.     X11Basic:  Getting  Started



This chapter describes all you need to know to write your own programs in X11-Basic.



3.1.    Introduction to this Dialect of BASIC



The programming language BASIC has been around since the 1960s. BASIC is an acronym

and it stands for Beginners All Purpose Symbolic Instruction Code.  BASIC was originally

designd to be a programming language that is easy to use for a wide range of projects by

anyone. X11-Basic is a dialect of this but it is not a BASIC in its original form. It is more a

mix of classic BASIC with structured languages like PASCAL and Modula-2. The Syntax of

X11-Basic is oriented to the famous GFA-BASIC which was developped for the ATARI ST in

1985. GFA BASIC (as of version 3.5, the most popular one) was, by the standards of its time,

a very modern programming language.  Like X11-Basic does, it does without line numbers

and has a reasonable range of structured programming commands.

   X11-Basic has a lot of features which make the language dioeerent from the original (ANSI-

Basic) intention. As with GFA-Basic these modiocations help developing programs with hav-

ing a more structured look and which make use of the more modern graphical user interfaces

available on compunters since the mid 1980's:



    fflone command or declaration per line for better readability ,

    ffluse of subroutines (procedures) and functions with local variables and parameter passing

       by value or reference,

    ffldata typing and arrays,

    fflpowerful loop and program AEow constructs,

    fflole and socket operations,

    fflcommands to directly access the OS

    fflcommands for using X11-Windows graphics and a port of the AES (the graphical user

       interface from the ATARI ST), allowing for easy use of graphics in your program

    fflcommands for direct memory manipulation, allowing you to access the machine almost

       as with machine language

    fflpossibility to merge source code for libraries and reuse

    ffla compiler is also available.



                                                                                               15

3.__X11Basic:_Getting_Started_____________________________________________________________________



3.2.    Interpreter vs Compiler


X11-Basic programs (or scripts) are interpreted by default.  This means the so-called inter-

preter takes each line of your code and looks what to do with it. The compiler does it dioeer-

ently, it will take your code once, translate it into directly executable machine code resulting in

a more speedy program execution as the step for command lookup does not appear anymore.

The compiled program just can be executed out of the box.  The advantage of an interpreter

is that you can directly test and run your program without running a compiler orst.  This is

helpful while developing but of course a compiler is available as well allowing you to produce

rather fast machine code from your X11-Basic program.



3.3.    Your orst X11-Basic program


Open your favorite editor and type the following line of code into the editor.


PRINT  "Hello  X11-Basic!"


   Now save the ole as "'hello.bas"' and run the interpreter with


xbasic  hello.bas


   X11-Basic should not complain. If it does, check carefully for typing mistakes. The Pro-

gram now should print out your hello message at the console or in the console window the

interpreter was started from. It will not return to the shell, but just prompt for aditional com-

mands. Now type


>  quit


and you return to the shell.

   Of course you can include the quit command in your hello.bas:


PRINT  "Hello  X11-Basic!"

QUIT


Now the program always returns to the shell promt when done.

   Now lets compile it:


xbbc  hello.bas  -o  hello.b


will produce a bytecode binray hello.b.

   You can run this:


xbvm  hello.b


will give you the save output Hello X11-Basic!

   Real compilation will need two more steps:



16

     _______________________________________________________________________3.4.__General_Syntax____________



xb2c  hello.b  -o  hello.c


  produced a translated C-sourceole hello.c.

  If you have the gnu C compiler available you can compile it to an independant excecutable

program called hello with:


gcc  hello.c  -o  hello  -lm  -lX11  -lx11basic  -lasound  -lreadline


  There you go. Your program can now directly be started with

./hello



3.4.    General Syntax



Appending lines


Since for a structured programming language like X11-Basic each line must not contain more

than a single command, some restrictions apply for the program code.

   With many editors a limitation on the maximal line length applies (e.g.  4096 charac-

ters/line). In X11-Basic a single command may in very rare cases consist of more than 4096

characters (e.g. by assigning an array constant to an array). Therfor a possibility of splitting

lines into two (or more) has been implemented. If the last character of a line is a '"' (it must

be really the last character of the line and may not be followed by a space character!), the

following line will be appended to this line by replacing the '"' and the following newline

character by spaces.

Example:

PRINT  "Hello,";    "

        "  thats  it"

will be treated as:

PRINT  "Hello,";"  thats  it"

   Please note: The '"' character must be placed at a position within the command where a

space would be allowed, too.



Comments


A comment can be inserted into your program code with the REM command or the abbrevia-

tion '. Also the '#' as a orst character of the program line reserves the rest of the line for a

comment. Anything behind the REM will be ignored by X11-Basic.

   The REM stands for remark and is a generic comment. Comment your programs and you

will be able to understand it later.

   If you want to place comments at the end of a line, they have to be prefaced with '!'.

Example:



                                                                                               17

3.__X11Basic:_Getting_Started_____________________________________________________________________



'  This  is  a  demonstration  of  comments

DO      !  endless  loop

LOOP   !  with  nothing  inside


These end of line comments can not be used after DATA (and REM).



3.5.    The very BASIC commands: PRINT, INPUT, IF and GOTO



The PRINT-command is used to put text on the text screen. Text screen means your terminal

(under UNIX) or the console window (under Windows).  PRINT is used to generate basic

output, e.g. text, strings, numbers, e.g. the result of a calculation. Some basic formatting is

possible.

   With the INPUT command you let the user input data, p.ex. numbers or text.

   The IF command let the program do dioeerent things depending on the result of a calculation.

   With GOTO you can branch to a dioeerent part of your program.  GOTO, despite its bad

reputation ([goto considered harmful]), has still its good uses.

   Besides these four very basic commands (which are really standard basic commands, and

you can already write very handy calculations with only these four commands) X11-Basic has

many more features which make life easier and your programs more user friendly.



3.6.    Variables



Variables in BASIC programming are analogous to variables in mathematics. Variable identi-

oers consist of alphanumeric strings. These identioers are used to refer to values in computer

memory. In the X11-Basic program, a variable name is one way to bind a variable to a memory

location; the corresponding value is stored as a data object in that location so that the object

can be accessed and manipulated later via the variable's name.

   X11-Basic uses two scopes for variables: global (which is the default) and local.

   Global variables can be modioed from anywhere within the program, and any part of the

program may depend on it. A global variable therefore has an unlimited potential for creating

mutual dependencies, and adding mutual dependencies increases complexity. However, in a

few cases, global variables can be suitable for use. They can be used to avoid having to pass

frequently-used variables continuously throughout several functions, for example.

   The use of global variables makes software harder to read and understand. Since any code

anywhere in the program can change the value of the variable at any time, understanding the

use of the variable may entail understanding a large portion of the program. They can lead to

problems of naming because a global variable makes a name dangerous to use for any other

local or object scope variable. A local variable of the same name can shield the global variable

from access, again leading to harder to understand code. The setting of a global variable can

create side eoeects that are hard to understand and predict.  The use of globals make it more



18

     ______________________________________________________________________________3.6.__Variables__________



diOEcult to isolate units of code for purposes of unit testing, thus they can directly contribute

to lowering the quality of the code.

  Because of all this, X11-Basic also provides local variables, which live only within a certain

function or procedure and their context.

  You can refer to a variable by giving its name in the place you want the value of the variable

to be used. X11-Basic will automatically know where to store the data and how to deal with

it.  It is also important to tell X11-Basic what sort of data you want to store.  You can have

variables that store only numbers but also variables that deal with a character or a whole string,

a line of text for example. The following valid line of X11-Basic code will create a variable

called x for you and assign it the value of 10.



x=10



  You learn here 3 important things. First your variable has a name, x in this case, secondly

you state that you want to do something with this variable, an assignment with the = sign, the

last thing is what you want to do with this variable.  You give it the value 10 here.  Such an

assignment will overwrite any old data that has been stored before in that variable. As long as

you don't assign a value to a variable, it will hold a default value, 0 in most cases.



3.6.1.   Data types


Now how you see that this variable x stores a number? How does X11-Basic know that you

want to deal with a number? Easy - by the way the name of the variable has been written. To

distinguish between dioeerent ways of data types X11-Basic appends a special typing sign as

a suOEx to the variable name to distinguish between several ways to store data in variables.

   The X11-Basic interpreter uses 64-bit AEoating point variables, 32-bit integer variables, char-

acter strings and arrays of these variables of arbitrary dimension. A declaration of the variables

and of their type is not necessary (except for arrays > DIM), because the interpreter recognizes

the type of the variable from the suOEx: Integer variables have the suOEx %, character strings a

$, arrays a (). Variables without suOEx are treated as AEoat. Pointers are integers, function calls

are marked by @. Logical expressions are also of type integer. It is important that variables

with a special suOEx are dioeerent from those without.



3.6.2.   Variable naming


You can use all letters and numbers for your variable names.  Spaces are not allowed but

underscores inside the variable name.  X11-Basic limits you only in the following ways:  a

variable may not begin with a number, only with letters.  Avoid to name your variables like

X11-Basic commands.  It will work but it can also cause troubles while typing.  As a rule,

never try to assign values to X11-Basic system variables (like TRUE, FALSE, TIMER, PC,

TERMINALNAME$). The values indeed will be assigned, but you never can use the assigned

values, since always the internal values will be used.



                                                                                               19

3.__X11Basic:_Getting_Started_____________________________________________________________________



   Valid variable names look like the following: x, auto%, lives%, bonus1%, x_1, city_name$,

debit Invalid variable names look like this and X11-Basic will complain: _blank, 1x, ?value%,

5s$. Always remember: begin your variable names with a letter from A-Z and you are on the

safe side!

   Variable names and commands are case insensitive. Each name is bound to only one kind

of variable; A$ is a whole dioeerent variable(value) than A which is dioeerent from A(1,1) or

A$(1,1).

   Space between commands will be ignored, but note that no space is allowed between the

name of a variable or command and the '(' of its parameter list.  So, ASC("A") is good,

ASC(       "A"       ) also, but ASC  ("A") isn't.



Examples:



integer variables:            i%=25

                              my_adr%=varptr(b$)

                              b%=malloc(100000)

AEoat variables:               a=1.2443e17

                              b=@f(x)

character strings:             t$="Hello  everybody  !"

oelds and arrays:             i%(),a(),t$(),  [1,3,5;7,6,2]



3.6.3.   Numbers


X11-Basic uses integer numbers (32 Bit) ranging from -2147483648 to 2147483647. Floating

point numbers are 64Bit IEEE 754 standard values.

   Number (constants) can be preceded by a sign, + or -, and are written as a string of numeric

digits with or without a decimal point and can also have a positive or negative exponent as a

power of 10 multiplier e.g.

   -253 67.3 0.25 -127.42E-3 -1.3E7 1

   Integer numbers, with no decimal fraction or exponent, can also be in either hexadecimal or

binary. Hexadecimal numbers should be preceded by $ (or 0x) and binary numbers preceded

by %, e.g.

   %101010 -$FFE0 0xA0127BD -%10001001 %00011010



3.6.4.   Strings


String variables can contain sequences of characters (bytes) of arbitrary length.  There is no

length limit for a string other than the virtual memory of the machine.  Strings generally

contain ASCII text, but can hold arbitrary byte sequences, even characters that have the ASCII

code zero. In other words a string is a collection of bytes of certain length. You can treat strings



20

     _________________________________________________________3.7.__Arithmetics_and_Calculations____________



as arbitrary length of binary data if you need. Strings are automatically elastic, meaning they

automatically resize to contain whatever number of bytes are put into them.  When a string

resizes, its location in memory may change, as when a longer string is assigned and there is

insuOEcient room after the string to store the extra bytes.

  A wealth of intrinsics and functions are provided to support eOEcient string processing and

manipulating.

  String variables are distinguished by the $ suOEx.

  String constants are enclosed with pairs of "" (double quote).

  There is a way to include special characters into string constants. The usual way in BASIC

is to split the string into sub strings and concatenate the parts during run time, like in the code

fragment:

  st$="This is a special string, containing a bell character at the end"+chr$(7)

  By the way, the double quote charackter can be added with chr$(34).



3.6.5.   Arrays


Arrays are memory locations that store many values at the same time. While normal variables

store a single value at a time, an array variable can store many values. The values are accessed

via the name of the variable and the appropriate indices. The index or indices follow the name

of the variable between ( and ).

   There is no limit on the number of indices (the dimension).  You can use as many as you

like. Also there is no limit on the index values other than the index values have to be positive

integer and that memory may limit the array sizes.

   X11-Basic arrays can contain variables of any data type, including strings. All arrays, even

multi-dimensional arrays, can be redimensioned without altering the contents. A special fea-

ture of X11-Basic is the implicit dimensioning of arrays and the existance of array constants.

You may deone an array by using the DIM command.  You might also deone the array by

an assignment like a()=b() if b() already has been DIMed or by a()=[1,2,3,4;6,7,8,9]

asigning an array constant (In this example a 2 dimensional array will be created and the rows

are separated by ';').



3.7.    Arithmetics and Calculations



X11-Basic handles numbers and arithmetic: You may calculate trigonometric functions like

SIN() or ATAN(), or logarithms (with LOG()). Bitwise operations, like AND or OR are available

as well as MIN() and MAX() (calculate the minimum or maximum of its argument) or MOD or

INT() (reminder of a division or integer part or a number).  Many other statements give a

complete set of math functions.



                                                                                               21

3.__X11Basic:_Getting_Started_____________________________________________________________________



3.7.1.   Expressions and Conditions


Expressions     are needed to calculate values. The simplest expression is a numerical or string

       constant. More complex expressions may contain constants, variables, operators, func-

       tion calls and possibly parentheses. The expression format used by X11-Basic is iden-

       tical with that of many other BASIC packages: The operators have precedence of the

       usual order and you can alter the order of operator evaluation using parentheses. Here

       is an example numeric expression following after a PRINT statement:



       PRINT  (X-1)*10+SIN(x)



Conditions    and expression are the same in X11-Basic, FALSE is deoned as 0 and TRUE

       as -1.  Those deonitions are deoned in defs.h and could be changed, but that is not

       recommended. Because BASIC doesn't have seperate boolean operators for conditions

       and expressions, using an boolean operator (AND,OR,XOR,NOT) may give spurious

       results. When on each site a value of an 0 or -1 is used, it's assumed as an condition, if

       it's not, it considered an expression. Problems could occure if you use boolean operators

       with negative numbers, but that is also unrecommended because the outcome of such an

       expression is highly platform depended.



3.7.2.   Operators


X11-Basic provides operators for numerical expressions, character strings and arrays of either

type and any dimension.



Numerical Operators


Numerical operators are roughly categorized in following categories:


    fflarithmetical operators: ^  *  /  +  -

    fflcomparison operators: =  <>  <  >  <=  >=

    ffllogical operators: NOT  AND  OR  XOR  ...


   X11-Basic recognizes the following operators, in order of falling precedence (the prece-

dence of BASIC operators aoeects the order of expression evaluation):


                    ___________________________________________________________
                    |  Order  |Operator  |  Description                     |
                    |_________|__________|__________________________________|__
                    |       1  |(  )        |Parenthetical expression        |
                    |          |            |                                |
                    |       2  |^           |Exponent/power                 |
                    |          |            |                               |
                    |       3  |          | Sign (negation)                  |
                    |          |          |                                  |
                    |       3  |+          |Sign                             |
                    |          |           |                                 |
                    |       4  |NOT       | Bitwise not                      |
                    |          |          |                                  |
                    |       5  |=           |Divide                           |
                    |          |            |                                 |



22

    _________________________________________________________3.7.__Arithmetics_and_Calculations____________



                   |       5  |*           |Multiply                         |
                   |          |            |                                 |
                   |       5  |"           |Integer division                 |
                   |          |            |                                 |
                   |       5  |MOD      |  Modulus (rest of division)       |
                   |          |         |                                   |
                   |       6  |+           |Add                             |
                   |          |            |                                |
                   |       6  |-           |Subtract                         |
                   |          |            |                                 |
                   |       7  |<<        | Bitwise shift to the left          |
                   |          |          |                                    |
                   |       7  |>>        | Bitwise shift to the right        |
                   |          |          |                                   |
                   |       8  |=           |Logical "equals"                |
                   |          |            |                                |
                   |       8  |<>         |Logical "not equal"             |
                   |          |           |                                |
                   |       8  |<           |Logical "less than"              |
                   |          |            |                                 |
                   |       8  |>           |Logical "Greater than"          |
                   |          |            |                                |
                   |       8  |<=         |Logical "less than or equal"     |
                   |          |           |                                 |
                   |       8  |>=         |Logical "greater than or equal"  |
                   |          |           |                                 |
                   |       9  |AND      |  Bitwise and                     |
                   |          |         |                                  |
                   |       9  |OR        | Bitwise or                       |
                   |          |          |                                  |
                   |       9  |XOR      |  Bitwise xor                      |
                   |          |         |                                   |
                   |       9  |IMP       | Implies                          |
                   |          |          |                                  |
                   |       9  |EQV       | Equivalence                     |
                   |          |          |                                 |
                   |      10  |=           |assignment                      |
                   |__________|____________|________________________________|__



Addition and subtraction operators      are both binary and unary operators.  In their unary

      form they are used out of the precedence orders.  Unary operators are always applied

      orst, unless parentheses drive dioeerent calculation order.

The power operator ab     calculates the b-th power of a. he actual implementation of the power

      operator always uses to pow() function, which always treats all operants as real numbers.

      Under some circumstances it might be more optimal to use a*a instead of a2

The multiplication operator    multiplies the operands. If any of the operands is an array then

      the result will be an array.

The division operator    divides the orst operand with the second.  If the second operand is

      zero then an error will occur.

The integer division operator    divides the orst operand with the second.  The calculation is

      performed using integer numbers and the result is truncated towards zero.

Bit-wise and logical NOT    This unary operator calculates the logical negate of the operand.

      The calculation is done on integer numbers, thus the operand is converted to integer

      value. The operator inverts each bit of the operand.

Logical operators (and, or, xor)   These operators can be used for both logical and bit-wise

      operators.  X11-Basic does not have a separate type for logical values.  The logical

      TRUE is represented as integer value -1 (all bits set to 1) and the logical FALSE is 0.

      The operators and, or and xor perform the calculation on integer values.  If any of the

      operands is not integer it is converted to integer value before the operation takes place.



                                                                                              23

3.__X11Basic:_Getting_Started_____________________________________________________________________



       The operations are performed on each bit of the operands.



Operators for Character Strings


+  conjunction, links two strings together.

       Example:  suppose a$="X11", b$="-" and c$="BASIC", so d$=a$+b$+c$ results in

       "X11-BASIC".

< <= = => >    comparison functions belong to numerical (boolean) functions because the result

       is a number.

&   the eval operator evaluates command or expression which is given by the String.



Rules for comparison of strings:



   1.  Two strings are equal if all the characters inside are identical (also spaces and punctua-

       tion marks).

       Example:

       "  123  v  fdh.-,"  =  "  123  v  fdh.-,"

   2.  The comparison of size operates also character by character until one of them is smaller

       or a the strings ends orst, this is the smaller one.

       Examples:



       "X11">"X11"       result:   0

       "X11"<"x11"       result:  -1

       "123"<"abc"       result:  -1

       "123">"1234"      result:   0



The eval-Operator &:   The &-operator followed by a string evaluates it for program code.
Example:


REM generate ten times the command 'print a$'
CLR i
a$="print a$"
label1:
INC i
IF i>10
  b$="label2"
ELSE
  b$="label1"
ENDIF
&a$
GOTO &b$
label2:
END



   To program like this can produce a really unreadable code but this is BASIC.



24

     _________________________________________________________3.7.__Arithmetics_and_Calculations____________



3.7.3.   String processing


X11-Basic has the usual functions to extract parts from a string:  LEFT$(),  MID$() and

RIGHT$().

   If you want to split a string into tokens you should use the commands WORT_SEP or SPLIT.

   There is quite a bunch of other string-processing functions like UPPER$() (converting to

upper case), INSTR() (onding one string within the other), CHR$() (converting an ascii-code

into a character), GLOB() (testing a string against a pattern) and more.



3.7.4.   Arrays



Array constants


The common way to assign data to a whole array is to put the input ogures into list into square

brackets (which forms an array constant) and assign this to an array variable like:

   a()=[1,2,3;4,5,6]

   a comma is used to separate columns elements, and semicolon is used to separate rows. So

[1, 2, 3] is a row vector, and [1; 2; 3] is a column vector.

   Now that you know how to deone a simple array, you should know how to access its ele-

ments. Accessing the content of an array is done through the operator (), with the index inside

the parenthesis; the indexing of the orst element is 0:

   b=a(0)

   a(1)=5

   Accessing an element outside the bounds will result in an error: Field index too large.

   To access a single matrix element, you can use the (i,j) subscript, where i is the index in the

row, and j in the column:

   b=a(1,2)

   a(3,4)=3

   It is also possible to access blocks of matrices using the colon (:) operator. This operator

is like a wildcard; it tells X11Basic that you want all elements of a given dimension or with

indices between two given values. For example, say you want to access the entire orst row of

matrix a above, but not the second row. Then you can write:

   b()=a(1,:)

   Now say you only want the orst two elements in the orst row. To do this, use the following

syntax:

   b()=a(1,1:2)

   It is also possible to use arrays of higher dimension.

   b=a(2,5,4,2,7)



                                                                                               25

3.__X11Basic:_Getting_Started_____________________________________________________________________



Array operators


+ : Addition element by element - : subtraction element by element * : Array/Matrix multi-

plication : : Subarray (a block) =,<,>,<=,>=,<> : comparison

   Arrays are not only good for storing information in tables, but one can apply operations

on arrays.  You can for example use the classic arithmetic operations + and - on any array

in X11Basic:  this results in the vector addition and subtraction as deoned in classic vector

vectors spaces, which is simply the addition and subtraction elements wise.

   Array functions and operators act on entire arrays. Some return a list, which can then either

be used as a value for another array function, or assigned into an array variable.

   Array comparisons compare the array contents element-by-element, using the default com-

parison function for the element data type (=,>,<). In multidimensional arrays the elements are

visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are

equal but the dimensionality is dioeerent, the orst dioeerence in the dimensionality information

determines the sort order.



Spanning operators


Some operators operate in between of dioeerent classes of operands, like the string comparison

operators produce a number, or also the array comparison operators produce numbers.



3.8.    Program structure



An X11-Basic program consist of a main program block and subroutines. The main program

block is the shell of the program and is the section between the orst line and the keyword

END (or QUIT). The code in the main block drives the logic of your program.  In a simple

programs this is that is needed. In larger and more complex programs, putting all your code

in the main block makes the program hard to read and understand. Subroutines let you divide

your program in manageable sections, each performing its own specioc, but limited, tasks.

   In X11-Basic there are two types of subroutines: procedures and functions. The main dioeer-

ence between the two is that a function returns a single value and can be used in expressions,

while a procedure never returns a value. A procedure or function must appear after the main

program block. Therefore, the structure of an X11-Basic program is as follows:



Main  program  block

END

Procedures  and  Functions



Procedures    are blocks of code that can be called from elsewhere in a program. These sub-

       routines can take arguments but return no results. They can access all variables available

       but also may have local variables (> LOCAL).



26

     _____________________________________________________________________3.8.__Program_structure___________



 Functions   are blocks of code that can be called from elsewhere within an expression (e.g

       a=3*@myfunction(b)). Variables are global unless declared local. For local variables

       changes outside a function have no eoeect within the function except as explicitly spec-

       ioed within the function. Functions arguments can be variables and arrays of any data

       types. Functions can return variables of any data type. By default, arguments are passed

       by value.



3.8.1.   Procedures


A procedure starts with the keyword PROCEDURE followed by the procedure name and the

parameters being passed to the procedure. All procedures must end with the keyword RETURN.

Procedures use the following format:



PROCEDURE  ProcName(parameters)

   LOCAL  vars

   procedure  logic

RETURN



   The parameters of the subroutine are placed between parenthesis behind the subroutine

name and must be in the same order as the procedure call from the main program. All variables

used within the subroutine should be declared local using the LOCAL statement. The rest of the

procedure determines the task the subroutine must perform.

   A procedure can be called in two ways: by using the keyword GOSUB or @. For instance, the

procedure progress(), which showsa progress bar on the text console given the total amount

a and the fraction b, can be called the following ways:



GOSUB  progress(100,i)

@progress(100,i)



PROCEDURE  progress(a,b)

   LOCAL  t$

   IF  verbose

      PRINT  chr$(13);"[";string$(b/a*32,"-");">";

      PRINT  string$((1.03-b/a)*32,"-");"_  ";str$(int(b/a*100),3,3);"%  ]";

      FLUSH

   ENDIF

RETURN



3.8.2.   Functions


A function starts with a FUNCTION header followed by a function name, and ends with the

keyword ENDFUNCTION. The function is either a numeric or a string function.  A numeric



                                                                                               27

3.__X11Basic:_Getting_Started_____________________________________________________________________



function defaults to the AEoating point data type and needs no postox. A string function returns

a string and the function name ends with a $ postox.  A function must contain at least one

RETURN statement to return the function value. Functions use this format:


FUNCTION  FuncName[$](parameters)

   LOCAL  vars

   function  logic

   RETURN  value[$]

ENDFUNCTION


   The type of the return value must match the function type.  A string function must return

a string and a numeric function a numeric value.  The numeric value is always converted to

a AEoating point variable.  The function returns to the caller when the RETURN statement is

executed. The ENDFUNCTION statement only indicates the end of the function declaration and

will cause an error if the program tries to execute this statement.

   A function is called by preceding the function name with @.  As an example, the string

function Copy$() is called as follows:


Right$=@Copy$("X11-Basic",4)


   where the function Copy$() might be deoned as:


FUNCTION  Copy$(a$,p)

   LOCAL  b$

   b$=MID$(a$,p)

   RETURN  b$

ENDFUNC


   Of course you are as well free do deone


FUNCTION  Copy$(a$,p)

   RETURN  MID$(a$,p)

ENDFUNC


instead.

   An alternative for FUNCTION is the DEFFN statement, which deones a one line function. The

function Copy$() used in the example above, might be used in a DEFFN statement as well:


DEFFN  Copy$(a$,p)=MID$(a$,p)


   In contrast with procedures and functions, DEFFN functions may be placed within a proce-

dure or function body, although it doesn't use the local variables of the subroutine. There is

another dioeerence between DEFFN and FUNCTION: The compiler will use the DEFFN expres-

sion as an inline expression and will not produce a function with a symbol name. This is a bit

faster, but produces longer code.



28

     __________________________________________________________________3.9.__Simple_Input/Output____________



3.8.3.   Parameters and local variables


Any X11-Basic variable type can be passed to a procedure or function.

   By default all parameters are passed "'by value"'.  Though parameters can also be passed

"'by reference"' by using the VAR statement1.

   The LOCAL statement lists the variables only known to a procedure or function. Subroutine

parameters are local variables as well. When a subroutine calls another subroutine the local

variables of the calling routine are known in the called routine as if they where global variables.

   Several local variables separated by commas may be listed after the LOCAL statement. Mul-

tiple LOCAL lines are allowed.



3.8.4.   The address of a procedure


Some external linked shared libraries require an address of a function that can be called from

within the shared library (or other objects of code, which can be linked to the X11-Basic

interpreter or compiled excecutable, if it is compiled (callback functions). X11-Basic provides

the _CB()= command to generate a pointer to the entry point of a procedure2.



3.9.    Simple Input/Output



3.9.1.   Printing data to the console


You actually already know a X11-Basic command to write data on screen. This command is

PRINT. It is very versatile and you can extend it in various ways.

   Syntax is simple, PRINT  <data> where <data> is whatever sort of data you want to print

on screen. That can be variables, numbers, the result of a calculation, a string or a mix of them

all. You can even special user deoned commands (using functions) to your PRINT statement

for screen control such as cursor positioning. A few examples for the PRINT command can be

found here:


PRINT  10+5

PRINT  x%

PRINT  10;20;30

PRINT  10,20,30

PRINT  "Hello!"

PRINT  "y=  ";y

PRINT  "x=";x;"  y=";y;"  z=";z

PRINT  "Your  name  is  ";nam$

PRINT  AT(5,5);"AT()  is  one  of  my  favorites"
     _____________________________________________
  1This is currently not implemented in X11-Basic. You can use a workaround to this by using VARPTR(), such

    passing only a pointer to the memory location, where the value of the variable is stored.
  2Not yet implemented to X11-Basic



                                                                                               29

3.__X11Basic:_Getting_Started_____________________________________________________________________



PRINT  CHR$(27);"[2J  This  is  a  cleared  console..."


   These are the most simple variations of the PRINT command. Try them out on your own to

see their eoeects. Try with deoning a few sample variables.

   Now why do you write PRINT  "y  =";y instead of PRINT  "y  =",y? Using ; will add the

following data directly behind your text without altering the cursor position while the , will

advance the cursor to the next vertical tabular position. You can use that to align your data in

tables on screen. In short, if you want to write data directly to some sort of prompt or behind

some text, use the ; notation. Put a ; as the last data on your PRINT statement to let the cursor

stay on the current line. You can use this to prevent a scrolling on the last line of the screen

or if you simply want to split writing of prompt and data into two lines of code. Technically

speaking giving the ; last will suppress a carriage return.

   If you want to write direct text onto screen which is not contained in a string variable, just

enclose it in double quotes " like PRINT  "Hello!" which will write Hello! on screen.



3.9.2.   Screen control


Now that you know how to write your data on screen, you will also want to know how to handle

screen output in detail. How do I leave a line of text blank might you ask? Write simply PRINT

without any data behind to output a blank line on screen. Try this 3 lines program:


PRINT  "Hello!"

PRINT

PRINT  "This  is  the  first  example  for  screen  control!"


   As you see it prints the greeting and the other line with an empty line between.

   A very important thing is how to clear the screen. For obvious reasons, you'll sometimes

prepare a screen layout that requires you not to have other text or old data on screen. You'll

simply clear the screen with the following command.


CLS


   A neat thing is to write on screen exactly on a position where you want and not following

the listed AEow of ordinary PRINT statements. If you did try the orst example in this chapter,

you have noticed the AT() command. This special addition for PRINT allows you to position

the cursor freely on screen so you can write your data where you want. Let's try the following

example program:


CLS

PRINT  AT(1,1);"Top  left"

PRINT  AT(5,13);"Middle  line,  text  indented  5  chars"

PRINT  AT(20,25);"bottom  line";

INPUT  "",dummy$



30

     __________________________________________________________________3.9.__Simple_Input/Output____________



  Press the RETURN key to terminate the program. You'll learn soon about the INPUT state-

ment.

  Syntax for PRINT  AT(); is PRINT  AT(column,  row);, where row 1 is on top of the screen

and column 1 on the left end. Column and row can be variables, expressions or simply a plain

number. Valid PRINT  AT() commands are:



PRINT  AT(1,5);"Hello"

PRINT  AT(5+x%,10);"x"

PRINT  AT(4+8,y%);"y  =  "



  How many character positions do I have at my hand you may ask.  This depends on the

current console screen size. You have almost always at least 24 lines of text. 80 columns are

standard. If you want to exactly know the number of rows and collums of the text screen, you

can use the (system) variables ROWS and COLS.



>  PRINT  ROWS,COLS

24        80



  There are more commands you can use with PRINT like SPC() and TAB().  Refer to the

command reference on them.



3.9.3.   Formatting output with PRINT USING


There are built in commands for formatting data on output. I will only explain how to use that

for numeric data. Refer to your command reference to learn how to apply it for strings.

   Generic syntax is PRINT  USING  "<format  string>",expression. The format string de-

ones how you want your data to be formatted on screen while expression is what you want to

write with this format. Expression can be a number, a variable or a full expression.



3.9.4.   Gathering user input


Finally you can make your program interactive and allow the user to enter data into the com-

puter. To understand this sub chapter, you have to fully understand variables as explained in

chapter 2 because all user input is stored in variables.

   To enter numbers into the computer, use the INPUT statement in one of the following ways.

Your entered data is stored in the named variable. If you give a string variable, you can enter

text while you can only enter numeric data if you use a numeric variable. A minus sign and

optional decimal point are allowed for numeric input.



INPUT  "x=  ",x

INPUT  "What  is  your  name?  ",your_name$



                                                                                               31

3.__X11Basic:_Getting_Started_____________________________________________________________________



   This will prompt the user to enter a value for x which will be stored into a AEoat variable.

You can then use this variable in your program as normal, doing calculations with it.  Your

program will stop until the RETURN key or the ENTER key has been pressed to terminate the

input.

   You can read more than one variable with one INPUT statement, just list your variables

where you want your input to go to with separating commata.


PRINT  "enter  3  values,  separated  with  commata  (eq  3,4,5):"

INPUT  x%,y%,z%


   The user has then to enter commata at the appropriate places to tell which input goes to

which variable. To the example above the user would respond with 5,6,7. As always you can

then reuse the entered values in expressions and calculations.


CLS

INPUT  "Enter  a  value  for  x:",x

PRINT  "x  =  ";x

INPUT  "What  is  your  name?",your_name$

PRINT  "Your  name  is  ";your_name$;"."

PRINT  "Bye,  ";your_name$;"!"


   While entering strings you may have already noticed that X11-Basic will treat entering a

comma again as a delimiter, eoeectively cutting your string at that comma. Use the command

LINEINPUT instead of INPUT to read strings.


LINEINPUT  txt$


   You can now enter strings with a comma in and it will be saved to the string variable as well.

You can read multiple strings with LINEINPUT as well but the user has to press the RETURN

key terminating each string to be entered.

   An INPUT statement will erase the former contents of a variable in any case and will place

the entered values in them.



3.10.    Flow Control


This time you'll onally make your programs do things more then once without having to retype

your code.  The creation of so called loops is essential for making complex programs work.

The concept of looping and simple counting loops

   Before going further let me explain you the fundamental idea of looping.  The idea is to

make your program repeat a section of code for a deoned amount of time. You may let X11-

Basic count a variable for you and you can then use the value of that variable in an ongoing

calculation. Or you can let X11-Basic loop a certain part of code until a special condition has

been met. Take a look at the following sample program:



32

     ________________________________________________________________________3.10.__Flow_Control____________



FOR  i%=1  TO  5

   PRINT  i%

NEXT  i%


  This little example program loops 5 times and counts the variable i% from 1 to 5 and prints

the current value to the screen.  This sort of loop is called a FOR-NEXT-loop.  You can use

any numerical variable to count.  Most often this sort of loop is used to do things a certain

amount of time or to iterate over a list.  The loop will repeat the code between the FOR and

its corresponding NEXT. Each time X11-Basic reaches the NEXT, it will increment the count

variable and will stop the loop if the maximum count has been reached.

  You can of course have another loop inside the current one. Just make sure not to use the

same variable for counting or X11-Basic will do unpredictable things:


FOR  i%=1  TO  5

   FOR  j%=1  TO  10

      PRINT  i%;"  *  ";j%;"  =  ";i%*j%

   NEXT  j%

NEXT  i%


  That sample program has one FOR-NEXT-loop in another and it calculates the product of

the both counter variables creating some sort of multiplication table. Some rules and advice

to keep in mind with FOR-NEXT-loops:


   1.  Always terminate an opened FOR with a corresponding NEXT.

   2.  Always terminate FOR-loops in the correct order.  If you write FOR  i%=. . . orst and

       FOR  j%=. . . next, make sure to terminate the inner loop orst.

   3.  You can count downwards with the word DOWNTO instead of TO. Try FOR  i%=5  DOWNTO  1.

   4.  You can count in steps not equal 1 with the keyword STEP: FOR  i%=1  TO  10  STEP  2

       That will increment i% in steps of 2 until it reaches 10.

   5.  X11-Basic will check for correct loop termination while entering the code into the editor.

   6.  You can terminate the FOR-NEXT-loop with the EXIT  IF statement.



Conditions


A very fundamental idea in programming is to create and use conditionals. These will allow

you to make decisions when certain conditions are met and let your program take an alternative

code segment.

   Try to imagine that you count a special variable and want to do something else when the

value of your counter is 5:


FOR  i%=1  to  10

   IF  i%=5

      PRINT  "i%  is  now  5"



                                                                                               33

3.__X11Basic:_Getting_Started_____________________________________________________________________



   ELSE

      PRINT  "i%  is  not  5"

   ENDIF

NEXT  i%


   This program loops 10 times and counts in the variable i%. For each iteration of the loop it

checks if i% is 5 in the IF line. If that condition is true, i% is 5, then it executes the program

branch until the ELSE and omits the following part.  If the condition is not true, X11-Basic

will only execute the part behind the ELSE. Make sure to terminate each IF conditional with

an ENDIF or X11-Basic will get lost and produce an error message.

   You may leave out the ELSE fork.  X11-Basic will then do nothing if the condition is not

true.



3.10.1.   Conditional and endless loops


Sometimes you don't know how far you need to count for a special operation. Or imagine a

game. You don't want to let it run just for 10 frames but until the player sprite did collide or

something like that. The orst new loop will loop until a condition is fulolled:


REPEAT

...

UNTIL  <condition>


   This is a so called REPEAT-UNTIL-loop. It loops at least once and checks for the condition

after the loop contents have been executed by X11-Basic.  Use it for things that need to be

done at least once. You can emulate FOR-NEXT-loops with it if you want trickier counting:


i%=1

REPEAT

   PRINT  "i%=";i%

   i%=i%+1

UNTIL  i%>5


   Surely you can test the condition before entering a loop. This is useful if you want to loop

only when a certain condition is already true:


WHILE  <condition>

...

WEND


   This is the so called WHILE-WEND loop.  It checks the condition orst and it will not

execute the loop body if the condition is not fulolled. Sometimes you want to loop endless.

X11-Basic has a special loop construct for this purpose although you can create never ending



34

     ________________________________________________________________________3.10.__Flow_Control____________



loops easily with the types above if you use a condition that will never get true.  The never

ending loop is called DO-loop. The 3 loops in the example are all equal in functionality and

will loop endless.



DO

   PRINT  "endless"

LOOP



i%=0

REPEAT

   PRINT  "endless"

UNTIL  i%=1



i%=0

WHILE  i%=0

   PRINT  "endless"

WEND



  At this point it is important that you know you can terminate at your X11-Basic program at

any point. This is useful if your program gets stuck in an endless loop which was not intended.

Press CONTROL-c together and X11-Basic will stop the program. Another CONTROL-c will

quit the interpreter.

  Sometimes you will want to terminate a running loop at another point than the oOEcial loop

beginning or loop end.  Use the EXIT  IF statement in your loop for extra conditions.  This

will also terminate FOR-NEXT-loops if you wish to and it is the only way to terminate a

DO-LOOP.



i%=1

DO

   PRINT  "i%=";i%

   EXIT  IF  i%=5

   i%=i%+1

LOOP



  Please note that the EXIT  IF statement has no ENDIF or the like. It just terminates the loop

and continues your program behind the loop end.



                                                                                               35

3.__X11Basic:_Getting_Started_____________________________________________________________________



3.11.    Adress Spaces



The full accessible Program memory can be accessed by PEEK/POKE, LPEEK/LPOKE, DPEEK/DPOKE.

Be careful.  You can manipulate all symbols of the interpreter and or dynamically linked li-

braries and your program.  Adressspaces belonging to other programs which are not shared

memory blocks can not be accessed. You will get a segmentation fault on trying this.



3.12.    Graphics: Drawing and Painting



A graphics window will be automatically opened when the orst graphic command appears in

your program. Without using any graphic commands no X11-Server is needed at all and your

programs also runs under a text console or as a daemon or as CGI scripts.  But if you want

to draw anything with e.g. LINE, CIRCLE or BOX, control the MOUSE pointer, the keyboard

or use the graphical user interface with e.g. ALERT or MENU, a graphic window will open with

the default geometry 640x400. All graphic output can be done in full color which can be set

with the GET_COLOR() and the COLOR statements. Moreover, there can be up to 16 dioeerent

graphic windows opened at a time. Please note that all graphics is displaied after a SHOWPAGE

command only. This allows fast animations.

   To allow for animated bitmap graphics and icons, X11-Basic ooeers the commands GET and

PUT, which retrieve rectangular regions from the graphics-window into a string or put back

bitmap graphics data from the string to the graphics screen or window. The ole format used

with PUT is a standard .BMP bitmap, so also externally created icons can be used.  Trans-

parency and alpha channels are supported.



3.13.    Reading from and Writing to Files



Before you may read from or write to a ole, you need to open it; once you are done, you

should close it.  Each open ole is designated by a simple number, which might be stored

within a variable and must be supplied to the PRINT and INPUT commands if you want to

access the ole.

   If you need more control, you may consider reading and writing one byte at a time, using

the multi-purpose commands INP() and OUT, or reading the whole ole as a binary block with

BLOAD.



3.14.    Internet connections, special oles and sockets



X11-Basic allows to connect a program to another Program on a dioeerent (or the same) host

computer via standart internet protocols or pipes.



36

     _______________________________________3.14.__Internet_connections,_special_oles_and_sockets___________



  Basically there are two methods of connections to other computers on a network:  The

TCP/IP Based connections via strams and the implemention of a connectionless, unreliable

datagram packet service (UDP).

  A method of passing data between two applications on the same computer is using Pipes.

Pipes are special oles which are created in the local olesystem.



3.14.1.   Local communication: Pipes



3.14.2.   World-Wide communication: Sockets


Most interprocess communication uses the client server model. These terms refer to the two

processes which will be communicating with each other. One of the two processes, the client,

connects to the other process, the server, typically to make a request for information. A good

analogy is a person who makes a phone call to another person.

   Notice that the client needs to know of the existence of and the address of the server, but

the server does not need to know the address of (or even the existence of) the client prior to

the connection being established. Notice also that once a connection is established, both sides

can send and receive information.

   When a socket is created, the program has to specify the address domain and the socket

type.  Two processes can communicate with each other only if their sockets are of the same

type and in the same domain. There are two widely used address domains, the unix domain,

in which two processes which share a common ole system communicate, and the Internet

domain, in which two processes running on any two hosts on the Internet communicate. Each

of these has its own address format.

   The address of a socket in the Unix domain is a character string which is basically an entry

in the ole system.

   The address of a socket in the Internet domain consists of the Internet address of the host

machine (every computer on the Internet has a unique 32 bit address, often referred to as its

IP address).  In addition, each socket needs a port number on that host.  Port numbers are

16 bit unsigned integers. The lower numbers are reserved in Unix for standard services. For

example, the port number for the FTP server is 21.  It is important that standard services be

at the same port on all computers so that clients will know their addresses.  However, port

numbers above 2000 are generally available.



Socket Types   There are two widely used socket types, stream sockets, and datagram sock-

ets. Stream sockets treat communications as a continuous stream of characters, while datagram

sockets have to read entire messages at once.  Each uses its own communciations protocol.

Stream sockets use TCP (Transmission Control Protocol), which is a reliable, stream oriented

protocol, and datagram sockets use UDP (Unix Datagram Protocol), which is unreliable and

message oriented.



                                                                                               37

3.__X11Basic:_Getting_Started_____________________________________________________________________



TCP/IP   Transmission Control Protocol (TCP) provides a reliable byte-stream transfer ser-

vice between two endpoints on an internet. TCP depends on IP to move packets around the

network on its behalf. IP is inherently unreliable, so TCP protects against data loss, data cor-

ruption, packet reordering and data duplication by adding checksums and sequence numbers

to transmitted data and, on the receiving side, sending back packets that acknowledge the

receipt of data.

   Before sending data across the network, TCP establishes a connection with the destination

via an exchange of management packets. The connection is destroyed, again via an exchange

of management packets, when the application that was using TCP indicates that no more data

will be transferred.  In OSI terms, TCP is a Connection-Oriented Acknowledged Transport

protocol.

   TCP has a multi-stage AEow-control mechanism which continuously adjusts the sender's

data rate in an attempt to achieve maximum data throughput while avoiding congestion and

subsequent packet losses in the network.  It also attempts to make the best use of network

resources by packing as much data as possible into a single IP packet, although this behaviour

can be overridden by applications that demand immediate data transfer and don't care about

the ineOEciencies of small network packets.

   The system calls for establishing a connection are somewhat dioeerent for the client and the

server, but both involve the basic construct of a socket. A socket is one end of an interprocess

communication channel. The two processes each establish their own socket.

   The steps involved in establishing a socket on the client side are as follows:


   1.  Create a socket with the OPEN command providing a port number


         open  "US",#1,"client",5000


   2.  Connect the socket to the address of the server using the CONNECT command


         connect  #1,"ptbtime1.ptb.de",13


   3.  Instead of using Steps 1 and 2, you can alternatively use the combined command:


         open  "UC",#2,"ptbtime1.ptb.de",13

   4.  Send and receive data. There are a number of ways to do this, but the simplest is to use
       the PRINT, SEND, WRITE, READ, RECEIVE INPUT commands.

         print #2,"GET /index.html"
         flush #2
         while inp?(#2)
           lineinput #2,t$
           print "got: ";t$
         wend

   5.  close the connection with


        close  #1


   The steps involved in establishing a socket on the server side are as follows:



38

     _______________________________________3.14.__Internet_connections,_special_oles_and_sockets___________



   1.  Create a socket with the OPEN command and bind the socket to a port number on the

       host machine.


         open  "US",#1,"server",5000


   2.  Listen for connections with

   3.  Accept a connection with another OPEN command.


         open  "UA",#2,"",1


       This call typically blocks until a client connects with the server.
   4.  Send and receive data on the accepted connection

         print #2,"Welcome to X11-Basic test-server ..."
         flush #2
         do
           if inp?(#2)
             lineinput #2,t$
             print "got: ";t$
           endif
           exit if t$="quit"
         loop
         print #2,"goodbye..."
         flush #2

   5.  close the established connection with


        close  #2


       and listen to the next connection or

   6.  close the socket if not further needed


        close  #1



UDP   User Datagram Protocol (UDP) provides an unreliable packetized data transfer service

between endpoints on an internet. UDP depends on IP to move packets around the network on

its behalf.

  First a SOcket has to be crated with the OPEN command:


   open  "UU",#1,"sender",5556


  When a UDP socket is created, its local and remote addresses are unspecioed. Datagrams

can be sent immedi ately using SEND with a valid destination address and port as argument:


  send #1,"This is my message",mkl(chr$(131)+chr$(195)+chr$(15)+chr$(200)),5000


  UDP uses the IPv4 address format, so a long integer has to be passed.

  When CONNECT is called on the socket the default destination address is set and datagrams

can now be sent using SEND without specifying an destination address. It is still possible to

send to other destinations by passing an address to SEND.



                                                                                               39

3.__X11Basic:_Getting_Started_____________________________________________________________________



  connect #1,"localhost",5555
  send #1,"This is my message"


   All receive operations return only one packet.


  if inp?(#1)
     receive #1,t$,adr
     print "Received Message: ";t$;" from ";hex$(adr)
  endif


   INP?(#n) Returns the size of the next pending datagram in bytes, or 0 when no datagram is

pending.

   The Socket should be closed when the connection is not goint to be used any more:


  close  #1


   UDP does not guarantee to actually deliver the data to the destination, nor does it guarantee

that data packets will be delivered to the destination in the order in which they were sent by the

source, nor does it guarantee that only one copy of the data will be delivered to the destination.

UDP does guarantee data integrity, and it does this by adding a checksum to the data before

transmission.



3.15.    Data within the program


You may store data within your program within DATA-statements; during execution you will

probably want to READ it into variables or arrays. Also the assignment of constant to arrays

may be used to store data in your program and last but not least the INLINE$() function may

be used to store huge binary data segments.

   The orst example shows how to store conventional data (numbers and strings) within the

sourcecode of a basic program:


' example how to use the DATA statement

RESTORE mydata
READ name$,age,address$,code

mydata:
DATA "Bud Spencer",30,"Holywood Street",890754
DATA "Hannelore Isendahl",15,"Max-Planck-Allee",813775


   The following example shows how to store arbitrary binary data, which can be used e.g. to

store the bitmapdata for a bitmap (    ). Or also for other resources like pictograms and any

other bitmap or icon.


' output of inline.bas for X11-Basic 23.04.2002
' demo 104 Bytes.
demo$=""
demo$=demo$+"5*II@V%M@[4D=*9V,)5I@[4D=*9V,(IR?*IR=6Y*A:]OA*IS?F".&IAI?J"D8ZII"
demo$=demo$+",*5M=;1I@V%P=;1I?F%OaJ]R=:"P,*5E?J"D>*)X,*9W,*AI>ZUE@+%X/F"R&JAV"



40

     _______________________________________________________________3.16.__Dynamic-link_libraries___________



demo$=demo$+"A;1W&HXR&DL$"
a$=INLINE$(demo$)
PRINT len(a$),a$

' show a bitmap
biene$="($$43$%*<(1G,=E5Z&MD%_DVW'b*%H-^,EQ6>VTL$$$$"

CLEARW
t$=INLINE$(biene$)
COLOR GET_COLOR(65535,65535,65535)
FOR i=0 TO 40
  PUT_BITMAP t$,i*16,0,16,16
NEXT i



  For convenience, a program called inline.bas shippes with X11-Basic. It does the con-

version from and compression of any binary ole to ready-to-use X11-basic sourcecode.



3.16.    Dynamic-link libraries



A dynamic-link library (.so =shared object) is a collection of functions (subroutines) that can

be used by programs or by other .so's. A .so function must be called, directly or indirectly,

from a running application and can not be run as a separate task.

   Dynamic link libraries save memory space and reduce memory swapping. Memory is saved,

because many applications can use a single .so simultaneously, sharing a single copy of the

.so in memory. Another feature of .so's is the ability to change the functions in a .so without

modifying the applications that use them, as long as the function's arguments and return values

do not change. A disadvantage to using .so's is that an application depends on the existence

of a separate .so module. If the .so is not found, the application is terminated.

   All documented functions from the shared objects of other software packages can be used

and invoked from within yout X11-Basic program.

   X11-Basic will perform no check on the number and type of the API function parameters.



3.16.1.   Using shared libraries and C functions


Before an application can use a function from a .so (if you want to use your own functions

written in C you have to compile them to a shared object ole), it must load the .so explicitly

using the LINK statement.



   LINK  #n,"myfile.so"



   The process of loading a .so explicitly is called run-time linking.

   For instance, to use the binit() function from the trackit.so library, an application must

include following lines of code (supposing, you want to use your own shared object made out

of the c-code trackit.c):



                                                                                               41

3.__X11Basic:_Getting_Started_____________________________________________________________________



   IF  not  exist("./trackit.so")

      system  "gcc  -O3  -shared  -o  trackit.so  trackit.c"

   ENDIF

   LINK  #11,"./trackit.so"

   "EXEC(SYM_ADR(#11,"binit"),L:n,L:200,L:varptr(x(0)),L:varptr(bins(0)))



   The ole trackit.c contains:


#include <stdlib.h>
#include <stdio.h>
#include <math.h>

void binit(int n,int dn,double *x,double *data) -
  int i,j;
  int over=0,under=0;
     for(i=0;i<n;i++) -
       j=(int)((x[i]+PI)/2/PI*dn);
       if(j<0) under++;
       else if(j>=dn) over++;
       else data[j]++;
     "
"



   X11-Basic applications can load up to 99 shard object oles simultaneously, al though the

channel number space is shared with the open oles..

   To do this parameter n must specify a value between 1 an 99.  X11-Basic maintains an

internal table with 99 entries to store the handle of the loaded shared object modules. These

handles are necessary to unload the .so when the application is onished using them.

   The .so's are unloaded by invoking the UNLINK command:



   UNLINK  #11



   X11-Basic currently allows only a AEoat (double) type for the return value. This is currently a

limitation for the use of the standard libraries. If you have written the library function yourself,

you could bypass this limitation by passing pointers to variables.

   The following parameter types are possible:

                        __________________________________________________
                        |  L:  |32-bits integers and pointers (long) (%)  |
                        |      |                                          |
                        |  W:  |         16-bits signed (short)           |
                        |      |                                          |
                        |  B:  |          8-bits signed (char)            |
                        |      |                                          |
                        |  F:  |         8 byte AEoat (double)            |
                        |      |                                          |
                        |  S:  |           4 byte AEoat (AEoat)             |
                        |______|__________________________________________  |


   The SYM_ADR function determines the address of the function from its name. The spelling

of the function name must therefore be identical to the spelling of the function in the .so.

   When passing the address of the string, a null byte must be added to the end of the string.



42

     _______________________________________________________________3.17.__Memory_management________________



3.17.    Memory management


Normally, X11-Basic takes care of most of the memory management for the programmer.

When a variable, string or array is declared, X11-Basic allocates the required memory and

releases it when the application is terminated. However, there may be situations when a pro-

grammer wants to allocate additional memory.



3.17.1.   Allocating memory


If an application needs to store small amounts of memory, it should use strings.  Strings are

often used as a buoeer for functions. The Adress of the memory occupied by a string can be

obtained by the VARPTR() function. Its length by the LEN() funciton.

   To allocate memory from the global and systemwide proram user space memory pool you

might use the function MALLOC(). For instance, to allocate 2000 bytes, you might use:



   Ptr%=MALLOC(2000)



   A global memory block allocated with MALLOC must be freed using the FREE() function.

An application should always free all memory blocks before exiting. For instance:



   FREE  Ptr%



3.18.    Other features


    fflX11-Basic programs may start other programs with the commands SYSTEM and SYSTEM$().

    fflThe ENV$() function allows access to environment variables.

    fflThe current time or date can be retrieved with TIME$ and DATE$.

    fflThe interpreter allows self modifying code.

    fflIt is possible to link shared library objects and use the fuctions provided from within the

       X11-basic Program



                                                                                               43

3.__X11Basic:_Getting_Started_____________________________________________________________________



         Figure 3.1 : A message box.



       Figure 3.2 : A simple input box.



3.19.    Using the Graphical User Interface (GUI)



3.19.1.   ALERT and FILESELECT


Two most often used Graphic functions are implementet as a full functional graphical user

interface dialog: Message boxes and a Fileselector. Arbitrary dialogs can be createt with the

object and recource functions. Also a pull down menu function is implemented.
   Fig. 3.1 shows a typical messagebox. The command which produces it is:


ALERT 3,"This file is write protected._You can only read or
          delete it.",1,"OK_DELETE_CANCEL",sel


   ALERT boxes can also be used to manage simple input forms like the one you can see in
og. 3.2. Here is a little exapmle program:

CLEARW
i=1
name$="TEST01"
posx$="N54ffi50'32.3"
posy$="E007ffi50'32.3"
t$="Edit waypoint:__Name:    "+CHR$(27)+name$+"_"
t$=t$+"Breite: "+chr$(27)+posx$+"_"
t$=t$+"Lnge:  "+chr$(27)+posy$+"_"
t$=t$+"Hhe:    "+chr$(27)+str$(alt,5,5)+"_"
t$=t$+"Typ:     "+chr$(27)+hex$(styp,4,4)+"_"
ALERT 0,t$,1,"OK_UPDATE_LSCHEN_CANCEL",a,f$
WHILE LEN(f$)
  WORT_SEP f$,CHR$(13),0,a$,f$
  PRINT "Feld";i;": ",a$
  INC i
WEND
QUIT


   Fig. 3.4 shows the oleselector box. The command which produces it is:



44

     ___________________________________________3.19.__Using_the_Graphical_User_Interface_(GUI)_____________



                                                                       Figure 3.3 : The oleselcetor



                                                  Figure 3.4 :A pull down menu



FILESELECT  "load  program:","./*.bas","in.bas",f$


  The complete path and olname of the selected ole will be returned in f$.



3.19.2.   Recources


X11-Basic resources consist of object trees, strings, and bitmaps used by a basic program.

They encapsulate the user interface and make internationalization easier by placing all pro-

gram strings in a single ole. The dataformat of X11Basic recources is downwards compatible

with the Atari-ST GEM implementation.

   Resources are generally created using a Resource Construction Set (RCS) and saved to a

.RSC ole which is loaded by RSRC_LOAD() at program initialization time.

   Resources may also be embedded as data structures in source code (the utility programs

rsc2gui.bas and gui2bas.bas convert .RSC oles to source code). Resources contain point-



                                                                                               45

3.__X11Basic:_Getting_Started_____________________________________________________________________



                           Figure 3.5.: Examples of forms in X11-Basic



ers and coordinates which must be oxed up before being used. RSRC_LOAD() does this auto-

matically, however if you use an embedded resource you must take care of this by yourself

on each object in each object tree to convert the initial character coordinates of to screen co-

ordinates. This allows resources designed on screens with dioeerent aspect ratios and system

fonts to appear the same. Once a resource is loaded use rsrc_gaddr() to obtain pointers to

individual object trees which can then be manipulated directly or with the X11-Basic built-in

functions.



3.19.3.   Objects


Objects can be boxes, buttons, text, images, and more. An object tree is an array of OBJECT

structures linked to form a structured relationship to each other. The object itself is a section

of data which can be held by a string in X11-Basic.

   The OBJECT structure is format is as follows:


object$=MKI$(ob_next)+MKI$(ob_head)+MKI$(ob_tail)+

           MKI$(ob_type)+MKI$(ob_flags)+MKI$(ob_state)+

           MKL$(ob_spec)+MKI$(ob_x)+MKI$(ob_y)+MKI$(ob_width)+

           MKI$(ob_height)


   An Object tree is a collection of objects:


tree$=object0$+object1$+  ...  +objectn$



46

     ___________________________________________3.19.__Using_the_Graphical_User_Interface_(GUI)_____________



  The orst object in an OBJECT tree is called the ROOT object (OBJECT 0). It's coordinates

are relative to the upper-left hand corner of the graphics window.  The ROOT object can

have any number of children and each child can have children of their own.  In each case,

the OBJECT's coordinates, ob_x, ob_y, ob_width, and ob_height are relative to that of its

parent. The X11-Basic function objc_offset() can, however, be used to determine the exact

screen coordinates of a child object. objc_find() is used to determine the object at a given

screen coordinate.

  The ob_next, ob_head, and ob_tail oelds determine this relationship between parent

OBJECTs and child OBJECTs.



 ob_next   the index (counting objects from the orst object in the object tree) of the object's

       next sibling at the same level in the object tree array. The ROOT object should set this

       value to -1. The last child at any given nesting level should set this to the index of its

       parent.

 ob_head   the index of the orst child of the current object. If the object has no children then

       this value should be -1.

 ob_tail the index of the last child: the tail of the list of the object's children in the object tree

       array If the object has no children then this value should be -1.

 ob_type   the object type. The low byte of the ob_type oeld specioes the object type as follows:



               ______________________________________________________________________
               |  ob_type   Name               Description                       |
               |_________________________________________________________________|___
               |     20     G_BOX              Box                                |
               |                                                                  |
               |     21     G_TEXT             Formatted Text                    |
               |                                                                 |
               |     22     G_BOXTEXT          Formatted Text in a Box           |
               |                                                                 |
               |     23     G_IMAGE            Monochrome Image               |
               |                                                              |
               |     24     G_PROGDEF          Programmer-Deoned Object       |
               |                                                              |
               |     25     G_IBOX             Invisible Box                      |
               |                                                                  |
               |     26     G_BUTTON           Push Button w/String              |
               |                                                                 |
               |     27     G_BOXCHAR          Character in a Box                 |
               |                                                                  |
               |     28     G_STRING           Unformatted Text                  |
               |                                                                 |
               |     29     G_FTEXT            Editable Formatted Text           |
               |                                                                 |
               |     30     G_FBOXTEXT         Editable Formatted Text in a Box  |
               |                                                                 |
               |     31     G_ICON             Monochrome Icon                 |
               |                                                               |
               |     32     G_TITLE            Menu Title                         |
               |                                                                  |
               |     33     G_CICON            Color Icon                         |
               |__________________________________________________________________|__



 ob_AEags  The ob_AEags oeld of the object structure is a bitmask of dioeerent AEags that can be

       applied to any object. You may want to apply one ore more AEags at once. Just add the

       values ob_AEags.



                                                                                               47

3.__X11Basic:_Getting_Started_____________________________________________________________________



    ___________________________________________________________________________________________
    |  ob_AEags   Name              Description                                              |
    |________________________________________________________________________________________|__
    |     0       NONE              No AEag                                                  |
    |________________________________________________________________________________________|__||

    |     1       SELECTABLE        object is selected. state may be toggled by clicking on  |
    |                               it with the mouse.                                       |
    |________________________________________________________________________________________|__||

    |     2       DEFAULT           An EXIT object with this bit set will have a thicker     |
    |                               outline and be triggered when the user presses return.   |
    |________________________________________________________________________________________|__||

    |     4       EXIT              Clicking on this OBJECT and releasing the mouse          |
    |                               button while still over it will cause the dialog to exit.|
    |________________________________________________________________________________________|__||

    |     8       EDITABLE          Set for FTEXT and FBOXTEXT objects to indicate           |
    |                               that they may receive edit focus.                        |
    |________________________________________________________________________________________|__||
    |     16      RBUTTON           This object is one of a group of radio buttons. Click-   |
    |                                                                                        |
    |                               ing on it will deselect any selected objects at the      |
    |                                                                                        |
    |                               same tree level that also have the RBUTTON AElag set.    |
    |                                                                                        |
    |                               Likewise, it will be deselected automatically when       |
    |                               any other object is selected.                            |
    |________________________________________________________________________________________|__||

    |     32      LASTOB            This AEag signals that the current OBJECT is the last    |
    |                               in the object tree. (Required!)                          |
    |________________________________________________________________________________________|__||
    |     64      TOUCHEXIT         Setting  this  AEag  causes  the  OBJECT  to  return  an |
    |                                                                                        |
    |                               exit state immediately after being clicked on with the   |
    |                               mouse.                                                   |
    |________________________________________________________________________________________|__||

    |    256      HIDETREE          This  OBJECT  and  all  of  its  children  will  not  be |
    |                               drawn.                                                   |
    |________________________________________________________________________________________|__||
    |    512      INDIRECT          This AEag cause the ob_spec oeld to be interpreted as    |
    |                                                                                        |
    |                               a pointer to the ob_spec value rather than the value     |
    |                               itself.                                                  |
    |________________________________________________________________________________________|__||
    |    1024     FL3DIND           Setting this AEag causes the OBJECT to be drawn as a     |
    |                                                                                        |
    |                               3D indicator. This is appropriate for radio and toggle   |
    |                               buttons.                                                 |
    |________________________________________________________________________________________|__||

    |    2048     FL3DACT           Setting this AEag causes the OBJECT to be drawn as a     |
    |                               3D activator. This is appropriate for EXIT buttons.      |
    |________________________________________________________________________________________|__||
    |    3072     FL3DBAK           If these bits are set, the object is treated as an AES   |
    |                                                                                        |
    |                               background object. If it is OUTLINED, the outlined       |
    |                                                                                        |
    |                               is drawn in a 3D manner. If its color is set to WHITE    |
    |                                                                                        |
    |                               and its oll pattern is set to 0 then the OBJECT will     |
    |                               inherit the default 3D background color.                 |
    |________________________________________________________________________________________|__||
    |    4096     SUBMENU           This bit is set on menu items which have a sub-menu      |
    |                                                                                        |
    |                               attachment. This bit also indicates that the high byte   |
    |                               of the ob_type oeld is being used by the menu system.    |
    |________________________________________________________________________________________|__



48

    ___________________________________________3.19.__Using_the_Graphical_User_Interface_(GUI)_____________



ob_state  The ob_state oeld determines the display state of the object as follows:



    _________________________________________________________________________________________
    |  ob_state  Name              Description                                              |
    |_______________________________________________________________________________________|_
    |      0     NORMAL            Normal state                                             |
    |_______________________________________________________________________________________|_||
    |      1     SELECTED          The object is selected. An object with this bit set will |
    |                                                                                       |
    |                              be drawn in inverse video except for G_CICON which       |
    |                              will use its 'selected' image.                           |
    |_______________________________________________________________________________________|_||
    |      2     CROSSED           An OBJECT with this bit set will be drawn over with      |
    |                                                                                       |
    |                              a white cross (this state can only usually be seen over  |
    |                              a colored or SELECTED object).                           |
    |_______________________________________________________________________________________|_||

    |      4     CHECKED           An OBJECT with this bit set will be displayed with a     |
    |                              checkmark in its upper-left corner.                      |
    |_______________________________________________________________________________________|_||
    |      8     DISABLED          An OBJECT with this bit set will ignore user input.      |
    |                                                                                       |
    |                              Text objects with this bit set will draw in grey or a    |
    |                              dithered pattern.                                        |
    |_______________________________________________________________________________________|_||
    |     16     OUTLINED          G_BOX, G_IBOX, G_BOXTEXT, G_FBOXTEXT,                    |
    |                                                                                       |
    |                              and G_BOXCHAR OBJECTs with this bit set will be          |
    |                              drawn with a double border.                              |
    |_______________________________________________________________________________________|_||
    |     32     SHADOWED          G_BOX, G_IBOX, G_BOXTEXT, G_FBOXTEXT,                    |
    |                                                                                       |
    |                              and G_BOXCHAR OBJECTs will be drawn with a               |
    |                              shadow.                                                  |
    |_______________________________________________________________________________________|_



ob_spec   The Object-Specioc Field

      The ob_spec oeld contains dioeerent data depending on the object type as indicated in

      the table below:


         _______________________________________________________________________________||
         |  G_BOX             The low 16 bits contain a WORD containing color          |
         |                                                                             |
         |                    information for the OBJECT. Bits 23-16 contain a         |
         |                                                                             |
         |                    signed BYTE representing the border thickness of the     |
         |                    box.                                                     |
         |_____________________________________________________________________________|_||

         |  G_TEXT            The ob_spec oeld contains a pointer to a TEDINFO         |
         |                    structure.                                               |
         |_____________________________________________________________________________|_||

         |  G_BOXTEXT         The ob_spec oeld contains a pointer to a TEDINFO         |
         |                    structure.                                               |
         |_____________________________________________________________________________|_
         |  G_IMAGE           The ob_spec oeld points to a BITBLK structure.           |
         |_____________________________________________________________________________|_
         |  G_PROGDEF         The ob_spec oeld points to a APPLBLK structure.          |
         |_____________________________________________________________________________|_||
         |  G_IBOX            The low 16 bits contain a WORD containing color          |
         |                                                                             |
         |                    information for the OBJECT. Bits 23-16 contain a         |
         |                                                                             |
         |                    signed BYTE representing the border thickness of the     |
         |                    box.                                                     |
         |_____________________________________________________________________________|



                                                                                              49

3.__X11Basic:_Getting_Started_____________________________________________________________________



          ______________________________________________________________________________||

          |  G_BUTTON          The ob_spec oeld contains a pointer to the text to be    |
          |                    contained in the button.                                 |
          |_____________________________________________________________________________|_||
          |  G_BOXCHAR         The low 16 bits contain a WORD containing color          |
          |                                                                             |
          |                    information for the OBJECT. Bits 23-16 contain a         |
          |                                                                             |
          |                    signed BYTE representing the border thickness of the     |
          |                                                                             |
          |                    box. Bits 31-24 contain the ASCII value of the char-     |
          |                    acter to display.                                        |
          |_____________________________________________________________________________|_||

          |  G_STRING          The ob_spec oeld contains a pointer to the text to be    |
          |                    displayed.                                               |
          |_____________________________________________________________________________|_||

          |  G_FTEXT           The ob_spec oeld contains a pointer to a TEDINFO         |
          |                    structure.                                               |
          |_____________________________________________________________________________|_||

          |  G_FBOXTEXT        The ob_spec oeld contains a pointer to a TEDINFO         |
          |                    structure.                                               |
          |_____________________________________________________________________________|_||

          |  G_ICON            The ob_spec oeld contains a pointer to an ICONBLK        |
          |                    structure.                                               |
          |_____________________________________________________________________________|_||

          |  G_TITLE           The ob_spec oeld contains a pointer to the text to be    |
          |                    used for the title.                                      |
          |_____________________________________________________________________________|_||

          |  G_CICON           The ob_spec oeld contains a pointer to a CICONBLK        |
          |                    structure.                                               |
          |_____________________________________________________________________________|_



       objc_colorword    Almost all objects reference a WORD containing the object color as

            deoned below.



            objc_colorword=bbbbcccctpppcccc


            Bits 15-12 contain the border color
            Bits 11-8  contain the text color
            Bit    7     is 1 if opaque or 0 if transparent
            Bits 6-4    contain the fill pattern index
            Bits 3-0    contain the fill color



            Available colors for oll patterns, text, and borders are listed below:



50

___________________________________________3.19.__Using_the_Graphical_User_Interface_(GUI)_____________



                            _____________________________________________
                            |  Value   Name            Color           |
                            |__________________________________________|_
                            |    0     WHITE           White           |
                            |                                          |
                            |    1     BLACK           Black           |
                            |                                          |
                            |    2     RED             Red             |
                            |                                          |
                            |    3     GREEN           Green           |
                            |                                          |
                            |    4     BLUE            Blue            |
                            |                                          |
                            |    5     CYAN            Cyan           |
                            |                                         |
                            |    6     YELLOW          Yellow          |
                            |                                          |
                            |    7     MAGENTA         Magenta        |
                            |                                         |
                            |    8     LWHITE          Light Gray     |
                            |                                         |
                            |    9     LBLACK          Dark Gray      |
                            |                                         |
                            |   10     LRED            Light Red      |
                            |                                         |
                            |   11     LGREEN          Light Green    |
                            |                                         |
                            |   12     LBLUE           Light Blue      |
                            |                                          |
                            |   13     LCYAN           Light Cyan     |
                            |                                         |
                            |   14     LYELLOW         Light Yellow   |
                            |                                         |
                            |   15     LMAGENTA        Light Magenta  |
                            |_________________________________________|__

  TEDINFO    G_TEXT, G_BOXTEXT, G_FTEXT, and G_FBOXTEXT objects all refer-
       ence a TEDINFO structure in their ob_spec oeld. The TEDINFO structure is de-
       oned below:

       tedinfo$=MKL$(VARPTR(te_ptext$))+MKL$(VARPTR(te_ptmplt$))+
                 MKL$(VARPTR(te_pvalid$))+MKI$(te_font)+MKI$(te_fontid)+
                 MKI$(te_just)+MKI$(te_color)+MKI$(te_fontsize)+
                 MKI$(te_thickness)+MKI$(te_txtlen)+MKI$(te_tmplen)

       The three character pointer point to text strings required for G_FTEXT and G_FBOXTEXT

       objects. te_ptext points to the actual text to be displayed and is the only oeld used

       by all text objects.  te_ptmplt points to the text template for editable oelds.  For

       each character that the user can enter, the text string should contain a tilde charac-

       ter (ASCII 126). Other characters are displayed but cannot be overwritten by the

       user.  te_pvalid contains validation characters for each character the user may

       enter. The current acceptable validation characters are:


       _____________________________________________________________________________________________
       |  Caracter   Allows                                                                       |
       |__________________________________________________________________________________________|_
       |      9      Digits 0-9                                                                    |
       |                                                                                           |
       |      A      Uppercase letters A-Z plus space                                            |
       |                                                                                         |
       |      a      Upper and lowercase letters plus space                                       |
       |                                                                                          |
       |      N      Digits 0-9, uppercase letters A-Z and space                                  |
       |                                                                                          |
       |      n      Digits 0-9, upper and lowercase letters A-Z and space                       |
       |                                                                                         |
       |      F      Valid DOS olename characters plus question mark and asterisk             |
       |                                                                                      |
       |      P      Valid DOS pathname characters, backslash, colon, question mark, asterisk  |
       |                                                                                       |
       |      p      Valid DOS pathname characters, backslash and colon                       |
       |                                                                                      |
       |      X      All characters                                                                |
       |___________________________________________________________________________________________|_



                                                                                          51

3.__X11Basic:_Getting_Started_____________________________________________________________________



            te_font may be set to any of the following values:

                        ______________________________________________________________
                        |  te_font  Name       Description                         |
                        |__________________________________________________________|__
                        |     3     IBM        Use the standard monospaced font.  |
                        |                                                         |
                        |     5     SMALL      Use the small monospaced font.     |
                        |_________________________________________________________|___

            te_just sets the justiocation of the text output as follows:

                                  __________________________________________
                                  |  te_just  Name           Description  |
                                  |_______________________________________|_
                                  |     0     TE_LEFT        Left Justify   |
                                  |                                         |
                                  |     1     TE_RIGHT       Right Justify  |
                                  |                                         |
                                  |     2     TE_CNTR        Center        |
                                  |________________________________________|_

            te_thickness sets the border thickness (positive and negative values are acceptable)

            of the G_BOXTEXT or G_FBOXTEXT object.

            te_txtlen and te_tmplen should be set to the length of the starting text and template

            length respectively.

       BITBLK   G_IMAGE objects contain a pointer to a BITBLK structure in their ob_spec

            oeld. The BITBLK structure is deoned as follows:


            bitblk$=MKL$(VARPTR(bi_pdata$))+MKI$(bi_wb)+MKI$(bi_hl)+
                     MKI$(bi_x)+MKI$(bi_y)+MKI$(bi_color)


            bi_pdata should contain a monochrome bit image. bi_wb specioes the width (in

            bytes) of the image.  All BITBLK images must be a multiple of 16 pixels wide

            therefore this value must be even. bi_hl specioes the height of the image in scan

            lines (rows). bi_x and bi_y are used as ooesets into bi_pdata. Any data occurring

            before these coordinates will be ignored.  bi_color is a standard color WORD

            where the oll color specioes the color in which the image will be rendered.

       ICONBLK     The ob_spec oeld of G_ICON objects point to an ICONBLK structure as

            deoned below:


            iconblk$=MKL$(VARPTR(ib_pmask$))+MKL$(VARPTR(ib_pdata$))+MKL$(VARPTR(ib_ptext$))+
                      MKI$(ib_char)+MKI$(ib_xchar)+MKI$(ib_ychar)+
                      MKI$(ib_xicon)+MKI$(ib_yicon)+MKI$(ib_wicon)+MKI$(ib_hicon)+
             MKI$(ib_xtext)+MKI$(ib_ytext)+MKI$(ib_wtext)+MKI$(ib_htext)


            ib_pmask and ib_pdata contain the monochrome mask and image data respec-

            tively.  ib_ptext is a string pointer to the icon text.  ib_char deones the icon

            character (used for drive icons) and the icon foreground and background color as

            follows:


            _                                  ib_char                                   _
            _       Bits 15-12       _       Bits 11-8        _        Bits 7-0        _
            _Icon Foreground Color _Icon Background Color _ASCII Character (or 0 _
            _                         _                         _  for no character).  _



52

___________________________________________3.19.__Using_the_Graphical_User_Interface_(GUI)_____________



       ib_xchar and ib_ychar specify the location of the icon character relative to

       ib_xicon and ib_yicon.  ib_xicon and ib_yicon specify the location of the

       icon relative to the ob_x and ob_y of the object. ib_wicon and ib_hicon specify

       the width and height of the icon in pixels. As with images, icons must be a mul-

       tiple of 16 pixels in width.  ib_xtext and ib_ytext specify the location of the

       text string relative to the ob_x and ob_y of the object. ib_wtext and ib_htext

       specify the width and height of the icon text area.

  CICONBLK     The G_CICON object deones its ob_spec oeld to be a pointer to a CICON-

       BLK structure as deoned below:

       ciconblk$=monoblk$+MKL$(VARPTR(mainlist$))


       monoblk contains a monochrome icon which is rendered if a color icon matching

       the display parameters cannot be found. In addition, the icon text, character, size,

       and positioning data from the monochrome icon are always used for the color one.

       mainlist contains the orst CICON structure in a linked list of color icons for

       dioeerent resolutions. CICON is deoned as follows:

       cicon$=MKI$(num_planes)+MKL$(VARPTR(col_data$))+MKL$(VARPTR(col_mask$))+
               MKL$(VARPTR(sel_data$))+MKL$(VARPTR(sel_mask$))+
               MKL$(VARPTR(cicon2$))


       num_planes indicates the number of bit planes this color icon contains. col_data

       and col_mask contain the icon data and mask for the unselected icon respectively.

       Likewise, sel_data and sel_mask contain the icon data and mask for the selected

       icon. cicon2$ contains the next color icon deonition. Use MKL$(0) if no more are

       available.

       The GUI library searches the CICONBLK object for a color icon that has the same

       number of planes in the display. If none is found, the GUI library simply uses the

       monochrome icon.

  APPLBLK     G_PROGDEF objects allow programmers to deone custom objects and link

       them transparently in the resource. The ob_spec oeld of G_PROGDEF objects con-

       tains a pointer to an APPLBLK as deoned below:

       applblk$=MKL$(SYM_ADR(#1,"function"))+MKL$(ap_parm)


       The orst is a pointer to a user-deoned routine which will draw the object.  This

       routine must be a c-Function, which has to be linked to X11-basic with the LINK

       command. The routine will be passed a pointer to a PARMBLK structure contain-

       ing the information it needs to render the object. The routine must be deoned with

       stack checking ooe and expect to be passed its parameter on the stack. ap_parm is a

       user-deoned value which is copied into the PARMBLK structure as deoned below:

       typedef struct parm_blk -
                OBJECT           *tree;
                short              pb_obj;
                short              pb_prevstate;



                                                                                          53

3.__X11Basic:_Getting_Started_____________________________________________________________________



                     short              pb_currstate;
                     short              pb_x;
                     short              pb_y;
                     short              pb_w;
                     short              pb_h;
                     short              pb_xc;
                     short              pb_yc;
                     short              pb_wc;
                     short              pb_hc;
                     long               pb_parm;
            " PARMBLK;


            tree points to the OBJECT tree of the object being drawn. The object is located

            at index pb_obj.

            The routine is passed the old ob_state of the object in pb_prevstate and the new

            ob_state of the object in pb_currstate. If pb_prevstate and pb_currstate

            is equal then the object should be drawn completely, otherwise only the drawing

            necessary to redraw the object from pb_prevstate to pb_currstate are neces-

            sary.

            pb_x, pb_y, pb_w, and pb_h give the screen coordinates of the object.  pb_xc,

            pb_yc, pb_wc, and pb_hc give the rectangle to clip to. pb_parm contains a copy

            of the ap_parm value in the APPLBLK structure. The custom routine should return

            a short containing any remaining ob_state bits you wish the GUI Library to draw

            over your custom object.



Dialogs


Dialog boxes are modal forms of user input. This means that no other interaction can occur

between the user and applications until the requirements of the dialog have been met and it

is exited.  A normal dialog box consists of an object tree with a BOX as its root object and

any number of other controls that accept user input. Both alert boxes and the ole selector are

examples of dialog boxes.

   The form_do() function performs the simplest method of using a dialog box. Simply con-

struct an OBJECT tree with at least one EXIT or TOUCHEXIT object and call form_do()1.

All interaction with the dialog like editable oelds, radio buttons, and selectable objects will be

maintained by the X11-Basic library until the user strikes an EXIT or TOUCHEXIT object.



3.19.4.   The gui ole format


The *.gui ole format, which is basically an ASCII representation of the ATARI ST recource

oles (*.rsc), can be converted to X11-Basic code, which then can handle message boxes and
________________________________________
  1Before you should display the dialog box using the objc_draw() function. Maybe you also want to center the

    dialog with form_center() andsave and redraw the background with form_dial().



54

     ___________________________________________3.19.__Using_the_Graphical_User_Interface_(GUI)_____________



forms. The converter gui2bas(1) does this job. For conversion of ATARI ST recource oles

to *.gui Files see rsc2gui(1).

  The *.gui ole consists of Lines and Blocks which specify objects and their hirarchical de-

pendencies. The generic format of such an object is:


label:  TYPE(variables)  -

 ...  block  ...

"


  The label is optional and gives the object a name. Depending on TYPE of the object, one

or more variables are given as a comma separated list in brackets.

  Each object may start a block with '-' at the end of the line. Inside this block there might be

one or more objects given which then are considered as sub-objects of the one whichopened

the block. The block will be closed by a '"' in a single line.

  Example:


' Little selector box    (c) Markus Hoffmann     07.2003
' convert this with gui2bas !
' as an example for the use of the gui system
' with X11-Basic



  BOX(X=0,Y=0,W=74,H=14, FRAME=2, FRAMECOL=1, TEXTCOL=1, BGCOL=0, PATTERN=0, TEXTMODE=0, STATE=OUTLINED+) -
    BOXTEXT(X=2,Y=1,W=70,H=1, TEXT="Select option ...", FONT=3, JUST=2, COLOR=4513, BORDER=253, STATE=SHADOWED+)
    BOX(X=2,Y=3,W=60,H=10, FRAME=-1, FRAMECOL=1, TEXTCOL=1, BGCOL=0, PATTERN=0, TEXTMODE=0) -
       FTEXT(X=1,Y=1,W=30,H=1,COLOR=4513,FONT=3,BORDER=1,TEXT="Line 1", PTMP="_______________________________________",PVALID="XXXX*
 *XXXXXXXXXXXXXXXXXXXXXXXXXX@
       FTEXT(X=1,Y=2,W=30,H=1,COLOR=4513,FONT=3,BORDER=1,TEXT="", PTMP="_______________________________________",PVALID="XXXXXXXXXX*
 *XXXXXXXXXXXXXXXXXXXXXXXXXX@
       FTEXT(X=1,Y=3,W=30,H=1,COLOR=4513,FONT=3,BORDER=1,TEXT="", PTMP="_______________________________________",PVALID="XXXXXXXXXX*
 *XXXXXXXXXXXXXXXXXXXXXXXXXX@
       FTEXT(X=1,Y=4,W=30,H=1,COLOR=4513,FONT=3,BORDER=1,TEXT="", PTMP="_______________________________________",PVALID="XXXXXXXXXX*
 *XXXXXXXXXXXXXXXXXXXXXXXXXX@
       BOX(X=2,Y=6,W=50,H=3, FRAME=-1, FRAMECOL=1, TEXTCOL=1, BGCOL=1, PATTERN=5, TEXTMODE=0) -
         BUTTON(X=2,Y=1,W=4,H=1, TEXT="ON",STATE=SELECTED, FLAGS=RADIOBUTTON+SELECTABLE,FRAME=2, FRAMECOL=1, TEXTCOL=1, BGCOL=1, PA*
 *TTERN=0, TEXTMODE=0)
         BUTTON(X=8,Y=1,W=4,H=1, TEXT="OFF",FLAGS=RADIOBUTTON+SELECTABLE,FRAME=2, FRAMECOL=1, TEXTCOL=1, BGCOL=1, PATTERN=0, TEXTMO*
 *DE=0)
       "
    "
    ok:      BUTTON(X=65,Y=4,W=7,H=4, TEXT="OK", FLAGS=SELECTABLE+DEFAULT+EXIT)
    cancel: BUTTON(X=65,Y=9,W=7,H=4, TEXT="CANCEL", FLAGS=SELECTABLE+EXIT+LASTOB+)
  "



3.19.5.   Menus


Most applications use a menu bar to allow the user to navigate through program options. In

addition, future versions of X11-Basic will allow popup menus and drop-down list boxes (a

special form of a popup menu).

   Here is a simple example program, which demonstrates the handling of a drop down menu.


' Test-program for Drop-Down-Menus
'
DIM field$(50)
FOR i=0 TO 50
  READ field$(i)
  EXIT IF field$(i)="***"
NEXT i



                                                                                               55

3.__X11Basic:_Getting_Started_____________________________________________________________________



oh=0
field$(i)=""
DATA "INFO","  Menutest"
DATA "---------------"
DATA "- Access.1","- Access.2","- Access.3","- Access.4","- Access.5"
DATA "- Access.6",""
DATA "FILE","  new","  open ...","  save","  save as ...","--------------"
DATA "  print","--------------","  Quit",""
DATA "EDIT","  cut","  copy","  paste","----------","  help1","  helper"
DATA "  assist",""
DATA "HELP","  online help","--------------","  edifac","  editor","  edilink"
DATA "  edouard",""
DATA "***"

grau=get_color(32000,32000,32000)
color grau
pbox 0,0,640,400
MENUDEF field$(),menuaction
DO
  pause 0.05
  MENU
LOOP
quit

PROCEDURE menuaction(k)
  local b
  IF (field$(k)="  Quit") OR (field$(k)="  exit")
     quit
  ELSE IF field$(k)="  online help"
     oh=not oh
     MENUSET k,4*abs(oh)
  ELSE IF field$(k)="  Menutest"
     "form_alert(1,"[0][---- Menutest ----__(c) Markus Hoffmann 2001_X11-Basic V.1.03][ OK ]")
  ELSE
     PRINT "MENU selected ";k;" contents: ";field$(k)
     b=form_alert(1,"[1][--- Menutest ---__You selected item (No. "+str$(k)+"),_ for which was no_function definded !][ OK _disable*
 *]")
     if b=2
       MENUSET k,8
     endif
  ENDIF
RETURN



56

     ________________________________________________3.20.__WEB_programming_with_X11-Basic__________________



3.20.    WEB programming with X11-Basic


This chapter explaines, how you can use X11-Basic programs for WEB-interfacing.  Espe-

cially via the use of so-called CGI-Scripts.



3.20.1.   What is CGI?


CGI stands for Common Gateway Interface  a term you don't really need to know. In short,

CGI deones how web servers and web browsers handle information from HTML forms on

web pages. This means instead of the WEB server sending static web pages to the clients, it

can invoke a program, typically called a cgi-script, to generate the page on the time the request

was received.  These cgi"-scripts take some action, and then send a results page back to the

user's web browser. The results page might be dioeerent every time the program is run.

   And these programs can be X11-Basic programs.



3.20.2.   Conoguration


   1.  All X11-Basic scripts must begin with the following statement, on the orst line:

       #!/usr/bin/xbasic

       Because Unix does not map ole suOExes to programs, there has to be a way to tell Unix

       that this ole is a X11-Basic program, and that it is to be executed by the X11-Basic

       interpreter xbasic. This is seen before in shell scripts, in which the orst line tells Unix

       to execute it with one of the shell programs. The xbasic executable, which will take this

       ole, parse it, and execute it, is located in the directory /usr/bin. This may be dioeerent on

       some systems. If you are not sure where the xbasic executable is, type which xbasic on

       the command line, and it will return you the path.

   2.  All scripts should be marked as executable by the system.

       Executable oles are types that contain instructions for the machine or an interpreter, such

       as xbasic, to execute. To mark a ole as executable, you need to alter the ole permissions

       on the script ole. There are three basic permissions: read, write, and execute. There are

       also three levels of access: owner, group, and anyone. X11-Basic oles should have their

       permissions changed so that you, the owner, has permission to read, write and execute

       your ole, while others only have permission to read and execute your ole. This is done

       with the following command:

       chmod 755 filename.bas

       The number 755 is the ole access mask. The orst digit is your permission; it is 7 for full

       access. The user and anyone settings are 5 for read and execute.

   3.  The very orst print statement in a X11-Basic cgi script that returns HTML should be:

       print "Content-type: text/html"+chr$(13)
       print ""+chr$(13)
       flush



                                                                                               57

3.__X11Basic:_Getting_Started_____________________________________________________________________



       When your X11-Basic script is going to return an HTML ole, you must have this as the

       very orst print statement in order to tell the web server that this is an HTML ole. There

       must be two end of line characters (CR+LF) (the aditional chr$(13)) in order for this

       to work. The AEush statement ensures, that this statement ist sent to the web-server. After

       that, you usually print  "<HTML><BODY>" etc.

   4.  End your program with quit

       Do not use END. Otherwise the cgi-program will remain is the servers memory as a

       zombie.

   5.  Always use the POST method with HTML forms

       There are 2 ways to get information from the client to the web server.  The GET

       method takes all of the data from the forms and concatenates it onto the end of the

       URL. This information is then passed to the CGI program as an environment variable

       (QUERY_STRING). Because the GET method has the limitation of being 1024 characters

       long, it is best to use the POST method.  This takes the data and sends it allong with

       the request to the web server, without the user seeing the ugly strings in the URL. This

       information is passed to the CGI program through standard in, which the program can

       easilly read from. To use the POST method, make sure that your HTML form tag has

       METHOD=POST (no quotes).

   6.  HTML forms must reference the cgi script to be executed.

       In your FORM tag, there is an ACTION attribute. This is like the HREF attribute for a

       link. It should be the URL of the CGI program you want the form data sent to. Usually

       this is ACTION="/cgi-bin/filename.bas"

   7.  X11-Basic-cgi oles usually go in the cgi-bin directory of your web server.

       The web server has a "root" directory.  This is the highest directory your HTML oles

       can access. (You don't want clients to be able to snoop around your entire system, so

       the rest of the system is sealed ooe) in this directory, there is usually one called cgi-bin,

       where all the CGI programs go. Some web service providers give each user a cgi-local

       directory in their home directory where they can put their cgi scripts. If this is the case,

       use this one instead.



3.20.3.   How it works


When a user activates a link to a gateway script, input is sent to the server. The server formats

this data into environment variables and checks to see whether additional data was submitted

via the standard input stream.



Environment Variables


Input to CGI scripts is usually in the form of environment variables. The environment variables

passed to gateway scripts are associated with the browser requesting information from the

server, the server processing the request, and the data passed in the request.  Environment

variables are case-sensitive and are normally used as described in this section. Although some



58

     ________________________________________________3.20.__WEB_programming_with_X11-Basic__________________



environment variables are system-specioc, many environment variables are standard.  The

standard environment variables are shown in the following Table:



       _____________________________________________________________________________________
       |  Variable               |Purpose                                                  |
       |_________________________|_________________________________________________________|_|||

       |  AUTH_TYPE            |  Specioes the authentication method and is used to val-   |
       |                       |  idate a user's access.                                   |
       |_______________________|___________________________________________________________|_|||

       |  CONTENT_LENGTH      |   Used to provide a way of tracking the length of the      |
       |                      |   data string as a numeric value.                          |
       |______________________|____________________________________________________________|_
       |  CONTENT_TYPE        |   Indicates the MIME type of data.                         |
       |______________________|____________________________________________________________|_|||

       |  GATEWAY_INTERFACE  |    Indicates which version of the CGI standard the server   |
       |                     |    is using.                                                |
       |_____________________|_____________________________________________________________|_|||

       |  HTTP_AccEPT          |  Indicates the MIME content types the browser will        |
       |                       |  accept, as passed to the gateway script via the server.  |
       |_______________________|___________________________________________________________|_|||

       |  HTTP_USER_AGENT    |    Indicates the type of browser used to send the request,  |
       |                     |    as passed to the gateway script via the server.          |
       |_____________________|_____________________________________________________________|_|||

       |  PATH_INFO            |  Identioes the extra information included in the URL      |
       |                       |  after the identiocation of the CGI script.               |
       |_______________________|___________________________________________________________|_|||
       |  PATH_TRANSLATED    |    Set by the server based on the PATH_INFO variable.       |
       |                     |                                                             |
       |                     |    The server translates the PATH_INFO variable into        |
       |                     |    this variable.                                           |
       |_____________________|_____________________________________________________________|_|||

       |  QUERY_STRING        |   Set to the query string (if the URL contains a query     |
       |                      |   string).                                                 |
       |______________________|____________________________________________________________|_|||

       |  REMOTE_ADDR          |  Identioes the Internet Protocol address of the remote    |
       |                       |  computer making the request.                             |
       |_______________________|___________________________________________________________|_|||

       |  REMOTE_HOST          |  Identioes the name of the machine making the re-         |
       |                       |  quest.                                                   |
       |_______________________|___________________________________________________________|_
       |  REMOTE_IDENT        |   Identioes the machine making the request.                |
       |______________________|____________________________________________________________|_
       |  REMOTE_USER          |  Identioes the user name as authenticated by the user.    |
       |_______________________|___________________________________________________________|_
       |  REQUEST_METHOD      |   Indicates the method by which the request was made.      |
       |______________________|____________________________________________________________|_
       |  SCRIPT_NAME          |  Identioes the virtual path to the script being executed. |
       |_______________________|___________________________________________________________|_|||

       |  SERVER_NAME          |  Identioes the server by its host name, alias, or IP ad-  |
       |                       |  dress.                                                   |
       |_______________________|___________________________________________________________|_|||

       |  SERVER_PORT          |  Identioes the port number the server received the re-    |
       |                       |  quest on.                                                |
       |_______________________|___________________________________________________________|_
       |  SERVER_PROTOCOL    |    Indicates the protocol of the request sent to the server.|
       |_____________________|_____________________________________________________________|_
       |  SERVER_SOFTWARE    |    Identioes the Web server software.                       |
       |_____________________|_____________________________________________________________|_



 AUTH_TYPE     The AUTH_TYPE variable provides access control to protected areas of the Web

       server and can be used only on servers that support user authentication. If an area of the



                                                                                               59

3.__X11Basic:_Getting_Started_____________________________________________________________________



       Web site has no access control, the AUTH_TYPE variable has no value associated with it.

       If an area of the Web site has access control, the AUTH_TYPE variable is set to a specioc

       value that identioes the authentication scheme being used.

       Using this mechanism, the server can challenge a client's request and the client can

       respond.  To do this, the server sets a value for the AUTH_TYPE variable and the client

       supplies a matching value.  The next step is to authenticate the user.  Using the basic

       authentication scheme, the user's browser must supply authentication information that

       uniquely identioes the user. This information includes a user ID and password.

       Under the current implementation of HTTP, HTTP 1.0, the basic authentication scheme

       is the most commonly used authentication method.  To specify this method, set the

       AUTH_TYPE variable as follows: AUTH_TYPE  =  Basic

 CONTENT_LENGTH         The CONTENT_LENGTH variable provides a way of tracking the length of

       the data string.  This variable tells the client and server how much data to read on the

       standard input stream. The value of the variable corresponds to the number of characters

       in the data passed with the request. If no data is being passed, the variable has no value.

 CONTENT_TYPE       The CONTENT_TYPE variable indicates the data's MIME type. This variable

       is set only when attached data is passed using the standard input or output stream. The

       value assigned to the variable identioes the basic MIME type and subtype as follows:


           _____________________________________________________________________________
           |  Type           |Description                                              |
           |_________________|_________________________________________________________|_|||

           |  application  |  Binary data that can be executed or used with another    |
           |               |  application                                              |
           |_______________|___________________________________________________________|_
           |  audio          |A sound ole that requires an output device to preview    |
           |_________________|_________________________________________________________|_
           |  image          |A picture that requires an output device to preview      |
           |_________________|_________________________________________________________|_
           |  message       | An encapsulated mail message                             |
           |________________|__________________________________________________________|_|||

           |  multipart    |  Data consisting of multiple parts and possibly many      |
           |               |  data types                                               |
           |_______________|___________________________________________________________|_|||

           |  text           |Textual data that can be represented in any character    |
           |                 |set or formatting language                               |
           |_________________|_________________________________________________________|_
           |  video          |A video ole that requires an output device to preview    |
           |_________________|_________________________________________________________|_
           |  x-world       | Experimental data type for world oles                    |
           |________________|__________________________________________________________|_



       MIME subtypes are deoned in three categories: primary, additionally deoned, and ex-

       tended.  The primary subtype is the primary type of data adopted for use as a MIME

       content type. Additionally deoned data types are additional subtypes that have been of-

       ocially adopted as MIME content types. Extended data types are experimental subtypes

       that have not been oOEcially adopted as MIME content types.  You can easily identify

       extended subtypes because they begin with the letter x followed by a hyphen. The fol-

       lowing Table lists common MIME types and their descriptions.



60

________________________________________________3.20.__WEB_programming_with_X11-Basic__________________



__________________________________________________________________________________________________
||||  Type/Subtype                De|scription                                             |
||||________________________________|______________________________________________________|______
||||  application/msword          |Microsoft Word document                                 |
||||______________________________|________________________________________________________|______|||

||||  application/octet-stream  | Binary data that can be executed or used with another    |
||||                            | application                                              |
||||____________________________|__________________________________________________________|______
||||  application/pdf             A|CROBAT PDF document                                    |
||||_______________________________|_______________________________________________________|______
||||  application/postscript    | Postscript-formatted data                                |
||||____________________________|__________________________________________________________|______
||||  application/rtf             R|ich Text Format (RTF) document                         |
||||_______________________________|_______________________________________________________|______
||||  application/x-compress    | Data that has been compressed using UNIX compress        |
||||____________________________|__________________________________________________________|______
||||  application/x-dvi           |Device-independent ole                                  |
||||______________________________|________________________________________________________|______
||||  application/x-gzip          |Data that has been compressed using UNIX gzip           |
||||______________________________|________________________________________________________|______
||||  application/x-latex        |LATEX document                                           |
||||_____________________________|_________________________________________________________|______
||||  application/x-tar           |Data that has been archived using UNIX tar              |
||||______________________________|________________________________________________________|______
||||  audio/basic                 Au|dio in a nondescript format                           |
||||________________________________|______________________________________________________|______
||||  audio/x-wav                 Au|dio in Microsoft WAV format                           |
||||________________________________|______________________________________________________|______
||||  image/gif                   Ima|ge in gif format                                     |
||||_________________________________|_____________________________________________________|______
||||  image/jpeg                  Im|age in JPEG format                                    |
||||________________________________|______________________________________________________|______
||||  image/tiff                  Im|age in TIFF format                                    |
||||________________________________|______________________________________________________|______
||||  image/x-portable-bitmap   | Portable bitmap                                          |
||||____________________________|__________________________________________________________|______
||||  image/x-portable-graymap  | Portable graymap                                         |
||||____________________________|__________________________________________________________|______
||||  image/x-portable-pixmap   | Portable pixmap                                          |
||||____________________________|__________________________________________________________|______
||||  image/x-xbitmap             X|-bitmap                                                |
||||_______________________________|_______________________________________________________|______
||||  image/x-xpixmap             X|-pixmap                                                |
||||_______________________________|_______________________________________________________|______
||||  message/external-body      |Message with external data source                        |
||||_____________________________|_________________________________________________________|______
||||  message/partial             F|ragmented or partial message                           |
||||_______________________________|_______________________________________________________|______
||||  message/rfc822              R|FC 822-compliant message                               |
||||_______________________________|_______________________________________________________|______
||||  multipart/alternative      |Data with alternative formats                            |
||||_____________________________|_________________________________________________________|______
||||  multipart/digest            |Multipart message digest                                |
||||______________________________|________________________________________________________|______
||||  multipart/mixed             M|ultipart message with data in multiple formats         |
||||_______________________________|_______________________________________________________|______|||

||||  multipart/parallel          |Multipart data with parts that should be viewed simul-  |
||||                              |taneously                                               |
||||______________________________|________________________________________________________|______
||||  text/html                   HTM|L-formatted text                                     |
||||_________________________________|_____________________________________________________|______
||||  text/plain                  Pl|ain text with no HTML formatting included             |
||||________________________________|______________________________________________________|______
||||  video/mpeg                  Vi|deo in the MPEG format                                |
||||________________________________|______________________________________________________|______
||||  video/quicktime             V|ideo in the Apple QuickTime format                     |
||||_______________________________|_______________________________________________________|______
||||  video/x-msvideo             V|ideo in the Microsoft AVI format                       |
||||_______________________________|_______________________________________________________|______
||||  x-world/x-vrml              V|RML world ole                                          |
||||_______________________________|_______________________________________________________|______



  There are some more common MIME types.

  Some MIME content types can be used with additional parameters. These content types



                                                                                          61

3.__X11Basic:_Getting_Started_____________________________________________________________________



       include text/plain, text/html, and all multipart message data.  The charset parameter,

       which is optional, is used with the text/plain type to identify the character set used for the

       data. If a charset is not specioed, the default value charset=us-ascii is assumed. Other

       values for charset include any character set approved by the International Standards

       Organization.  These character sets are deoned by ISO-8859-1 to ISO-8859-9 and are

       specioed as follows:

        CONTENT_TYPE = text/plain; charset=iso-8859-1


       The boundary parameter, which is required, is used with multipart data to identify the

       boundary string that separates message parts.  The boundary value is set to a string of

       1 to 70 characters. Although the string cannot end in a space, it can contain any valid

       letter or number and can include spaces and a limited set of special characters. Boundary

       parameters are unique strings that are deoned as follows:

        CONTENT_TYPE = multipart/mixed; boundary=boundary_string


 GATEWAY_INTERFACE         The GATEWAY_INTERFACE variable indicates which version of the

       CGI speciocation the server is using.  The value assigned to the variable identioes the

       name and version of the speciocation used as follows:

        GATEWAY_INTERFACE = name/version


       The current version of the CGI speciocation is 1.1. A server conforming to this version

       would set the GATEWAY_INTERFACE variable as follows:

        GATEWAY_INTERFACE = CGI/1.1


 HTTP_ACCEPT      The HTTP_ACCEPT variable deones the types of data the client will accept.

       The acceptable values are expressed as a type/subtype pair.  Each type/subtype pair is

       separated by commas.

 HTTP_USER_AGENT         The HTTP_USER_AGENT variable identioes the type of browser used

       to send the request.  The acceptable values are expressed as software type/version or

       library/version.

 PATH_INFO    The PATH_INFO variable specioes extra path information and can be used to send

       additional information to a gateway script. The extra path information follows the URL

       to the gateway script referenced. Generally, this information is a virtual or relative path

       to a resource that the server must interpret.

 PATH_TRANSLATED        Servers translate the PATH_INFO variable into the PATH_TRANSLATED

       variable by inserting the default Web document's directory path in front of the extra path

       information.

 QUERY_STRING       The QUERY_STRING variable specioes an URL-encoded search string. You

       set this variable when you use the GET method to submit a oll-out form or when you

       use an ISINDEX query to search a document.  The query string is separated from the

       URL by a question mark. The user submits all the information following the question

       mark separating the URL from the query string. The following is an example:



62

    ________________________________________________3.20.__WEB_programming_with_X11-Basic__________________



       /cgi-bin/doit.cgi?string


      When the query string is URL-encoded, the browser encodes key parts of the string.

      The plus sign is a placeholder between words and acts as a substitute for spaces:

       /cgi-bin/doit.cgi?word1+word2+word3


      Equal signs separate keys assigned by the publisher from values entered by the user. In

      the following example, response is the key assigned by the publisher, and never is the

      value entered by the user:

       /cgi-bin/doit.cgi?response=never


      Ampersand symbols separate sets of keys and values.  In the following example, re-

      sponse is the orst key assigned by the publisher, and sometimes is the value entered by

      the user. The second key assigned by the publisher is reason, and the value entered by

      the user is I am not really sure:

       /cgi-bin/doit.cgi?response=sometimes&reason=I+am+not+really+sure


      Finally, the percent sign is used to identify escape characters. Following the percent sign

      is an escape code for a special character expressed as a hexadecimal value. Here is how

      the previous query string could be rewritten using the escape code for an apostrophe:

       /cgi-bin/doit.cgi?response=sometimes&reason=I%27m+not+really+sure


REMOTE_ADDR        The REMOTE_ADDR variable is set to the Internet Protocol (IP) address of the

      remote computer making the request.

REMOTE_HOST       The REMOTE_HOST variable specioes the name of the host computer making

      a request. This variable is set only if the server can ogure out this information using a

      reverse lookup procedure.

REMOTE_IDENT       The REMOTE_IDENT variable identioes the remote user making a request.

      The variable is set only if the server and the remote machine making the request sup-

      port the identiocation protocol.  Further, information on the remote user is not always

      available, so you should not rely on it even when it is available.

REMOTE_USER       The REMOTE_USER variable is the user name as authenticated by the user,

      and as such is the only variable you should rely upon to identify a user. As with other

      types of user authentication, this variable is set only if the server supports user authen-

      tication and if the gateway script is protected.

REQUEST_METHOD         The REQUEST_METHOD variable specioes the method by which the re-

      quest was made. The methods could be any of GET, HEAD, POST, PUT, DELETE, LINK and

      UNLINK.

      The GET, HEAD and POST methods are the most commonly used request methods. Both

      GET and POST are used to submit forms.

SCRIPT_NAME      The SCRIPT_NAME variable specioes the virtual path to the script being exe-

      cuted. This information is useful if the script generates an HTML document that refer-

      ences the script.



                                                                                              63

3.__X11Basic:_Getting_Started_____________________________________________________________________



 SERVER_NAME       The SERVER_NAME variable identioes the server by its host name, alias, or

       IP address. This variable is always set.

 SERVER_PORT       The SERVER_PORT variable specioes the port number on which the server

       received the request. This information can be interpreted from the URL to the script if

       necessary. However, most servers use the default port of 80 for HTTP requests.

 SERVER_PROTOCOL         The SERVER_PROTOCOL variable identioes the protocol used to send

       the request.  The value assigned to the variable identioes the name and version of the

       protocol used. The format is name/version, such as HTTP/1.0.

 SERVER_SOFTWARE          The SERVER_SOFTWARE variable identioes the name and version of

       the server software.  The format for values assigned to the variable is name/version,

       such as CERN/2.17.



CGI Standard Input


Most input sent to a Web server is used to set environment variables, yet not all input ots neatly

into an environment variable. When a user submits data to be processed by a gateway script,

this data is received as an URL-encoded search string or through the standard input stream.

The server knows how to process this data because of the method (either POST or GET in

HTTP 1.0) used to submit the data.

   Sending data as standard input is the most direct way to send data.  The server tells the

gateway script how many eight-bit sets of data to read from standard input. The script opens

the standard input stream and reads the specioed amount of data. Although long URL-encoded

search strings may get truncated, data sent on the standard input stream will not. Consequently,

the standard input stream is the preferred way to pass data.



Which CGI Input Method to use?


You can identify a submission method when you create your oll-out forms. Under HTTP 1.0,

two submission methods for forms exist. The HTTP GET method uses URL-encoded search

strings. When a server receives an URL-encoded search string, the server assigns the value of

the search string to the QUERY_STRING variable.

   The HTTP POST method uses the standard input streams. When a server receives data by

the standard input stream, the server assigns the value associated with the length of the input

stream to the CONTENT_LENGTH variable.



Output from CGI Scripts


After the script onishes processing the input, the script should return output to the server. The

server will then return the output to the client. Generally, this output is in the form of an HTTP

response that includes a header followed by a blank line and a body. Although the CGI header

output is strictly formatted, the body of the output is formatted in the manner you specify in

the header. For example, the body can contain an HTML document for the client to display.



64

     ________________________________________________3.20.__WEB_programming_with_X11-Basic__________________



CGI Headers


CGI headers contain directives to the server. Currently, these three server directives are valid:



      * Content-Type
      * Location
      * Status



   A single header can contain one or all of the server directives.  Your CGI script outputs

these directives to the server. Although the header is followed by a blank line that separates

the header from the body, the output does not have to contain a body.

   The Content-Type oeld in a CGI header identioes the MIME type of the data you are

sending back to the client. Usually the data output from a script is a fully formatted document,

such as an HTML document. You could specify this output in the header as follows:



 Content-Type: text/html



   But of course, if your program outputs other data like images etc. you should specify the

corresponding content type.



Locations   The output of your script doesn't have to be a document created within the script.

You can reference any document on the Web using the Location oeld.  The Location oeld

references a ole by its URL. Servers process location references either directly or indirectly

depending on the location of the ole. If the server can ond the ole locally, it passes the ole to

the client. Otherwise, the server redirects the URL to the client and the client has to retrieve

the ole. You can specify a location in a script as follows:



 Location: http://www.new-jokes.com/



Status   The Status oeld passes a status line to the server for forwarding to the client. Status

codes are expressed as a three-digit code followed by a string that generally explains what has

occurred. The orst digit of a status code shows the general status as follows:



  1XX Not yet allocated
  2XX Success
  3XX Redirection
  4XX Client error
  5XX Server error



   Although many status codes are used by servers, the status codes you pass to a client via

your CGI script are usually client error codes. Suppose the script could not ond a ole and you

have specioed that in such cases, instead of returning nothing, the script should output an error

code. Here is a list of the client error codes you may want to use:



                                                                                               65

3.__X11Basic:_Getting_Started_____________________________________________________________________



401 Unauthorized Authentication has failed.
     User is not allowed to access the file and should try again.


403 Forbidden. The request is not acceptable.
     User is not permitted to access file.


404 Not found. The specified resource could not be found.


405 Method not allowed. The submission method used is not allowed.



3.20.4.   Example cgi-Script envtest.cgi


Here is a simple sample cgi-script, which simply returns all the information which it gets from

the web server as a html page.



#!/usr/bin/xbasic
print "Content-type: text/html"+chr$(13)
print ""+chr$(13)
flush
print "<html><head><TITLE>Test CGI</TITLE><head><body>"
print "<h1>Commandline:</h1>"
i=0
while len(param$(i))
  print str$(i)+": "+param$(i)+"<br>"
  inc i
wend
print "<h1>Environment:</h1><pre>"
flush       ! flush the output before another program is executed !
system "env"
print "</pre><h1>Stdin:</h1><pre>"
length=val(env$("CONTENT_LENGTH"))
if length
  for i=0 to length-1
     t$=t$+chr$(inp(-2))
  next i
  print t$
endif
print "</pre>"
print "<FORM METHOD=POST ACTION=/cgi-bin/envtest.cgi>"
print "Name: <INPUT NAME=name><BR>"
print "Email: <INPUT NAME=email><BR>"
print "<INPUT TYPE=submit VALUE="+chr$(34)+"Test POST Method"+chr$(34)+">"
print "</FORM>"
print "<hr><h6>(c) Markus Hoffmann cgi with X11-basic</h6></body></html>"
flush
quit



66




4.     Quick  reference



4.1.    reserved variable names



There are some reserved variables. Some Keywords may not work as varable names as well.

Although there is no checking done, parsing errors could occure.  Please try the command

LET in such cases. In general, as long as an ending of a variable name is dioeerent from any

command or keyword, it's usable as name.

   Reserved and system variables are:

    TRUE                -1

    FALSE               0

    PI                  3.14159265359...

    TIMER               unix system timer, AEoat, seconts

    STIMER              integer system timer

    CTIMER              system timer in units of CPU-time

    PC                  line number of next line to be processed

    SP                  internal stack pointer

    ROWS                number of rows of the terminal

    COLS                number of columns of the terminal

    ERR                 error number of last error

    MOUSEX              x coordinate of mouse position relative to window

    MOUSEY              y coordinate of mouse position

    MOUSEK              mouse button state

    MOUSES              state of the shift,alt,ctrl,caps keys

    INKEY$              content of the keyboard-buoeer

    TERMINALNAME$       device name of the standard terminal

    TIME$               current time

    DATE$               current date



4.2.    Abbreviations



In direct mode in the interpreter every command can be abbreviated as long as the command

parser can identify uniquely the command. So you may use q instead of QUIT.

   In addition there are abbreviations which are actually alternate commands like:



                                                                                               67

4.__Quick_reference_______________________________________________________________________________



                                         ________________
                                         |  '  REM     |
                                         |             |
                                         |  ?  PRINT   |
                                         |             |
                                         |  @  GOSUB  |
                                         |            |
                                         |  "  VOID    |
                                         |             |
                                         |  &  EVAL    |
                                         |_____________|_



4.3.    Commands



AFTER  n,procedure                   execute procedure after n seconds

ARRAYFILL  a(),b                      olls array with value

ARRAYCOPY  dest(),souce()          copies array including Dimensionierung

BEEP                                    Beep (on TTY/console)

BELL                                    same as BEEP

BGET  #f,a,n                           read n bytes from ole #f to adress a

BLOAD  f$,a[,l]                       reads entire ole (given by name) to adress a

BMOVE  q,z,n                           copies a block of n bytes from adress q to z

BPUT  #f,a,n                           writes n bytes from adress a to ole/channel f

BREAK                                   same as EXIT IF true

BSAVE  f$,a,l                          saves l bytes in memory at adress a to ole f$

CALL  adr[,par,...]                  see EXEC

CASE  const                            see SELECT * CASE * DEFAULT * ENDSELECT

CHAIN  bas$                            executes another basic program

CLEAR                                   clear and remove all variables

CLOSE  [[#]n]                          close ole, I/O channel or link

CLR  a,b,c(),f$                       clear variables

CLS                                      clear (text)screen

CONT                                    continue (after STOP)

DATA  1,"Hallo",...                  deone constants

DEFAULT                                see SELECT * CASE * DEFAULT * ENDSELECT

DIM                                      Declarate array

DO  *  LOOP                              Loop

DPOKE  adr,word                       write short int word to adr

DUMP                                    lists all used variable names

DUMP  "@"                               list of Funktionen und Prozeduren

DUMP  ":"                               list of all labels

DUMP  "#"                               list of open Files

DUMP  "K"                               list of implementierten Kommandos

DUMP  "F"                               list of internal functions

ECHO  ON/OFF                           same as TRON * TROFF

EDIT                                    call default editor to edit program



68

     ____________________________________________________________________________4.3.__Commands_____________



ELSE                                    see IF * ELSE * ENDIF

END                                      program end, enter interactive mode

ENDFUNCTION                           see FUNCTION * ENDFUNCTION

ENDIF                                   see IF * ELSE * ENDIF

ENDSELECT                              see SELECT * CASE * DEFAULT * ENDSELECT

ERASE  a()[,b$(),...]               erase arrays

ERROR  n                                execute error number n

EVAL  t$                                execute X11-Basic command contained in t$

EVERY  n,procedure                   invokes procedure every n seconds

EXEC  adr[,var[,...]]               call a C subroutine at pointer adr.

EXIT  IF  a                              exit loop if condition a is TRUE

FLUSH  [#n]                            AEush output

FOR  *  NEXT                            For Next loop

FORM_INPUT  t$                        input string with default value

FUNCTION  *  ENDFUNC                  deone function

GOSUB  procedure(varliste)        call subroutine

GOTO  label                            goto label

HELP  <expr>                           prints short help on expr

HOME                                    Textcursor home

IF  *  ELSE  IF  *  ELSE  *  ENDIF      conditions

INC  a                                   increments variable a

INPUT  [#n,]["text";]  varlist    read values for variables

LET  a=b                                enforces assignment

LINEINPUT  [#n,]t$                   read entire line from channel/ole/console

LINK  #n,t$                            load shared object ole t$

LIST  [s,e]                            List programm code (from line s to e)

LOAD  a$                                load Program

LOCAL  var[,var2,...]               specioes a list of vars to be local in Procedure or function

LOCATE  column,row                   Place cursor on column and row

LOOP                                    see DO * LOOP

LPOKE  adr,long                       writes long int value to pointer adr

LSET  t$=a$

MERGE  f$                               Merges bas-ole to actual program code

MUL  a,b                                same as a=a*b

NEW                                      clear and erase all variables and stop.

NEXT                                    see FOR * NEXT

NOP                                      no operation do nothing

NOOP                                    no operation do nothing

ON  *  GOSUB  proc1[,proc2,...]

ON  *  GOTO  label1[,label2,...]

ON  BREAK  GOSUB  proc

ON  ERROR  GOSUB  proc



                                                                                               69

4.__Quick_reference_______________________________________________________________________________



OPEN  mode$,#n,filename$           open a ole or socket for input and/or output

OUT  #n,a                               out byte a to channel n

PAUSE  sec                              pauses sec seconds

PLIST                                   formatted listing

POKE  adr,byte                        write byte to pointer adr

PRINT  a;b$                            console output

PRINT  #n;                              output to channel/ole

PRINT  AT(x,y);                       locate textcursor at row y and column x

PRINT  a  USING  f$                    print number with formatter

PROCEDURE  procname  [(p1  [,p2]  ...   )]   *  RETURN

PSAVE  a$                               writes the reformatted BASIC-program into ole a$

PUTBACK  [#n,]a                       put back a char to channel/ole/console

QUIT                                    quits the X11-BASIC-Interpreter

RANDOMIZE  [seed]                    Sets seed for random generator, default is TIMER

READ  var                               reads constant from DATA statement

RELSEEK  #n,d                          Place olepointer on new relative position d

REM  comment                           comment

REPEAT                                  see REPEAT * UNTIL

RESTORE  [label]                      (re)sets pointer for READ-statement to label

RESUME

RETURN                                  deone the end of a PROCEDURE

RETURN  expr                           return value from FUNCTION

RSRC_LOAD  filename$                loads GEM rsc-File (ATARI ST)

RSRC_FREE                              frees GEM rsc-File (ATARI ST)

RUN                                      start program

SAVE  [a$]                              writes the BASIC-program into ole with the name a$

SEEK  #n,d                              Place olepointer on new absolute position d

SETENV  t$=a$                          Sets environmentvar t$ using value a$

SORT  a(),n[,b()]                    Sort array

SOUND  freq                            Sound the internal speaker

SWAP

SYSTEM  t$                              excecute shell with command t$

TROFF                                   Trace mode ooe

TRON                                    Trace mode on (for debugging)

UNLINK  #n                              unlinks shared object #n

UNTIL  exp                              if exp is false goto REPEAT

VERSION                                shows X11-Basic version number and date

VOID  a                                  claculates expresion a and discard result

WORT_SEP  t$,d$,mode,a$,b$        separates string t$ by deliminator d$ in a$ and b$



70

     ___________________________________________________________________4.4.__Graphic_commands______________



4.4.    Graphic commands



ALERT  a,b$,c,d$,var[,ret$]       Infobox

BOX  x1,y1,x2,y2                      draw a frame

CIRCLE  x,y,r                          draw a circle

CLEARW  [[#]n]                        clear graphic window

CLOSEW  [[#]n]                        close graphic window

COLOR  f[,b]                           Set foreground color (and background color)

DEFFILL  c,a,b                        set oll style and pattern

DEFLINE  a,b                           set line width and type

DEFMARK  c,a,g                        set colour, size, type (POLYMARK)

DEFMOUSE  i                            set mouse cursor type

DEFTEXT  c,s,r,g                      set text properties for ltext

DRAW  [[x1,y1]  TO]  x2,y2           draw line

ELLIPSE  x,y,a,b[,a1,a2]           draw an ellipse

FILESELECT  tit$,pfad$,default$,f$display a oleselector-box

GET  x,y,w,h,g$                       Graok-Ausschnitt in g$ speichern

GPRINT                                  like PRINT, but the output goes to the graphic window

GRAPHMODE  mode                       set graphic-mode

KEYEVENT  a,b                          Waits until key is pressed

LINE  x1,y1,x2,y2                    draw a line

LTEXT  x,y,t$                          Linegraphic-Text

MENUDEF  array$(),proc              read text for menu-header from array$()

MENUKILL                               deletes menue

MENUSET  n,x                           change menu-point #n with value x

MENU  STOP                              switch ooe the menu

ONMENU                                  execute the menu and

MENU                                    wait for menue-events

MOUSE  x,y,k                           gets position and state of mouse

MOUSEEVENT                            wait for mouse event

MOTIONEVENT                           wait for mouse movement

MOVEW  n,x,y                           move window

OPENW  n                                open window

PBOX   x1,y1,x2,y2                   draw olled box

PCIRCLE  x,y,r[,a1,a2]              draw olled cirle

PELLIPSE  x,y,a,b[,a1,a2]          draw olled ellipse

PLOT  x,y                               draw point

POLYLINE  n,x(),y()                  draw polygon in (x(),y())

POLYFILL  n,x(),y()                  draw olled polygon

POLYMARK  n,x(),y()                  draw polygon points

PRBOX  x1,y1,x2,y2                   draw olled rounded box



                                                                                               71

4.__Quick_reference_______________________________________________________________________________



PUT  x,y,g$                            map graphic at position

PUT_BITMAP  t$,i,i,i,i              map bitmap

RBOX  x1,y1,x2,y2                    draws a rounded box

SCOPE  a(),typ,ys,yo                fast plot a()

SCOPE  y(),x(),typ,ys,yo,xs,xo   fast 2D plot

SGET  screen$                          capture graphic and store it in screen$

SHOWPAGE                               maps all graphic to window

SPUT  screen$                          maps (xwd-)graphic to window

TEXT  x,y,t$                           draw text

TITLEW  n,t$                           set window title

VSYNC                                   same as SHOWPAGE

XLOAD                                   load a program, with FILESELECTOR

XRUN                                    load and run a program, with FILESELECTOR



4.5.    Math commands



ADD  a,b                                same as a=a+b but faster

DEC  var                                same as var=var-1 but faster

DIV  a,b                                same as a=a/b but faster

FFT  a(),i                              fast fourier transformation on 1D array.

FIT  x(),y()[,yerr()],n,func(x,a,b,c,...)

                                          ots function to data

FIT_LINEAR  x(),y()[,[xerr(),]yerr()],n,a,b[,siga,sigb,chi2,q]

                                          linear regression with errors

INC  var                                same as var=var+1 but faster

MUL  a,b                                same as a=a*b but faster

SORT  a(),n[,b()]                    sorts n values of a() to incrementing order

SUB  a,b                                same as a=a-b but faster



4.6.    Math functions


The math function library contains a comprehensive set of mathematics functions, including:


    ffltrigonometric

    fflarc-trigonometric

    fflhyperbolic

    fflarc-hyperbolic

    ffllogarithmic ( base e and base 10 )



72

     ________________________________________________________________________4.6.__Math_functions___________



    fflexponential ( base e and base 10 )

    fflmiscellaneous ( square root, power, etc. )


Some math functions are deoned on Vectors and Matrices.



b=ABS(a)                        absolut value

c=ADD(a,b)                     add

a=CINT(b)                      Truncate number (NOTE: dioeers from INT() ! )

a=RND(dummy)                  random number between 0 and 1

a=GASDEV(dummy)              random number Gauss distribution

a=RAND(dummy)                 random integer number between 0 and a large number

a=RANDOM(n)                    random integer number between 0 and n

i=SGN(a)                        sign of a (-1,0,1)

b=SQR(a)                        square root

b=SQRT(a)                      square root

b=TRUNC(a)                     round a to the nearest integer not larger in absolute value

b=FRAC(a)                      fractional (non integer) part of a

b=INT(a)                        convert to integer

b=LN(a)                         base e logarithm (natural log)

b=LOG(a)                        base e logarithm (natural log)

b=LOG10(a)                     base 10 logarithm

b=EXP(a)                        base e "anti-log" (e to the x)

b=FAK(a)                        Fakultaet



4.6.1.   Angles


Angles are always radians, for both, arguments and return values.



b=RAD(a)                        convert degrees to radians

b=DEG(a)                        convert radians to degrees



4.6.2.   Trigonometric functions



b=SIN(a)                        sine

b=COS(a)                        cosine

b=TAN(a)                        tangent

b=COT(a)                        cotangent



                                                                                               73

4.__Quick_reference_______________________________________________________________________________



b=SEC(a)                        secant

b=CSC(a)                        cosecant

b=ASIN(a)                      arc-sine

b=ACOS(a)                      arc-cosine

b=ATAN(a)                      arc-tangent

b=ATAN2(a,c)                  extended arc-tangent

b=ACOT(a)                      arc-cotangent

b=ASEC(a)                      arc-secant

b=ACSC(a)                      arc-cosecant

b=SINH(a)                      hyperbolic sine

b=COSH(a)                      hyperbolic cosine

b=TANH(a)                      hyperbolic tangent

b=COTH(a)                      hyperbolic cotangent

b=SECH(a)                      hyperbolic secant

b=CSCH(a)                      hyperbolic cosecant

b=ASINH(a)                     hyperbolic arc-sine

b=ACOSH(a)                     hyperbolic arc-cosine

b=ATANH(a)                     hyperbolic arc-tangent

b=ACOTH(a)                     hyperbolic arc-cotangent

b=ASECH(a)                     hyperbolic arc-secant

b=ACSCH(a)                     hyperbolic arc-cosecant



4.6.3.   Boolean functions



a=EVEN(d)                      TRUE if d is even number

a=ODD(d)                        TRUE if d is odd number



4.7.    String functions



b$=BIN$(a[,n])                convert to binary number

t$=CHR$(a)                     convert ascii code to string

t$=ENV$(n$)                    read value of environment variable n$

t$=HEX$(a[,n])                a as Hexadecimal number

t$=INLINE$(a$)                7Bit-ASCII to Binary conversion, can be used to include Binary data in the source code.

t$=INPUT$(#n,num)            reads num bytes from ole/channel n

d$=juldate$(a)                date$ by julian day a

u$=LCASE$(t$)                 converts t$ to lower case

t$=LEFT$(a$[,n])             extraxts from string a$ the orst (left) n characters



74

     _____________________________________________________________________4.8.__Graphic_functions___________



u$=LOWER$(t$)                 converts t$ to lower case

m$=MID$(t$,s[,l])            extraxts from string t$ a string from position s with l characters

t$=MKI$(i)                     convert Integer to 2-Byte String

t$=MKL$(i)                     convert integer to 4-Byte String

t$=MKF$(a)                     convert AEoat to 4 Byte String

t$=MKD$(a)                     convert AEoat to 8 Byte String

o$=OCT$(d,n)                  convert integer d to string with octal number

t$=PRG$(i)                     Program line

t$=RIGHT$(a$[,n])            returns right n characters of a$

t$=SPACE$(i)                  returns string consisting of i spaces

t$=STR$(a[,b,c])             convert number to String of length b with c signiokant digits

t$=STRING$(w$,i)             returns string consisting of i copys of w$

t$=SYSTEM$(n$)                execute shell with command n$

t$=TERMINALNAME$(#n)        returns device name of terminal connected to #n

u$=UCASE$(t$)                 converts t$ to upper case

t$=unixtime$(i)              give time$ from TIMER value

d$=unixdate$(i)              give date$ from TIMER value

u$=UPPER$(t$)                 converts t$ to upper case



4.8.    Graphic functions



a=FORM_ALERT(n,t$)                         message box with default button n

a=FORM_DIAL(i,i,i,i,i,i,i,i,i)         complex function

a=FORM_DO(i)                                 do dialog

c=GET_COLOR(r,g,b)                         allocate color by rgb value

dummy=OBJC_DRAW(i,i,i,i,i)               draw object tree

ob=OBJC_FIND(tree,x,y)                    return object number by coordinates

c=POINT(x,y)                                 returns color of pixel of graphic in window

a=RSRC_GADDR(typ,nr)                       get pointer to object tree



4.9.    Other functions



a=ARRPTR(b())                 pointer to array descriptors

a=ASC(t$)                      ASCII code of orst letter of string

b=CVI(a$)                      convert 2-byte string to integer

b=CVL(a$)                      convert 4-byte string to integer

b=CVS(a$)                      convert 4-byte string to AEoat

b=CVF(a$)                      convert 4-byte string to AEoat



                                                                                               75

4.__Quick_reference_______________________________________________________________________________



b=CVD(a$)                      convert 8-byte string to double

a=DIM?(a())                    returns number of elements of array a()

i=DPEEK(adr)                  read word from pointer adr

b=EOF(#n)                      TRUE if ole pointer reached end of ole

a=EVAL(t$)                     evaluate expression contained in t$

b=EXIST(fname$)              TRUE if ole fname$ exist

ret=EXEC(adr[,var])         see command EXEC, returns int

a=FREEFILE()                  Returns orst free olenumber or -1

f=GLOB(a$,b$[,flags])      TRUE if a$ matches pattern b$

b=GRAY(a)                      Gray code.pif_a<0:_inverse Gray code

a=HYPOT(x,y)                  returns    x2 + y2

c=INP(#n)                      reads character (Byte) from channel/ole.

c=INP?(#n)                     number of chars which can be read from channel/ole

a=INP&(#n)                     reads word (2 Bytes) from channel/ole.

i=INP%(#n)                     reads long (4 Bytes) from channel/ole.

a=INSTR(s1$,s2$[,n])        tests if s2$ is contained in s1$

a=julian(date$)              julian day

l=LEN(t$)                      length of string

p=LOC(#n)                      Returns value of ole position indicator

l=LOF(#n)                      length of ole

b=LPEEK(adr)                  reads long (4 Bytes) from adress

m=MAX(a,b,c,...)             returns biggest value

m=MAX(f())                     not implemented jet

m=MIN(a,b,c,...)             returns smallest value

m=MIN(array())                not implemented jet

m=MIN(function())            not implemented jet

d=PEEK(a)                      reads Byte from address a

a=RINSTR(s1$,s2$[,n])      tests (starting from right) if s2$ is contained in s1$

adr=SYM_ADR(#n,s$)          return pointer to symbol with name s$ from shared Object ole #n

a=VAL(t$)                      converts String/ASCII to number

i=VAL?(t$)                     returns number of chars which can be converted to number

a=VARPTR(v)                    returns pointer to variable



4.10.    Subroutines and Functions



4.10.1.   Subroutines


Subroutines are blocks of code that can be called from elsewhere in the program. Subroutines

can take arguments but return no results. They can access all variables available but also may

have local variables (> LOCAL). Subroutines are deoned with



76

     ______________________________________________________________________4.11.__Error_Messages____________



          PROCEDURE  name(argumentlist)

            ...   many  commands

          RETURN



4.10.2.   User deoned functions


X11-Basic functions are blocks of code that can be called from elsewhere within an expression

(e.g a=3*@myfunction(b)). Functions can take arguments and must return a result. Variables

are global unless declared local. For local variables changes outside a function have no eoeect

within the function except as explicitly specioed within the function. Functions arguments can

be variables and arrays of any types. Functions can return variables of any type. By default,

arguments are passed by value.  Functions can be executed recursively.  A function will be

deoned by:


          FUNCTION  name(argumentlist)

            ..  many  more  calculations

            RETURN  returnvalue

          ENDFUNCTION



4.11.    Error Messages


X11-Basic can produce a number of internal errors, which are reoeerred to by a number (ERR)

(see also ERROR).

   The meaning of this errors and their text expression is as follows:



0       Divide by zero

1       OverAEow

2       Value not integer 2147483648 : :2:147483647

3       Value not byte 0 : :2:55

4       Value not short 32768 : :3:2767

5       Square root: only positive numbers

6       Logarithmen nur fr Zahlen grer Null

7       Unknown Error

8       Out of Memory

9       Function or command not yet implemented

10      String too long

12      Program too long, buoeer size exeeded > NEW

14      Array () already dimensioned

15      Array () not dimensioned

16      Field index too large

17      Dim too large



                                                                                               77

4.__Quick_reference_______________________________________________________________________________



18      Wrong number of indicies

19      Procedure not found

20      Label not found

21      Open only "I"nput "O"utput "A"ppend "U"pdate

22      File already opened

23      Wrong ole #

24      File not opened

25      Wrong input, no number

26      EOF - reached end of ole

27      Too many points for Polyline/Polyoll

28      Array must be one dimensional

30      Merge - no ASCII ole

31      Merge - line too long - CANCEL

32      ==> Syntax error

33      Label not deoned

34      Not enough data

35      data must be numeric

36      Error in program structure

37      Disk full

38      Command not allowed in interactive mode

39      Program Error Gosub impossible

40      CLEAR not allowed within For-Next-loops or procedures

41      CONT not possible here

42      Not enough parameters

43      Expression too complex

44      Function not deoned

45      Too many parameters

46      Incorrect parameter , must be number

47      Incorrect parameter , must be string

48      Open "R" - incorrect Field length

49      Too many "R"-oles (max. 31)

50      No "R"-ole

51      Parser: Syntax Error <>

52      Fields larger than oeld length

53      Wrong graphic format

54      GET/PUT wrong Field-String length

55      GET/PUT Satznummer falsch

56      Wrong number of parameters

57      Variable is not yet initialized

58      Variable has incorrect type

59      Graphic has wrong color depth

60      Sprite-String length wrong



78

     ______________________________________________________________________4.11.__Error_Messages____________



61      Fehler bei RESERVE

62      Menu falsch

63      Reserve falsch

64      Pointer falsch

65      Feldgre < 256

66      Kein VAR-Array

67      ASIN/ACOS falsch

68      Falsche VAR-Type

69      ENDFUNC ohne RETURN

70      Unbekannter Fehler 70

71      Index zu gro

72      Fehler bei RSRC_LOAD

73      Fehler bei RSRC_FREE

80      Matrizenoperationen nur fr ein- oder zweidimensionale Felder

81      Matrizen haben nicht die gleiche Ordnung

82      Vektorprodukt nicht deoniert

83      Matrizenprodukt nicht deoniert

84      Scalarprodukt nicht deoniert

85      Transposition nur fr zweidimensionale Matrizen

86      Matrix nicht quadratisch

87      Transposition nicht deoniert

88      FACT/COMBIN/VARIAT nicht deoniert

89      Array must be two dimensional

90      Fehler bei Local

91      Fehler bei For

92      Resume (next) nicht mglich Fatal, For oder Local

93      Stapel-Fehler

97      This operation is not allowed for root window

98      Illegal Window number (0-16)

99      Window does not exist

100     X11BASIC Version 1.19 Copyright (c) 1997-2012 Markus Hooemann

101     ** 1 - Segmentation fault : Speicherschutzverletzung

102     ** 2 - Bus Error Peek/Poke falsch?

103     ** 3 - Adress error Ungerade Wort-Adresse! Dpoke/Dpeek, Lpoke/Lpeek?

104     ** 4 - Illegal Instruction : ungltiger Maschinenbefehl

105     ** 5 - Divide by Zero : Division durch Null

106     ** 6 - CHK exeption : CHK-Befehl

107     ** 7 - TRAPV exeption : TRAPV-Befehl

108     ** 8 - Privilege Violation : Privilegverletzung

109     ** 9 - Trace exeption : Trace ohne Monitor

110     ** 10 - Broken pipe : Ausgabeweitergabe abgebrochen

131     * Number of hash collisons exceeds maximum generation counter value.



                                                                                               79

4.__Quick_reference_______________________________________________________________________________



132     * Wrong medium type : Andere Diskette einlegen

133     * No medium found : Bitte Disk einlegen

134     * Quota exceeded

135     * Remote I/O error

136     * Is a named type ole

137     * No XENIX semaphores available

138     * Not a XENIX named type ole

139     * Structure needs cleaning

140     * Stale NFS ole handle

141     * Operation now in progress

142     * Operation already in progress

143     * No route to host

144     * Host is down

145     * Connection refused : Verbindungsaufbau verweigert

146     * Connection timed out : Zeitberschreitung bei Verbindung

147     * Too many references: cannot splice

148     * Cannot send after transport endpoint shutdown

149     * Transport endpoint is not connected : Keine Verbindung, Verbindung unterbrochen ?

150     * Transport endpoint is already connected : Verbindung schon geoenet

151     * No buoeer space available : Speicher voll

152     * Connection reset by peer

153     * Software caused connection abort : Verbindungsabbruch durch Anwender

154     * Network dropped connection because of reset

155     * Network is unreachable

156     * Network is down

157     * Cannot assign requested address : Verbindungsaufbau nicht mglich

158     * Address already in use : Besetzt, Verbindung nicht mglich

159     * Address family not supported by protocol

160     * Protocol family not supported

161     * Operation not supported on transport endpoint

162     * Socket type not supported

163     * Protocol not supported

164     * Protocol not available

165     * Protocol wrong type for socket

166     * Message too long

167     * Destination address required

168     * Socket operation on non-socket : Operation nur mit Sockets erlaubt

169     * Too many users

170     * Streams pipe error

171     * Interrupted system call should be restarted

172     * Illegal byte sequence

173     * Cannot exec a shared library directly



80

     ______________________________________________________________________4.11.__Error_Messages____________



174     * Attempting to link in too many shared libraries

175     * .lib section in a.out corrupted

176     * Accessing a corrupted shared library

177     * Can not access a needed shared library

178     * Remote address changed

179     * File descriptor in bad state

180     * Name not unique on network

181     * Value too large for deoned data type

182     * Not a data message

183     * RFS specioc error

184     * Try again : Operation zur Zeit nicht mglich

185     * Too many symbolic links encountered

186     * File name too long : Dateiname zu lang

187     * Resource deadlock would occur

188     * Advertise error

189     * Speicherblockfehler

190     * Kein Binrprogramm

191     * Link has been severed

192     * Object is remote

193     * Math result not representable

194     * Math arg out of domain of func

195     * Cross-device link

196     * Device not a stream

197     * Mount device busy

198     * Block device required

199     * Bad address

200     * No more processes

201     * No children

202     * Exchange full

203     * Interrupted system call

204     * Invalid exchange

205     * Permission denied, you must be super-user

206     * Operation auf diesem Kanal nicht (mehr) mglich

207     * Keine weiteren Dateien

208     * Link number out of range

209     * Level 3 reset

210     * Ungltige Laufwerksbezeichnung

211     * Level 2 not synchronized

212     * Channel number out of range

213     * Identioer removed

214     * No message of desired type

215     * Operation would block



                                                                                               81

4.__Quick_reference_______________________________________________________________________________



216     * Ungltige Speicherblockadresse

217     * Directory not empty : Das Verzeichnis ist nicht leer

218     * Function not implemented : Unbekannter Befehl

219     * Ungltiges Handle

220     * Zugrioe nicht mglich

221     * Zu viele Dateien ooeen

222     * Pfadname nicht gefunden

223     * Datei nicht gefunden

224     * Broken pipe : Verbindung wurde unterbrochen

225     * Too many links : Zu viele Links

226     * Read-Only File-System : File-System ist Schreibgeschtzt

227     * Illegal seek : Seek falsch

228     * No space left on device : File-System ist voll

229     * File too large : File ist zu gross fr diese Operation

230     * Text ole busy

231     * Not a typewriter

232     * Too many open oles

233     * File table overAEow : Zur Zeit sind keine weiteren ooeenen Files mglich

234     * Invalid argument

235     * Is a directory

236     * Not a directory

237     * No such device

238     * Cross-device link

239     * File exists

240     * Bad Sektor (Verify)

241     * Unbekanntes Gert

242     * Diskette wurde gewechselt

243     * Permission denied : Die Erlaubnis wurde verweigert

244     * Not enough core : Speicher voll

245     * Lesefehler

246     * Schreibfehler

247     * Kein Papier

248     * Sektor nicht gefunden

249     * Arg list too long : Zu viele Parameter

250     * Seek Error Spur nicht gefunden

251     * Bad Request Ungltiger Befehl

252     * CRC Fehler Disk-Prfsumme falsch

253     * No such process

254     * Timeout

255     * IO-Error : Allgemeiner IO-Fehler



82




5.     X11-Basic  command  reference



5.1.    Syntax templates


This manual describes the syntax of BASIC commands and BASIC functions in a generalized

form. Here is an example:



PRINT  [#<device-number>,]  <expression>  [<,>_<;>  [...]]



   Those parts of the command that must appear literally in the source code (like PRINT in

the example above) are all uppercase. Descriptions in angle brackets ("<>") are not meant to

appear literally in the source code but are descriptive references to the element that is supposed

to be used in the source code at this place, like a variable, a numeric expression etc. Optional

elements are listed inside square brackets ("[]").  They may be omitted from the command

line. Mutually exclusive alternatives are separated by the "_" character. Exactly one of these

alternatives must appear in the command line. Finally, repetitive syntax is indicated by three

dots "...". Here are some BASIC command lines that all match the syntax template above:



PRINT  x

PRINT  #1,2*y

PRINT  "result  =  ";result



                                                                                               83

5.__X11-Basic_command_reference___________________________________________________________________



5.2.    A



84

     ______________________________________________________________________________________5.2.__A__________



  Function:             ABS()



 Syntax:        <num-result>=ABS(<num-expression>)



DESCRIPTION:



  Returns the absolute value of an expression. The absolute value is the value without regard

to the sign (negative, zero or positive). The result of ABS will always be a positive number or

zero.



  SEE ALSO:       SGN()



EXAMPLE:


PRINT ABS(-34.5),ABS(34)
        Result: 34.5      34



                                                                                               85

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             ACOS()



  Syntax:      <num-result>=ACOS(<num-expression>)



DESCRIPTION:



   The acos() is the arcus cosine-function, i.e. the inverse of the cos()-function. It returns the

angle (in radian), which, fed to the cosine-function will produce the argument passed to the

acos()-function.



EXAMPLE:



PRINT ACOS(0.5),ACOS(COS(PI))
Result: 1.047197551197  3.14159265359



   SEE ALSO:       COS(),ASIN()


                          _______________________*______________________



   Function:             ACOSH()



  Syntax:      <num-result>=ACOSH(<num-expression>)



DESCRIPTION:



   The acosh() is the inverse hyperbolic cosine function, i.e. the inverse of the cosh()-function.

It returns the angle (in radian), which, fed to the hyperbolic cosine-function will produce the

argument passed to the acosh()-function.



   SEE ALSO:       COSH(),ASINH()



86

     ______________________________________________________________________________________5.2.__A__________



  Command:             ADD



 Syntax:        ADD  <num-variable>,<num-expression>



DESCRIPTION:



  Increase value of variable by result of <num-expression>.



EXAMPLE:


a=0.5
ADD a,5
Result: 5.5



   SEE ALSO:       SUB,MUL,DIV


                          _______________________*______________________



Function:             ADD()



  Syntax:      <num-result>=ADD(<num-expression>,<num-expression>)



DESCRIPTION:



   (Integer) addition.



EXAMPLE:


a=0.5
b=ADD(a,5)
Result: 5.5



   SEE ALSO:       SUB(),MUL(),DIV()



                                                                                               87

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             AFTER



  Syntax:      AFTER  <num-variable>,  <procedure-name>

               AFTER  STOP

               AFTER  CONT



DESCRIPTION:



   Procedures can be called after the expiry of a set time. Time in seconds. To continue the

process, use CONT, and to stop use STOP.



EXAMPLE:



PRINT "You have 10 seconds to enter your name: "
AFTER 10,alarm
INPUT name$
END
PROCEDURE alarm
  PRINT "Time out !"
  QUIT
RETURN



   SEE ALSO:       EVERY



88

     ______________________________________________________________________________________5.2.__A__________



  Command:             ALERT



 Syntax:        ALERT  <type>,<message-string>,<default-button>,

                <button-string>,<num-var>[,<string-var>]



DESCRIPTION:



  Creates an alert box and asks for user input.

  <type> chooses type of alert symbol, 0=none, 1="!", 2="?", 3="stop" <message-string>

Contains main text.  Lines are separated by the '_' symbol.  Editable oelds are started with a

chr$(27) followed by the default text to be edited (until "_"). <button-string> Contains text for

the buttons (separated by '_'). <default-button> is the button to be highlighted (0=none,1,2,...)

to be selected by just pressing return.  <num-var> This variable is set to the number of the

button selected.  <string-var> This is a string variable which holds any text-input the user

made. It holds the contents of the editable oelds separated by a CHR$(13).



EXAMPLES:



ALERT 1,"Pick a_button",1,"Left_Right",a
ALERT 0,"You pressed_Button"+STR$(a),0,"OK",a

' Example of editable fields
i=1
name$="TEST01"
posx$="N54ffi50'32.3"
t$="Edit waypoint:__Name:    "+chr$(27)+name$+"_"
t$=t$+"Position: "+chr$(27)+posx$+"_"
ALERT 0,t$,1,"OK_UPDATE_DELETE_CANCEL",a,f$
WHILE LEN(f$)
  WORT_SEP f$,CHR$(13),0,a$,f$
  PRINT "Field";i;": ",a$
  INC i
WEND



   SEE ALSO:       FORM"_ALERT(),WORT"_SEP,CHR"$()



                                                                                               89

5.__X11-Basic_command_reference___________________________________________________________________



   Operator:             AND



  Syntax:      <num-expression1>  AND  <num-expression2>



DESCRIPTION:



   Used to determine if BOTH conditions are true. If both expression1 AND expression2 are

true (non-zero), the result is true. Returns -1 for true, 0 for false.

   Also used to compare bits in binary number operations.  1 AND 1 return a 1, all other

combinations of 0's and 1's produce 0.



EXAMPLES:



Print 3=3 AND 4>2         Result:  -1 (true)
Print 3>3 AND 5>3         Result:    0 (false)

PRINT (30>20 AND 20<30)  Result:  -1 (true)
PRINT (4 AND 255)         Result:    4



   SEE ALSO:       NAND,OR,NOT,XOR


                          _______________________*______________________



   Function:             AND()



  Syntax:      <num-result>=AND(<num-expression>,<num-expression2>)



DESCRIPTION:



   Returns <num-expression> AND <num-expression2> ===doesnt exist in X11-Basic===



   SEE ALSO:       OR(),AND



90

     ______________________________________________________________________________________5.2.__A__________



  Variable:             ANDROID?



 Syntax:        ANDROID?



DESCRIPTION:



  This variable gives -1 if the operating system is an Android. else the variable has a value of

0.



  SEE ALSO:       TRUE,FALSE,UNIX?,WIN32?



                                                                                               91

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             ARID$()



  Syntax:      <string-result>=ARID$(<string-expression>)



DESCRIPTION:



   The arid$()-takes a string argument and returns the order-0 adaptive arithmetic decoding of

that string.



EXAMPLE:


         t$="Hello, this is a test!!!! This shows arithmetric coding and decoding with X11-Basic."
         b$=arie$(t$)  ! encode it
         print "The string was compressed to ";round(len(b$)/len(t$)*1000)/10;"%"
         c$=arid$(b$)  ! decode it
         print c$
  Result:
The string was compressed to 88.1%
         Hello, this is a test!!!! This shows arithmetric coding and decoding with X11-Basic.



   SEE ALSO:       ARIE"$()



92

     ______________________________________________________________________________________5.2.__A__________



  Function:             ARIE$()



 Syntax:        <string-result>=ARIE$(<string-expression>)



DESCRIPTION:



  The arie$()-takes a string argument and returns the order-0 adaptive arithmetic encoding of

that string.  Frequently used characters will be stored with fewer bits and not-so-frequently

occurring characters will be stored with more bits, resulting in fewer bits used in total.



EXAMPLE:


         t$="Hello, this is a test!!!! This shows arithmetric coding and decoding with X11-Basic."
         b$=arie$(t$)  ! encode it
         print "The string was compressed to ";round(len(b$)/len(t$)*1000)/10;"%"
         c$=arid$(b$)  ! decode it
         print c$
  Result:
The string was compressed to 88.1%
         Hello, this is a test!!!! This shows arithmetric coding and decoding with X11-Basic.



   SEE ALSO:       ARID"$()



                                                                                               93

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ARRAYCOPY



  Syntax:      ARRAYCOPY  d(),s()



DESCRIPTION:



   Copys the contents of array s() to d() (including dimensions).  This is the same as the

statement: d()=s().



   SEE ALSO:       DIM


                          _______________________*______________________



   Command:             ARRAYFILL



  Syntax:      ARRAYFILL  x(),n

               ARRAYFILL  x$(),t$



DESCRIPTION:



   Assigns the value to all elements of an array or matrix.



EXAMPLE:


DIM a(100)
ARRAYFILL a(),13
PRINT a(22)        Result: 13



   SEE ALSO:       DIM



94

     ______________________________________________________________________________________5.2.__A__________



  Function:             ARRPTR()



 Syntax:        <int-result>=ARRPTR(<array>())



DESCRIPTION:



  Finds the address of the descriptor of a string or oeld array.



EXAMPLE:


DIM a(100)
b$="Test"
adr%=ARRPTR(a())
adr2%=ARRPTR(b$)
PRINT "Array gas dimension: ";LPEEK(adr%)
PRINT "String has a length of: ";LPEEK(adr2%)



   SEE ALSO:       VARPTR()



                                                                                               95

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             ASC()



  Syntax:      <num-result>=ASC(<string-expression>)



DESCRIPTION:



   Returns the ASCII code value (a number between 0 and 255) of the orst character in a string.

ASCII stands for American Standard Code for Information Interchange. ASC returns 0 if the

length of string is zero or the ASCII code of the string is zero.



   SEE ALSO:       CHR"$(),CVI(),CVL(),CVS()



EXAMPLE:


PRINT ASC("A"), ASC("T")  Result: 65, 84
PRINT ASC("TEST")          Result: 84



96

     ______________________________________________________________________________________5.2.__A__________



  Function:             ASIN()



 Syntax:        <num-result>=ASIN(<num-expression>)



DESCRIPTION:



  The asin() is the arcus sine-function, i.e. the inverse of the sin()-function. Or, more elabo-

rate: It Returns the angle (in radian, not degree !), which, fed to the sine-function will produce

the argument passed to the asin()-function.



  SEE ALSO:       ACOS(),SIN()



EXAMPLE:


PRINT 6*ASIN(0.5)      Result: 3.14159265359



                          _______________________*______________________



   Function:             ASINH()



  Syntax:      <num-result>=ASINH(<num-expression>)



DESCRIPTION:



   The asinh() function calculates the inverse hyperbolic sine of x, i.e.  the inverse of the

sinh()-function. It returns the angle (in radian), which, fed to the hyperbolic sine-function will

produce the argument passed to the asinh()-function.



   SEE ALSO:       ACOSH(),SINH()



                                                                                               97

5.__X11-Basic_command_reference___________________________________________________________________



   Keyword:             AT()



  Syntax:      PRINT  AT(y,x);[...]



DESCRIPTION:



   The AT-statement takes two numeric arguments (e.g. AT(2,3)) and can be used in combina-

tion with the PRINT- or GPRINT-command.

   The two numeric arguments of the AT-function may range from 0 to the width of your

terminal minus 1, and from 0 to the height of your terminal minus 1; if any argument exceeds

these values, it will be truncated accordingly.  However, X11-Basic has no inAEuence on the

size of your terminal (80x25 is a common, but not mandatory), the size of your terminal and

the maximum values acceptable within the AT-statement may vary.  To get the size of your

terminal you may use the COLS and ROWS variables. To get the actual position of the text

cursor you may use the CRSCOL and CRSLIN variables.  (Currently they only work under

Android.).



   SEE ALSO:       PRINT,GPRINT,TAB(),SPC(),COLS,ROWS,CRSLIN,CRSCOL,LOCATE



98

     ______________________________________________________________________________________5.2.__A__________



  Function:             ATN(),   ATAN()



 Syntax:        <num-result>=ATN(<num-expression>)

                <num-result>=ATAN(<num-expression>)



DESCRIPTION:



  Returns the angle, in radians, for the inverse tangent of expression.



  SEE ALSO:       ACOS(),ASIN()



EXAMPLE:


PRINT 4*ATAN(1)      Result: 3.14159265359



                          _______________________*______________________



   Function:             ATAN2()



  Syntax:      <num-result>=ATAN2(<num-expression>,<num-expression>)



DESCRIPTION:



   The atan()-function has a second form which accepts two arguments: atan2(a,b) which is

(mostly) equivilantly to atan(a/b) except for the fact, that the two-argument-form returns an

angle in the range -pi to pi, whereas the one-argument-form returns an angle in the range -pi/2

to pi/2.



EXAMPLE:


 PRINT DEG(ATAN2(0,-1))      Result: 180



   SEE ALSO:       ATAN()



                                                                                               99

5.__X11-Basic_command_reference___________________________________________________________________



                          _______________________*______________________



   Function:             ATANH()



  Syntax:      <num-result>=ATANH(<num-expression>)



DESCRIPTION:



   The atanh() function calculates the inverse hyperbolic tangent of x; that is the value whose

hyperbolic tangent is x.  If the absolute value of x is greater than 1.0, atanh() returns not-a-

number (NaN).



EXAMPLE:


 PRINT DEG(ATANH(-0.5))      Result: -31.47292373095



   SEE ALSO:       ATAN()



100

     ______________________________________________________________________________________5.3.__B__________



5.3.    B



                                                                                              101

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             BCHG()



  Syntax:      <num-result>=BCHG(<num-expression>,<num-expression>))



DESCRIPTION:



   Allow setting and resetting of bits.



   SEE ALSO:       BSET(),BCLR()


                          _______________________*______________________



   Function:             BCLR()



  Syntax:      <num-result>=BCLR(<num-expression-x>,<num-expression-y>))



DESCRIPTION:



   BCLR sets the y-th bit of x to zero.



   SEE ALSO:       BSET(),BCHG()



102

     ______________________________________________________________________________________5.3.__B__________



  Command:             BEEP,   BELL



 Syntax:        BEEP

                BELL



DESCRIPTION:



  Sounds the speaker of your terminal.  This command is not a sound-interface, so you can

neither vary the length or the height of the sound (technically, it just prints chr$(7)). BELL is

exactly the same as BEEP.



  SEE ALSO:       SOUND



                                                                                              103

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             BGET



  Syntax:      BGET  #<device-nr>,<adr>,<len>



DESCRIPTION:



   Reads <len> bytes from a data channel into an area of memory starting at address <adr>

   Unlike BLOAD, several dioeerent areas of memory can be read from a ole.



   SEE ALSO:       BLOAD,BPUT



104

     ______________________________________________________________________________________5.3.__B__________



  Function:             BIN$()



 Syntax:        <string-result>=BIN$(<num-expression>[,<num-expression>)])



DESCRIPTION:



  The bin$()-takes a numeric argument and converts it into a string of binary digits (i.e. '0'

and '1'). The length of the output, number of digits, can be specioed by the optional second

argument.



EXAMPLE:


         PRINT BIN$(64),BIN$(-2000,16)
Result: 01000000         1111100000110000



   SEE ALSO:       HEX"$()



                                                                                              105

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             BLOAD



  Syntax:      BLOAD  <filename>,<address>



DESCRIPTION:



   BLOAD reads the specioed ole into memory.  The adress space <address> is pointing to

should be allocated before.  You should check if the ole exists prior to using this function.

This command is meant to be used for loading binary data. To load a text ole, use OPEN and

INPUT # to remain compatible with other BASIC implementations.



   SEE ALSO:       MALLOC(),BGET,INPUT,INPUT"$(),BSAVE



106

     ______________________________________________________________________________________5.3.__B__________



  Command:             BMOVE



 Syntax:        BMOVE  <scr>,<dst>,<len>



DESCRIPTION:



  Fast movement of memory blocks.

  <scr> is the address at which the block to be moved begins. <dst> is the address to which

the block is to moved. <len> is the length of the block in bytes.



  SEE ALSO:       PEEK(),POKE,BLOAD,BSAVE



                                                                                              107

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             BOUNDARY



  Syntax:      BOUNDARY  <num-expression>



DESCRIPTION:



   Switch ooe (or on) borders on olled shapes (PBOX, PCIRCLE ..). If the argument is zero -

no border will be drawn.



   SEE ALSO:       PBOX,PCIRCLE



108

     ______________________________________________________________________________________5.3.__B__________



  Command:             BOX



 Syntax:        BOX  <x>,<y>,<x2>,<y2>



DESCRIPTION:



  Draws a rectangle with corners at (x,y) and (x2,y2).



  SEE ALSO:       PBOX



                                                                                              109

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             BPUT



  Syntax:      BPUT  #<device-nr>,<adr>,<len>



DESCRIPTION:



   Reads <len> bytes from an area of memory starting at <adr> out to a data channel.



   SEE ALSO:       BGET



110

     ______________________________________________________________________________________5.3.__B__________



  Command:             BREAK



 Syntax:        BREAK



DESCRIPTION:



  BREAK transfers control immediately outside the enclosing loop or select statement. This

is the preferred way of leaving such a statement (rather than goto).



  SEE ALSO:       EXIT  IF



                                                                                              111

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             BSAVE



  Syntax:      <filename>,<adr>,<len>



DESCRIPTION:



   Save <len> bytes in memory from adress <adr> to ole. This command is meant be be used

for saving binary data obtained via BLOAD. To save text oles, use OPEN and PRINT # to

remain compatible with other BASIC implementations.



   SEE ALSO:       BLOAD,BPUT



112

     ______________________________________________________________________________________5.3.__B__________



  Function:             BSET()



 Syntax:        <num-result>=BSET(<num-expression-x>,<num-expression-y>)



DESCRIPTION:



  Allows setting and resetting of bits. BSET sets the y-th bit of x to 1.



  SEE ALSO:       BCHG(),BCLR(),BTST()



                                                                                              113

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             BTST()



  Syntax:      <bool-result>=BTST(<num-expression-x>,<num-expression-y>)



DESCRIPTION:



   BTST results in -1 (TRUE) if bit y of x is set.



   SEE ALSO:       BCHG(),BCLR(),BSET()



114

     ______________________________________________________________________________________5.3.__B__________



  Function:             BWTD$()



 Syntax:        b$=BWTD$(a$)



DESCRIPTION:



  BWTD$() performs the inverse Burrows-Wheeler transform on the string a$.



  SEE ALSO:       BWTE"$()



                                                                                              115

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             BWTE$()



  Syntax:      b$=BWTE$(a$)



DESCRIPTION:



   BWTE$() performs a Burrows-Wheeler transform on the string a$.

   The Burrows-Wheeler transform (BWT) is an algorithm used in data compression tech-

niques such as bzip2. It was invented by Michael Burrows and David Wheeler.

   When a character string is transformed by the BWT, none of its characters change. It just

rearranges the order of the characters. If the original string had several substrings that occurred

often, then the transformed string will have several places where a single character is repeated

multiple times in a row. This is useful for compression, since it tends to be easy to compress

a string that has runs of repeated characters by techniques such as run-length encoding.



EXAMPLE:



         t$="Hello, this is the Burrows Wheeler transformation!"
         b$=bwte$(t$)  ! encode it
         print b$
         c$=bwtd$(b$)  ! decode it
         print c$

Result:
esss,rno ! rmhheHlstWtth eelroalifretoruwiin  a Bo
Hello, this is the Burrows Wheeler transformation!



   SEE ALSO:       BWTD"$()



116

     ______________________________________________________________________________________5.3.__B__________



  Function:             BYTE()



 Syntax:        <num>=BYTE(<num-expression>)



DESCRIPTION:



  Returns lower 8 bits of argument. (same as a=b AND 255)



  SEE ALSO:       CARD(),WORD(),SWAP()



                                                                                              117

5.__X11-Basic_command_reference___________________________________________________________________



5.4.    C



118

     ______________________________________________________________________________________5.4.__C__________



  Command:             CALL



 Syntax:        CALL  <adr>[,<parameter-list>]



DESCRIPTION:



  Calls a machine code or C subroutine at address <adr> without return value.  Optinal pa-

rameters are passed on the stack. (like in C). The default parameter-type is (4-Byte) integer. If

you want to specify other types, please use preoxes:

  D:  double (8-Bytes) F:  AEoat (4-Bytes) L:  long int



  SEE ALSO:       EXEC,EXEC()



EXAMPLE:


DIM result(100)
LINK #1,"simlib.so"
adr=SYM_ADR(#1,"CalcBeta")
CALL adr,D:1.2,L:0,L:VARPTR(result(0))
UNLINK #1



                                                                                              119

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             CARD()



  Syntax:      <num>=CARD(<num-expression>)



DESCRIPTION:



   Returns lower 16 bits of b. (same as a=b AND (2(HOCH)16-1))



   SEE ALSO:       BYTE(),WORD(),SWAP()



120

     ______________________________________________________________________________________5.4.__C__________



  Keyword:             CASE



 Syntax:        CASE  <num-expression>[,<num-expression>,...]



DESCRIPTION:



  CASE takes a list of expressions to be compared with the expression of the corresponding

SELECT statement. See Example program for SELECT.



  SEE ALSO:       SELECT,DEFAULT,ENDSELECT



                                                                                              121

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             CBRT()



  Syntax:      a=CBRT(x)



DESCRIPTION:



   The CBRT() function returns the cube root of x.  This function cannot fail; every repre-

sentable real value has a representable real cube root.



   SEE ALSO:       SQRT()



122

     ______________________________________________________________________________________5.4.__C__________



  Function:             CEIL()



 Syntax:        <num-result>=CEIL(<num-expression>)



DESCRIPTION:



  Ceiling function: return smallest integral value not less than argument.



  SEE ALSO:       INT()



                                                                                              123

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CHAIN



  Syntax:      CHAIN  <file-name>



DESCRIPTION:



   CHAIN loads and runs another BASIC program.  Global variables will be available with

their current value to the new program, all other variables are erased. If you want to append

another program to the current program (as opposed to erasing the current program and loading

a new program), use the MERGE command instead.



   SEE ALSO:       MERGE,RUN



124

     ______________________________________________________________________________________5.4.__C__________



  Function:             CHR$()



 Syntax:        <string-result>  =  CHR$(<num-expression>)



DESCRIPTION:



  CHR$() returns the character associated with a given ASCII code.

  Character table


       032        048   0      064   @    080   P      096   `    112   p

       033   !    049   1      065   A    081   Q      097   a    113   q

       034   "    050   2      066   B    082   R      098   b    114   r

       035   "#    051   3      067   C    083   S      099   c    115   s

       036   "$    052   4      068   D    084   T      100   d    116   t

       037   "%    053   5      069   E    085   U      101   e    117   u

       038   "&    054   6      070   F    086   V      102   f    118   v

       039   '    055   7      071   G    087   W      103   g    119   w

       040   (    056   8      072   H    088   X      104   h    120   x

       041   )    057   9      073   I    089   Y      105   i    121   y

       042   *    058   :      074   J    090   Z      106   j    122   z

       043   +    059   ;      075   K    091   "$["$      107   k    123   -

       044   ,    060   <      076   L    092   "      108   l    124   _

       045   -    061   =      077   M    093   "$]"$      109   m    125   "

       046   .    062   >      078   N    094   (HOCH)      110   n    126   "

       047   /    063   ?      079   O    095   "_      111   o    127


  Control codes


       00  NUL          08  BS    --  Backspace    16  DLE

       01  SOH          09  HT    --  horizontal  TAB    17  DC1   --  XON

       02  STX          10  LF    --  Newline    18  DC2

       03  ETX          11  VT    19  DC3   --  XOFF

       04  EOT          12  FF    --  Form  feed    20  DC4

       05  ENQ          13  CR    --  Carriage  Return   21  NAK

       06  ACK          14  SO    22  SYN

       07  BEL   --  Bell   15  SI    23  ETB



       24  CAN          32  SP   --  Space

       25  EM        127  DEL  --  Delete

       26  SUB



                                                                                              125

5.__X11-Basic_command_reference___________________________________________________________________



       27  ESC28  FS

       29  GS

       30  RT

       31  US



EXAMPLE:


        PRINT CHR$(34);"Hello World !";CHR$(34)
        Result: "Hello World !"



   SEE ALSO:       ASC()



126

     ______________________________________________________________________________________5.4.__C__________



  Function:             CINT()



 Syntax:        <num-result>=CINT(<num-expression>)



DESCRIPTION:



  CINT() returns the rounded absolute value of its argument preoxed with the sign of its

argument.



EXAMPLE:


PRINT CINT(1.4), CINT(-1.7)
         Result: 2, -2



   SEE ALSO:       INT(),FRAC(),TRUNC(),ROUND()



                                                                                              127

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CIRCLE



  Syntax:      CIRCLE  <x>,<y>,<r>[,<w1>,<w2>]



DESCRIPTION:



   Draw a circle with actual color (and ollpattern). The x- and y-coordinates of the center and

the radius of the circle in screen coordinates. Optionally a starting angle <w1> and stop angle

<w2> can be passed to draw a circular arc.



EXAMPLE:


         CIRCLE 100,100,50



   SEE ALSO:       ELLIPSE,COLOR,DEFFILL,PCIRCLE



128

     ______________________________________________________________________________________5.4.__C__________



  Command:             CLEAR



 Syntax:        CLEAR



DESCRIPTION:



  Clear all variables and arrays as if they were never used before.



  SEE ALSO:       NEW



                                                                                              129

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CLEARW



  Syntax:      CLEARW  [<num>]



DESCRIPTION:



   Clear graphic window.  If a number is given, clear window with the number given.  The

Window is olled with the backgound color given by the X-server.



   SEE ALSO:       CLOSEW



130

     ______________________________________________________________________________________5.4.__C__________



  Command:             CLIP



 Syntax:        CLIP  x,y,w,h[,ox,oy]



DESCRIPTION:



  This command provide the 'Clipping' function, ie. the limiting of graphic display within a

specioed rectangular screen area. The command CLIP x,y,w,h deones the clipping rectangle

starting at upper left coordinates x,y and extends w wide and h high. The optional additional

command parameters ox,oy make it possible to redeone the origin of the graphic display.



  SEE ALSO:



                                                                                              131

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CLOSE



  Syntax:      CLOSE  [[#]<num-expression>[,[#]<num-expression>,...]]



DESCRIPTION:



   This statement is used to CLOSE one or more OPEN oles or other devices. The parameter

expression indicates a device number or ole number. If no ole or device numbers are declared

all OPEN devices will be closed.

   COMMENT:

   All oles should be closed before leaving a program to insure that data will not be lost or

destroyed. If a program exit is through END or QUIT, all oles will be closed. If a program is

stopped with the STOP command, alle open oles remain open.



EXAMPLE:


         CLOSE #1,#2
         CLOSE



   SEE ALSO:       OPEN,LINK



132

     ______________________________________________________________________________________5.4.__C__________



  Command:             CLOSEW



 Syntax:        CLOSEW  [<num>]



DESCRIPTION:



  Close graphic window (make it disappear from the screen).  If a number is given, closes

window with the number given.  The Window will again be opened, when the next graphic

command is executed.



  SEE ALSO:       CLEARW



                                                                                              133

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CLR



  Syntax:      CLR  <var>[,<var>,...]



DESCRIPTION:



   Sets specioed variables to 0 or "".



134

     ______________________________________________________________________________________5.4.__C__________



  Command:             CLS



 Syntax:        CLS



DESCRIPTION:


Clear text screen and move cursor home (upper left corner).



  SEE ALSO:       PRINT



                                                                                              135

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             COLOR



  Syntax:      COLOR  <foreground-color>[,<background-color>]



DESCRIPTION:



   COLOR sets the foreground color (and optionally the background color) for graphic output

into the graphic window. The color values are dependant of the color depth of the Screen/X-

Server. Usually the COLOR statement is used together with the GET_COLOR() function, so

arbitrary colors may be used.



EXAMPLE:


yellow=GET_COLOR(65535,65535,0)
blue=GET_COLOR(0,0,65535)
COLOR yellow,blue



   SEE ALSO:       GET"_COLOR,LINE



136

     ______________________________________________________________________________________5.4.__C__________



  Function:             COMBIN()



 Syntax:        <num-result>=COMBIN(<n>,<k>)



DESCRIPTION:



  Calculates the number of combinations of <n> elements to the <k>th class without repeti-

tions. Deoned as z=n!/((n-k)!*k!).



                                                                                              137

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             COMPRESS$()



  Syntax:      c$=COMPRESS$(a$)



DESCRIPTION:



   Performs a losless compression on the String a$. The algorithm uses run length encoding

in combination with the Burrows-Wheeler transform. The result is a better compression than

p.ex. the algorithm used by gzip. At the moment the COMPRESS$() function is identical to

following combination: b$=ARIE$(RLE$(MTFE$(BWTE$(RLE$(a$)))))



   SEE ALSO:       UNCOMPRESS"$(),BWTE"$(),RLE"$(),MTFE"$()



138

     ______________________________________________________________________________________5.4.__C__________



  Command:             CONNECT



 Syntax:        CONNECT  #n,server$,port%



DESCRIPTION:



  Initiate a connection on a socket.

  The ole number #n must refer to a socket.  If the socket is of type "U" then the server$

address is the address to which packets are sent by default, and the only address from which

packets are received.  If the socket is of type "S","A","C", this call attempts to make a con-

nection to another socket. The other socket is specioed by server$, which is an address in the

communications space of the socket.

  Generally, connection-based protocol sockets may success fully connect only once; connec-

tionless protocol sockets may use connect multiple times to change their associa tion.



  SEE ALSO:       OPEN,CLOSE,SEND,RECEIVE



                                                                                              139

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CONTINUE



  Syntax:      CONT

               CONTINUE



DESCRIPTION:



   This command has two dioeerent use cases. If used in direct mode, it continues the execution

of a program after interruption (e.g. with STOP).

   If used inside a SELECT/ENDSELECT block, it branches to the line following the next

CASE or DEFAULT directive.  If no CASE or DEFAULT statement is found, it branches to

ENDSELECT.



EXAMPLE:


INPUT a
SELECT a
CASE 1
  PRINT 1
  CONTINUE
CASE 2
  PRINT "1 or 2"
CASE 3
  PRINT 3
DEFAULT
  PRINT "default"
ENDSELECT



   SEE ALSO:       STOP,SELECT,CASE,DEFAULT,BREAK



140

     ______________________________________________________________________________________5.4.__C__________



  Command:             COPYAREA



 Syntax:        COPYAREA  x,y,w,h,xd,yd



DESCRIPTION:



  Copies a rectangular screen sections given by x,y,w,h to a destination at xd,yd.

  x,y top left corner of source rectangle w,h width & height " " " xd,yd destination x and y

coordinates

  This command is very fast compared to the GET and PUT commands because the whole

data transfer takes place on the X-client.



  SEE ALSO:       GET,PUT,GRAPHMODE



                                                                                              141

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             COS()



  Syntax:      <num-result>=COS(<num-expression>)



DESCRIPTION:



   Returns the Cosine of the expression in radians.



   SEE ALSO:       SIN(),ASIN()



EXAMPLE:


PRINT COS(0)      Result: 1



                          _______________________*______________________



   Function:             COSH()



  Syntax:      <num-result>=COSH(<num-expression>)



DESCRIPTION:



   The cosh() function returns the hyperbolic cosine of x, which is deoned mathematically as

(exp(x)+exp(-x))/2



   SEE ALSO:       COS(),ACOSH(),EXP()


                          _______________________*______________________



   Function:             CRC()



  Syntax:      <num-result>=CRC(t$[,oc])



142

     ______________________________________________________________________________________5.4.__C__________



DESCRIPTION:



  Calculates a 32 bit checksum on the given String.  If oc is passed, the checksum will be

updated with the given String.



  SEE ALSO:       LEN()



                                                                                              143

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             CRSCOL,   CRSLIN



  Syntax:      CRSCOL

               CRSLIN



DESCRIPTION:



   Returns current cursor line and column.



   SEE ALSO:       PRINT  AT()



144

     ______________________________________________________________________________________5.4.__C__________



  Variable:             CTIMER



 Syntax:        CTIMER



DESCRIPTION:



  Returns CPU-Clock in seconds. This timer returns the amount of time this application was

running. It is most usefull for benchmark applications on multi tasking environments.



  SEE ALSO:       TIMER,STIMER



                                                                                              145

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             CURVE



  Syntax:      CURVE  x0,y0,x1,y1,x2,y2,x3,y3



DESCRIPTION:



   The CURVE command draws a qubic bezier curve.  The bezier-Curve starts at x0,y0 and

ends at x3,y3. The curve at x0,y0 is at a tangent with a line from x0,y0 to x1,y1; and at x3,y3

is at a tangent with a line between x3,y3 and x2,y2.



   SEE ALSO:       LINE,POLYLINE



146

     ______________________________________________________________________________________5.4.__C__________



  Function:             CVA()



 Syntax:        <array-result>=CVA(<string-expression>)



DESCRIPTION:



  Returns array reconstructed from the string. This function is the compliment of MKA$().



EXAMPLE:


a()=CVA(t$)



   SEE ALSO:       ASC(),CVF(),CVL(),MKA"$()



                                                                                              147

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             CVD()



  Syntax:      <num-result>=CVD(<string-expression>)



DESCRIPTION:



   Returns the binary double value of the orst 8 characters of string.  This function is the

compliment of MKD$().



   SEE ALSO:       ASC(),CVF(),CVL(),MKD"$()



                          _______________________*______________________



   Function:             CVF()



  Syntax:      <num-result>=CVF(<string-expression>)



DESCRIPTION:



   Returns the binary AEoat value of the orst 4 characters of string. This function is the compli-

ment of MKF$().



   SEE ALSO:       ASC(),CVD(),CVL(),MKF"$()



                          _______________________*______________________



   Function:             CVI()



  Syntax:      <num-result>=CVI(<string-expression>)



DESCRIPTION:



148

     ______________________________________________________________________________________5.4.__C__________



  Returns the binary integer value of the orst 2 characters of string.  This function is the

compliment of MKI$().  Null string returns 0, One character strings will return the ASCII

value.



  SEE ALSO:       ASC(),CVF(),CVL(),MKI"$()


                           ______________________*_______________________



  Function:             CVL()



 Syntax:        <num-result>=CVL(<string-expression>)



DESCRIPTION:



  Returns the binary long integer value of the orst 4 characters of string. This function is the

compliment of MKL$(). Null string returns 0.



  SEE ALSO:       ASC(),CVF(),CVI(),MKL"$()


                           ______________________*_______________________



  Function:             CVS()



 Syntax:        <num-result>=CVS(<string-expression>)



DESCRIPTION:



  Returns the binary AEoat value of the orst 4 characters of string. This function is the compli-

ment of MKS$().



  SEE ALSO:       CVF(),MKS"$()



                                                                                              149

5.__X11-Basic_command_reference___________________________________________________________________



5.5.    D



150

     ______________________________________________________________________________________5.5.__D__________



  Command:             DATA



 Syntax:        DATA  [<const>[,<const>,  ...]]



DESCRIPTION:



  The DATA statement is used to hold information that may be read into variables using the

READ statement. DATA items are a list of string or numeric constants separated by commas

and may appear anywhere in a program. No comment statement may follow the DATA state-

ment on the same line. Items are read in the order they appear in a program. RESTORE will

set the pointer back to the beginning of the orst DATA statement.

  Alphanumeric string information in a DATA statement need not be enclosed in quotes if the

orst character is not a number, math sign or decimal point.  Leading spaces will be ignored

(unless in quotes). DATA statements can be included anywhere within a program and will be

read in order.



  SEE ALSO:       READ,RESTORE



                                                                                              151

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             DATE$



  Syntax:      DATE$



DESCRIPTION:



   Returns the system date. The format is DD.MM.YYYY.



   SEE ALSO:       TIME"$



152

     ______________________________________________________________________________________5.5.__D__________



  Command:             DEC



 Syntax:        DEC  <num-variable>



DESCRIPTION:



  Decrement Variable a. The result is a=a-1.



  SEE ALSO:       INC



                                                                                              153

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             DECRYPT$()



  Syntax:      t$=DECRYPT$(message$,key$)



DESCRIPTION:



   Decrypts a message, which has been encrypted with ENCRYPT$() before.



   SEE ALSO:       ENCRYPT"$()



154

     ______________________________________________________________________________________5.5.__D__________



  Keyword:             DEFAULT



 Syntax:        SELECT  ...  DEFAULT  ...  ENDSELECT



DESCRIPTION:



  See SELECT.



  SEE ALSO:       SELECT



                                                                                              155

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             DEFFILL



  Syntax:      DEFFILL  <col>,<style>,<pattern>



DESCRIPTION:



   Sets oll colour and pattern.  <col> - not used at the moment <style> - 0=empty, 1=olled,

2=dots, 3=lines, 4=user (not used) <pattern> - 24 dotted patterns and 12 lined can by chosen.



   SEE ALSO:       DEFLINE,DEFTEXT



156

     ______________________________________________________________________________________5.5.__D__________



  Command:             DEFFN



 Syntax:        DEFFN  <function-name>[$][(<variable  list>)]=<expression>



DESCRIPTION:



  This statement allows the user to deone a single line inline function that can thereafter be

called by @name. This is a handy way of adding functions not provided in the language. The

expression may be a numeric or string expression and must match the type the function name

would assume if it was a variable name. The name must adhere to variable name syntax.



EXAMPLES:


DEFFN av(x,y)=SQR(x^2+y^2)
a=@av(b,c)    ! call av
DEFFN add$(a$,b$)=a$+b$



   SEE ALSO:       FUNCTION,GOSUB



                                                                                              157

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             DEFLINE



  Syntax:      DEFLINE  <style>,<thickness>[,<begin_s>,<end_s>]



DESCRIPTION:



   Sets line style, width and type of line start and end. <style>  determines the style of line:

1 Solid line 2 Long dashed line 3 Dotted 4 Dot-dashed 5 Dashed 6 Dash dot dot ..  7 User

deoned (not used) <thickness>  sets line width in pixels. <begin_s>,<end_s>  The start and

end symbols are deoned by the last parameter, and can be: 0 Square 1 Arrow 2 Round



   SEE ALSO:       LINE,DEFFILL



158

     ______________________________________________________________________________________5.5.__D__________



  Command:             DEFMARK



 Syntax:        DEFMARK  <color>,<style>,<size>



DESCRIPTION:



  Sets colour, type and size of the corner points to be marked using the command POLY-

MARK. The color value will be ignored. The color of the points can be set with the COLOR

command.  The following types are possible: 0=point 1=dot (circle) 2=plus sign 3=asterisk

4=square 5=cross 6=hash 8=olled circle 9=olled square



  SEE ALSO:       POLYMARK,DEFLINE,COLOR



                                                                                              159

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             DEFMOUSE



  Syntax:      DEFMOUSE  <style>



DESCRIPTION:



   Chooses a pre-deoned mouse form. The following mouse forms are available :

   0=arrow 1=expanded (rounded) X 2=busy bee 3=hand, pointing onger 4=open hand 5=thin

crosswire 6=thick crosswire 7=bordered crosswire and about 100 other X-Window specioc

symbols.



   SEE ALSO:       HIDEM,SHOWM



160

     ______________________________________________________________________________________5.5.__D__________



  Command:             DEFTEXT



 Syntax:        DEFTEXT  <colour>,<attr>,<angle>,<height>,<width>



DESCRIPTION:



  Deones the colour,style,rotation and size of text to be printed using the LTEXT command.

  <colour> not used.  <attr> text style - 0=normal 1=bold 2=light 4=italic 8=underlined

16=outlined (can be combined).  <angle> rotation in degrees <width> and <height> size of

text in % (100% correspondt to 100 Pixel font)



  SEE ALSO:       LTEXT,TEXT



                                                                                              161

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             DEG()



  Syntax:      <num-expression>=DEG(<num-expression_x>)



DESCRIPTION:



   Converts x from radians to degrees.



   SEE ALSO:       RAD()



162

     ______________________________________________________________________________________5.5.__D__________



  Command:             DELAY



 Syntax:        DELAY  <num-of-seconds>



DESCRIPTION:



  Same as PAUSE. Delays program execution by <num-of-seconds> seconds.



  SEE ALSO:       PAUSE



                                                                                              163

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             DET()



  Syntax:      d=DET(a())



DESCRIPTION:



   Calculates the determinant of a (square) matrix a(). (This command is not yet implemented

into X11-Basic V.1.19.)



   SEE ALSO:       SOLVE(),INV()



164

     ______________________________________________________________________________________5.5.__D__________



  Function:             DEVICE()



 Syntax:        d=DEVICE(filename$)



DESCRIPTION:



  Returns the device id corresponding to a ole.



                                                                                              165

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             DIM



  Syntax:      DIM  <arrayname>(<indices>)[,<arrayname>(<indices>),...]



DESCRIPTION:



   Sets the dimensions of an array or string array. Arrays can be re-dimensioned any time.



EXAMPLES:


DIM a(10)
DIM b(100,100)
DIM c$(20,30,405,6)



   SEE ALSO:       ERASE,DIM?()


                          _______________________*______________________



   Function:             DIM?()



  Syntax:      <num-result>=DIM?(<array-name>())



DESCRIPTION:



   Determines the number of elements in an array. Note - arrays have an element '0'.



EXAMPLE:


DIM a(10,10)
PRINT DIM?(A())      Result: 121



   SEE ALSO:       DIM



166

     ______________________________________________________________________________________5.5.__D__________



  Command:             DIV



 Syntax:        DIV  <num-var>,<num-expression>



DESCRIPTION:



  Divides the value of var by n. As var=var/n but faster.



  SEE ALSO:       ADD,MUL,SUB


                           ______________________*_______________________



  Function:             DIV()



 Syntax:        <num-result>=DIV(<num-expression>,<num-expression>)



DESCRIPTION:



  Divides the orst value by second.



  SEE ALSO:       ADD(),MUL(),SUB()



                                                                                              167

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             DO



  Syntax:      DO  ...  LOOP



DESCRIPTION:



   DO implements an unconditional loop. The lines between the DO line and the LOOP line

form the loop body. The unconditional DO...LOOP block simply loops and the only way out

is by EXIT IF or BREAK (or GOTO).



   SEE ALSO:       LOOP,EXIT  IF,BREAK,WHILE



EXAMPLE:


         DO
              INPUT a$
              EXIT IF a$=""
         LOOP



168

     ______________________________________________________________________________________5.5.__D__________



  Keyword:             DOWNTO



 Syntax:        FOR  ...  DOWNTO  ...



DESCRIPTION:



  Used within a FOR..NEXT loop as a counter.  Instead of using STEP -1, the command

DOWNTO is used, however STEP is not possible with DOWNTO. eg: FOR c=100 DOWNTO

1 is the same as FOR c=100 TO 1 STEP -1



  SEE ALSO:       FOR,TO,NEXT,STEP



                                                                                              169

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             DPEEK()



  Syntax:      <num-result>=DPEEK(<adr>)



DESCRIPTION:



   Reads 2 bytes from address <adr> (a word).



   SEE ALSO:       PEEK(),LPEEK(),DPOKE


                          _______________________*______________________



   Command:             DPOKE



  Syntax:      DPOKE  <adr>,<num-expression>



DESCRIPTION:



   Writes <num-expression> as a 2 byte word to address <adr>.



   SEE ALSO:       PEEK(),LPEEK(),POKE,DPEEK()



170

     ______________________________________________________________________________________5.5.__D__________



  Command:             DRAW



 Syntax:        DRAW  [<x1>,<y1>][TO  <x2>,<y2>][TO  <x3>,<y3>][TO  ...]



DESCRIPTION:



  Draws points and connects two or more points with straight lines. DRAW x,y is the same

as PLOT x,y. DRAW TO x,y connects the point to the last set point (set by PLOT, LINE or

DRAW).



  SEE ALSO:       LINE,PLOT



                                                                                              171

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             DUMP



  Syntax:      DUMM  [t$]



DESCRIPTION:



   Query Information about stored Variables, names:

   DUMP  Lists all used variable names DUMP "@"  list of functions and procedures

DUMP ":"  list of all labels DUMP "#"  list of open Files DUMP "K"  list of X11-Basic

commands DUMP "F"  list of X11-Basic functions



   SEE ALSO:       LIST,PLIST,HELP



172

     ______________________________________________________________________________________5.6.__E__________



5.6.    E



                                                                                              173

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ECHO



  Syntax:      ECHO  ON

               ECHO  OFF



DESCRIPTION:



   Switches the trace function on or ooe. This causes each command to be listed on the stdout.



   SEE ALSO:       TRON,TROFF



174

     ______________________________________________________________________________________5.6.__E__________



  Command:             EDIT



 Syntax:        EDIT



DESCRIPTION:



  EDIT invokes the standart editor (given by the environment variable $(EDITOR) to edit the

BASIC program in memory.

  The command invokes the following actions: - SAVE "name.  " writes the BASIC-program

into a temporary ole, - calls the editor '$EDITOR', waits until editor is closed - NEW clears

internal values - LOAD "name.  " reads the BASIC-program from the temporary ole.

  You may want to SAVE the ole before using the EDIT command if the ole has not yet

been saved in order to choose a name at that occasion. The default name is "name.   ". This

command requires that the editor installed on your system does not detach itself from the

calling process or EDIT will not recognize any changes (in that case, use LOAD to load the

modioed source code).



  SEE ALSO:       LOAD,SAVE



                                                                                              175

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ELLIPSE



  Syntax:      ELLIPSE  <x>,<y>,<a>,<b>  [,<w0>,<w1>]



DESCRIPTION:



   Draws an ellipse at <x>,<y>, having <a> as horizontal radius and <b> vertical radius The

optional angles <w0> and <w1> give start and end angles in degrees, to create an elliptical

arc.



   SEE ALSO:       PELLIPSE,CIRCLE



176

     ______________________________________________________________________________________5.6.__E__________



  Command:             ELSE,   ELSE   IF



 Syntax:        ELSE

                ELSE  IF  <expression>



DESCRIPTION:



  ELSE IF <expression> introduces another condition block and the unqualioed ELSE intro-

duces the default condition block in a multi-line IF statement. SEE ALSO:       IF,ENDIF



EXAMPLE:


        IF (N=0)
            PRINT "0"
        ELSE IF (N=1)
            PRINT "1"
        ELSE
            PRINT "Out of range"
        ENDIF



                                                                                              177

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             ENCRYPT$()



  Syntax:      e$=ENCRYPT$(t$,key$)



DESCRIPTION:


This Function will encrypt a String with a given key. Internally the blowosh algorithm is used,

if this was compiled into X11-Basic. Since strong encryption is not allowed in some contries

(including the US), this option is not activated by default. Instead a very weak obfuscation is

used. Note that in this case this function is not a proper encryption routine, and is only suitable

for hiding strings.

   The encrypted message can be decrypted again using DECRYPT$() and the same key.



   SEE ALSO:       COMPRESS"$(),DECRYPT"$()



178

     ______________________________________________________________________________________5.6.__E__________



  Command:             END



 Syntax:        END



DESCRIPTION:



  END terminates program execution. The interpreter switches to interactive mode.



  SEE ALSO:       STOP,QUIT



                                                                                              179

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ENDFUNCTION



  Syntax:      ENDFUNCTION



DESCRIPTION:



   Terminates a user deoned function block.  The function itself must return a value with a

RETURN command.



   SEE ALSO:       FUNCTION,RETURN



180

     ______________________________________________________________________________________5.6.__E__________



  Command:             ENDIF



 Syntax:        ENDIF



DESCRIPTION:



  ENDIF terminates a multi-line IF block.



  SEE ALSO:       IF,ELSE,ELSE  IF



                                                                                              181

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ENDSELECT



  Syntax:      ENDSELECT



DESCRIPTION:



   Terminates a SELECT block.



   SEE ALSO:       SELECT,DEFAULT,CASE



182

     ______________________________________________________________________________________5.6.__E__________



  Command:             ENV$()



 Syntax:        <string-result>=ENV$(<env-variable>)



DESCRIPTION:



  ENV$() returns the current value of the specioed "environment variable".  Environment

variables are string variables maintained by the operating system.  These variables typically

are used to save conoguration information. Use the SETENV command to set the values of

environment variables.



  SEE ALSO:       SETENV



EXAMPLE:


         PRINT ENV$("USER")
         Result: hoffmann



                                                                                              183

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             EOF()



  Syntax:      <boolean-result>=EOF(#<dev-number>)



DESCRIPTION:



   EOF() checks the end-of-ole status of a ole previously opened for reading by the OPEN

command. It returns -1 (TRUE) if the end of ole has been reached, otherwise null (FALSE).



   SEE ALSO:       OPEN



EXAMPLE:


         OPEN "I",#1,"filename"
         WHILE NOT EOF(#1)
              LINEINPUT #1,a$
         WEND
         CLOSE #1



184

     ______________________________________________________________________________________5.6.__E__________



  Operator:             EQV



 Syntax:        <num-result>=<num-expression>  EQV  <num-expression>



DESCRIPTION:



  The operator EQV (equivalence) produces a TRUE result only if the arguments of both are

either TRUE or both FALSE. (same as NOT(x XOR y)) and ((A IMP B) AND (B IMP A)).

  table: A _ B _ A EQV B ++ -1 _ -1 _ -1 -1 _ 0 _ 0 0 _ -1 _ 0 0 _ 0 _ -1



  SEE ALSO:       TRUE,FALSE,NOT,XOR,IMP


                           ______________________*_______________________



  Function:             EQV()



 Syntax:        <num-result>=EQV(<num-expression>,<num-expression>)



DESCRIPTION:



  Binary Function of logical operator EQV.



  SEE ALSO:       EQV



EXAMPLE:


            PRINT BIN$(EQV(15,6),4)
    Result:  0110



                                                                                              185

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ERASE



  Syntax:      ERASE  <array>()[,<array>(),<variable>...]



DESCRIPTION:



   un-DIMs an array and removes it from the internal variables. Or remove a variable out of

the memory.  (This command need never be used in X11-Basic.  Dont use it.  An array can

easily redimensioned with another DIM statement.)



   SEE ALSO:       DIM,CLR



186

     ______________________________________________________________________________________5.6.__E__________



  Variable:             ERR



 Syntax:        ERR



DESCRIPTION:



  Returns the error code of latest occurred error.



  SEE ALSO:       ERROR,ERR"$()



                                                                                              187

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             ERR$()



  Syntax:      <string-result>=ERR$(<error-nr)



DESCRIPTION:



   Returns, as a string containing the X11-Basic error mesage which belongs to the error num-

ber.



EXAMPLE:



PRINT "X11-Basic Error messages:"
FOR i=0 TO 255
  PRINT i,ERR$(i)
NEXT i



   SEE ALSO:       ERR



188

     ______________________________________________________________________________________5.6.__E__________



  Command:             ERROR



 Syntax:        ERROR  <error-number>



DESCRIPTION:



  ERROR simulates an error, i.e., displays the message appropriate for a given error code or

calls the error handler if one was installed via the ON ERROR command. This command is

helpful in writing ON ERROR GOSUB routines that can identify errors for special treatment

and then ERROR ERR (i.e. default handling) for all others.



EXAMPLE:



> ERROR 245
Line -1: * Timeout



   SEE ALSO:       ON  ERROR  GOSUB,ERR



                                                                                              189

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             EVAL



  Syntax:      EVAL  a$



DESCRIPTION:



   Evaluate or execute X11-Basic command, which is in a$.



EXAMPLE:



b$="a=5"
a$="print a"
EVAL a$
EVAL b$
EVAL a$



   SEE ALSO:       EVAL(),&



190

     ______________________________________________________________________________________5.6.__E__________



  Function:             EVAL()



 Syntax:        a=EVAL(b$)



DESCRIPTION:



  Evaluate expression, which is in b$.



EXAMPLE:



b$="sin(0.5*exp(0.001))"
result=EVAL(b$)



   SEE ALSO:       EVAL,&



                                                                                              191

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             EVEN()



  Syntax:      <bool-result>=EVEN(<num-expression>)



DESCRIPTION:



   Returns true (-1) if the number is even, else false (0).



   SEE ALSO:       ODD()



192

     ______________________________________________________________________________________5.6.__E__________



  Command:             EVENT



 Syntax:        EVENT  typ,[x,y,xroot,yroot,s,k,ks,t$]



DESCRIPTION:



  Waits until any of the KEYEVENT, MOUSEEVENT, MOTIONEVENT occurs.

  typ determines whichof the events have occured:

  typ=6  motionevent typ=14  MOUSEEVENT typ=2  keyevent

  x,y  Mouse position relative to window xroot,yroot  Mouse position relative to screen

s  State of the Alt, Caps, Shift keys t$  Character of pressed key



  SEE ALSO:       KEYEVENT,MOUSEEVENT,MOTIONEVENT



                                                                                              193

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             EVERY



  Syntax:      EVERY  <seconds>,  <procedure>

               EVERY  CONT

               EVERY  STOP



DESCRIPTION:



   The command EVERY causes the procedure to be called every <seconds> seconds. Using

EVERY STOP, the calling of a procedure can be prevented. With EVERY CONT this is again

allowed.



   SEE ALSO:       AFTER



194

     ______________________________________________________________________________________5.6.__E__________



  Command:             EXEC



 Syntax:        EXEC  <adr>[,<parameter-list>]



DESCRIPTION:



  Calls a machine code or C subroutine at address <adr> without return value.  Optinal pa-

rameters are passed on the stack. (like in C). The default parameter-type is (4-Byte) integer. If

you want to specify other types, please use preoxes:

  D:  double (8-Bytes) F:  AEoat (4-Bytes) L:  long int



  SEE ALSO:       CALL,EXEC()


                           ______________________*_______________________



  Function:             EXEC()



 Syntax:        <int-return>=EXEC(<adr>[,<parameter-list>])



DESCRIPTION:



  Calls a machine code or C subroutine at address <adr> and returns an integer value. Optinal

parameters are passed on the stack. (like in C). The default parameter-type is (4-Byte) integer.

If you want to specify other types, please use preoxes:

  D:  double (8-Bytes) F:  AEoat (4-Bytes) L:  long int



  SEE ALSO:       CALL,EXEC



                                                                                              195

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             EXIST()



  Syntax:      <bool-result>=EXIST(<filename>)



DESCRIPTION:



   Returns TRUE (-1) if the ole is present on a ole system.



   SEE ALSO:       OPEN



196

     ______________________________________________________________________________________5.6.__E__________



  Command:             EXIT   IF



 Syntax:        EXIT  IF  <expression>



DESCRIPTION:



  The innermost loop will be exited if the expression is true.  WHILE, REPEAT, DO and

FOR loops can be aborted prematurely with the EXIT command.  EXIT leaves the current

(innermost) loop immediately.  EXIT IF leaves the current loop only if the expression after

EXIT IF is not FALSE (not null).



  SEE ALSO:       DO,WHILE,FOR,REPEAT,BREAK,IF



                                                                                              197

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             EXP()



  Syntax:      <num-result>  =  EXP(<num-expression>)



DESCRIPTION:



   EXP() returns the exponential value of its argument (e to the specioed power).



   SEE ALSO:       Operator  ^



EXAMPLE:


        PRINT EXP(1)
        Result: 2.718281828459



198

     ______________________________________________________________________________________5.6.__E__________



  Function:             EXPM1()



 Syntax:        <num-result>  =  EXPM1(<num-expression>)



DESCRIPTION:



  Returns a value equivalent to `exp(x)-1'. It is computed in a way that is accurate even if the

value of x is near zeroa case where `exp(x)-1' would be inaccurate due to subtraction of two

numbers that are nearly equal.



  SEE ALSO:       LOG1P(),EXP()



EXAMPLE:


        PRINT EXPM1(1)
        Result: 1.718281828459



                                                                                              199

5.__X11-Basic_command_reference___________________________________________________________________



5.7.    F



200

     ______________________________________________________________________________________5.7.__F__________



  Function:             FACT()



 Syntax:        <num-result>=FACT(<num-expression>)



DESCRIPTION:



  Calculates the factorial (n!)



                                                                                              201

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             FALSE



  Syntax:      FALSE



DESCRIPTION:



   Constant 0.  This is simply another way of expressing the value of a condition when it is

false and is equal to zero.



   SEE ALSO:       TRUE



202

     ______________________________________________________________________________________5.7.__F__________



  Command:             FFT



 Syntax:        FFT  a(),



DESCRIPTION:



  FFT a(),i $[$,...$]$  Fouriertransformation. i=-1 Rcktransformation Dim?(a()) muss Zweier-

potenz sein. SEE ALSO:



                                                                                              203

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             FILEEVENT$



  Syntax:      t$=FILEEVENT$



DESCRIPTION:



   Returns a string with event information on watched oles and directories.  If the string is

empty, no events are pending.  The events consist of 3 charackters followed by a blank and

optionally followed by a olename.  The orst three charackters have the folllowing meaning:

1st: "d" means: the ole is a directory 2nd: "X" created, "O" OPENed, "C" closed, "M" moved,

"D" deleted 3rd: "r" read, "w" write, "a" attributes were changed

   When monitoring a directory, the events above can occur for oles in the directory, in which

case the name oeld in the returned string identioes the name of the ole within the directory.



   SEE ALSO:       WATCH



EXAMPLE:


WATCH "/tmp"
DO
  a$=FILEEVENT$
  IF LEN(a$)
     PRINT a$
  ENDIF
LOOP



204

     ______________________________________________________________________________________5.7.__F__________



  Command:             FILESELECT



 Syntax:        FILESELECT  <title$>,<path$>,<default$>,<string-variable>



DESCRIPTION:



  Opens a oleselect box. <title$> gives a short title to be placed in the oleselect box. Such as

'Select a .DOC ole to open...'.

  <path$> path - if none specioed then the default path is assumed.  The pathname should

include a complete path speciocation including a drive letter (except for UNIX ole system),

colon, path, and olemask. The olemask may (and usually does include wildcard characters).

  <default$> contains the name of the ole to apppear in the selection line. ("" for no default).

  FILESELECT returns the selected olename (including path) in <string-variable>. If CAN-

CEL is selected an empty string is returned.



  SEE ALSO:       XLOAD,XRUN,FSEL"_INPUT()



EXAMPLE:


FILESELECT "LOAD File","."*.dat","input.dat",file$



                                                                                              205

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             FILL



  Syntax:      FILL  x,y[,bc]



DESCRIPTION:



   Fills a bordered area with a color commencing at the co-ordinates 'x,y'. If a border color

(bc) is specioed, the oll stops at boundaries with this color. If no border color is given, the oll

will stop at any oter color than the one of the starting coordinate. The oll color can be chosen

with the command COLOR.



   SEE ALSO:       COLOR



206

     ______________________________________________________________________________________5.7.__F__________



  FIT a(),a(),???,???$[$,???,???,???,???,???,???$]$ FIT_LINEAR x(),y()$[$,$[$xerr(),$]$yerr()$]$,n,a,b$[$,siga,sigb,chi2,q$]$

 Lineare Regression optional mit Fehlerbalken in beide Richtungen. n=Anzahl der Fitpunkte,

f(x)=a+b*x



                                                                                              207

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             FIX()



  Syntax:      <num-result>=FIX(<num-expression-x>)



DESCRIPTION:



   Returns the integer of x after it has been rounded.  Same as INT(x) for positive numbers

but for negative numbers INT(-1.99)=-2 AND FIX(-1.99)=1. FIX is identical to the function

TRUNC and complements FRAC.



   SEE ALSO:       INT(),TRUNC(),FRAC(),ROUND()



208

     ______________________________________________________________________________________5.7.__F__________



  Function:             FLOOR()



 Syntax:        <num-result>=FLOOR(<num-expression-x>)



DESCRIPTION:



  Round x down to the nearest integer.



  SEE ALSO:       INT(),FIX()



                                                                                              209

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             FLUSH



  Syntax:      FLUSH  [#<device-name>]



DESCRIPTION:



   Flushes the output to the ole or console. Usually a Line is printed when the newline charac-

ter is encountered. To enforce output of everything which has been printed so far use FLUSH.



   SEE ALSO:       PRINT



210

     ______________________________________________________________________________________5.7.__F__________



  Command:             FOR



 Syntax:        FOR  <variable>  =  <start-expression>  TO  <target-expression>  [STEP  <increment-expression>]

                FOR  <variable>  =  <start-expression>  DOWNTO  <target-expression>  [STEP  <increment-expression>]



DESCRIPTION:



  FOR initiates a FOR...NEXT loop with the specioed <variable> initially set to <start-

expression> and incrementing in <increment> steps (default is 1).  The statements between

FOR and NEXT are repeated until the variable value reaches or steps over <target-expression>.



  SEE ALSO:       NEXT



EXAMPLE:


FOR n=2 TO 0 STEP -1
           PRINT n,
         NEXT n
         RESULT: 2  1  0



                                                                                              211

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             FORK()



  Syntax:      <int-result>=FORK()



DESCRIPTION:



   FORK() creates a child process of the running task (usually the X11-Basic interpreter with

the Basic program) that dioeers from the parent process only in its PID and PPID, and in the

fact that resource utilizations are set to 0.

   On success, the PID of the child process is returned in the parent's thread of execution,

and a 0 is returned in the child's thread of execution. On failure, a -1 will be returned in the

parent's context, no child process will be created.



EXAMPLE:


a=FORK()
IF a=-1
  PRINT "error"
  QUIT
ELSE IF a=0
  PRINT "I am child"
ELSE
  PRINT "I am parent. My child is PID=";a
ENDIF



212

     ______________________________________________________________________________________5.7.__F__________



  Function:             FORM_ALERT()



 Syntax:        <num-result>=FORM_ALERT(<default-button>,<string$>)



DESCRIPTION:



  Creates an alert box. button = number of the default button (0= none). string$ = string deon-

ing the message in the alert. Note that the square brackets are part of the string: $[$i$]$$[$Message$]$$[$Buttons$]$

where i = the required alert symbol - see ALERT. FORM_ALERT returns the number of the

selected Button.



  SEE ALSO:       ALERT



EXAMPLE:


"FORM_ALERT(1,"[0][This is my message!][OK]")



                                                                                              213

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             FORM_CENTER()



  Syntax:      <num-result>=FORM_CENTER(tree,x,y,w,h)



DESCRIPTION:



   Centers the tree, and returns its coordinates. INPUT: tree - address of the object tree. OUT-

PUTS: x,y coordinates of top left corner w,h form width and height. returns a reserved value.



214

     ______________________________________________________________________________________5.7.__F__________



  Function:             FORM_DIAL()



 Syntax:        <num-result>=FORM_DIAL(flag,x1,y1,w1,h1,x2,y2,w2,h2)



DESCRIPTION:



  Release (or reserve) a rectangular screen area and draw an expanding/shrinking rectangle.

Returns 0 if an error occured. AEag function 0 reserve a display area. 1 draw expanding box. 2

draw shrinking box. 3 release reserved display area. x1,y1 top left corner of rectangle at min

size w1,h1 width & height " " " " " x2,y2 top left corner of rectangle at max size w2,h2 width

& height " " " " "



                                                                                              215

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             FORM_DO()



  Syntax:      <num-result>=FORM_DO(tree,obj)



DESCRIPTION:



   Manages an Object tree, interacts with the user until an object with EXIT or TOUCH EXIT

status is clicked on. Returns the number of the object whose clicking or double clicking caused

the function to end. If it was a double click, bit 15 will be set. tree = address of the object tree.

obj = Number of the orst editable oeld (if there is one).



216

     ______________________________________________________________________________________5.7.__F__________



  Function:             FRAC()



 Syntax:        <num-result>  =  FRAC(<num-expression>)



DESCRIPTION:



  FRAC() returns the fractional part of its argument.



  SEE ALSO:       INT(),CINT(),TRUNC(),ROUND()



EXAMPLE:


        PRINT FRAC(-1.234)
        Result: -0.234



                                                                                              217

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             FREE



  Syntax:      FREE  <adr>



DESCRIPTION:



   Frees a previously allocated Memory block.



   SEE ALSO:       MALLOC()



218

   ______________________________________________________________________________________5.7.__F__________



a=FREEFILE()  Returns orst free olenumber or -1 on error.



                                                                                            219

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             FULLW



  Syntax:      FULLW  [[#]n]



DESCRIPTION:


Enlarges window 'n' to full screen size. 'n' is the window number.



   SEE ALSO:       OPENW,CLOSEW,MOVEW,SIZEW,TOPW,BOTTOMW



220

     ______________________________________________________________________________________5.7.__F__________



  Command:             FUNCTION



 Syntax:        FUNCTION  <name>[$][(<expression>  [,  ...])]



DESCRIPTION:



  FUNCTION starts a user-deoned multi-line function that calculates and returns a value

from an optional list of parameters.  The FUNCTION is called by using the function name

preceeded by a @ in an expression. The function return type can either be a numerical value

or a string. In the latter case, the function name must end with the "$" precision qualioer. (No

Integer type functions with % are allowed.)

  A FUNCTION returns a result with the RETURN command inside the function. In a func-

tion, RETURN can be used several times, with IF or the like. A function cannot be terminated

without a RETURN command being before the ENDFUNC command.  In a function name

ending with the $ character the function returns a string result.

  All variables declared inside the FUNCTION block are global variables unless you declare

them as local with the LOCAL command.  The FUNCTION name may be followed by a

list of parameter variables representing the values and variables in the calling line. Variables

in the calling line reach the FUNCTION "by-value" unless the VAR keyword is used in the

calling line.  In that case, the variable is passed "by-reference" to the FUNCTION so that

the FUNCTION "gets" the variable and not only its value.  Variables passed "by-reference"

can be changed by the FUNCTION. The FUNCTION block is terminated by an ENDFUNC-

TION statement which resumes execution of the calling expression. Unlike a PROCEDURE-

subroutine, a FUNCTION must return a value.



  SEE ALSO:       ENDFUNCTION,RETURN,DEFFN,LOCAL,PROCEDURE



EXAMPLE:


FUNCTION theta(x,a)
  if x>a
     RETURN 0
  else
     RETURN a
  endif
ENDFUNCTION



                                                                                              221

5.__X11-Basic_command_reference___________________________________________________________________



5.8.    G



222

     ______________________________________________________________________________________5.8.__G__________



  Function:             GASDEV()



 Syntax:        <num-result>=GASDEV(<num-expression>)



DESCRIPTION:



  Returns a random number which is gauss distributed. The numbers range from minus inon-

ity to inonity but values around 0 are much more likely. The argument is taken as a seed for

the random generator.



  SEE ALSO:       RND()



                                                                                              223

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             GET



Syntax : GET <x1>,<y1>,<x2>,<y2>,<var$>

   DESCRIPTION:



   GET puts a section of the graphic window into a string variable (x1,y1 and x2,y2 are coor-

dinates of diagonally opposite corners).



   SEE ALSO:       PUT



224

     ______________________________________________________________________________________5.8.__G__________



  Function:             GET_COLOR()



 Syntax:        <num-result>=GET_COLOR(<red-value>,<green-value>,<blue-value>)



DESCRIPTION:



  GET_COLOR() returns acolor number for the specioed color. The rgb-values range from 0

(dark) to 65535 (bright). The returned number depends on the screen depth of the X-Server.

For 8 bit a color cell is allocated or if there is no free cell, a color is chosen which is most

similar to the specioed. The color numbers may be passed to the COLOR command.



EXAMPLE:


yellow=GET_COLOR(65535,65535,0)
COLOR yellow



   SEE ALSO:       COLOR



                                                                                              225

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             GET_GEOMETRY



  Syntax:      GET_GEPMETRY  <winnr>,<varx%>,<vary%>,<varw%>,<varh%>



DESCRIPTION:



   GET_GEOMETRY returns the size of the window or screen.  The window needed to be

opened before this command can be used. A SHOWPAGE will make sure, that thw screen or

window is allocated.



EXAMPLE:


GET_GEOMETRY ,x,y,w,h



   SEE ALSO:       SHOWPAGE



226

     ______________________________________________________________________________________5.8.__G__________



  Function:             GLOB()



 Syntax:        <bool>=GLOB(name$,pattern$[,flags])



DESCRIPTION:



  GLOB() checks if name$ matches the wildcard pattern pattern$ and gives -1 (TRUE), else

0 (FALSE). The kind of check can be secioed with the AEags parameter.

  AEags 0  default, no extras 1  name$ is treated as a olename (Chars '/' are not matched) 2

 Backslashes quote special characters 4  special treatment of '.' 8  just check path of ole

name name$ 16  case insensitive



EXAMPLES:



glob("abcd","abc?")          Result: -1
glob("abcd","*")                      -1
glob("abc","ab??")                     0
glob("*a[0-9]*","sad33333")           0



   SEE ALSO:       INSTR(),WORT"_SEP



                                                                                              227

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             GOSUB   ABBREV.   @



  Syntax:      GOSUB  <preocedure-name>[(<parameterlist>)]



DESCRIPTION:



   GOSUB initiates a jump to the preocedure specioed after GOSUB. The code reached that

way must end with a RETURN statement which returns control to the calling line.

   A procedure name can begin with a digit and contain letters, numbers, dots and the underline

dash. <parameterlist> contains expressions which are passed by value to local variables to the

procedure. It is possible to call further procedures whilst in a procedure. It is even possible to

call the procedure one is in at the time (recursive call).



EXAMPLES:


GOSUB testproc
@calcvac(12,s,4,t$)



   SEE ALSO:       PROCEDURE,RETURN,SPAWN,GOTO,EVERY,AFTER



228

     ______________________________________________________________________________________5.8.__G__________



  Command:             GOTO



 Syntax:        GOTO  <label-name>



DESCRIPTION:



  Allows an unconditional jump to a label. A label must be deoned at the beginning of a line

and must end in a colon.



EXAMPLE:


GOTO here
PRINT "never"
here:
PRINT "ever"



   SEE ALSO:       GOSUB



                                                                                              229

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             GPRINT



  Syntax:      GPRINT  [[AT(),TAB(),SPC()]a$b_const_USING_...;',]_



DESCRIPTION:



   The GPRINT-statement writes all its arguments to the graphic window.  It uses the same

sytax as PRINT. Unlike PRINT thoe output goes to the graphic window.



   SEE ALSO:       PRINT,TEXT



230

     ______________________________________________________________________________________5.8.__G__________



  Command:             GPS



 Syntax:        GPS  ON

                GPS  OFF



DESCRIPTION:



  Switches the GPS (Global positioning System receiver) on or ooe.



  SEE ALSO:       GPS?,GPS"_ALT,GPS"_LAT.  GPS"_LON,SENSOR



                                                                                              231

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             GPS?



  Syntax:      a=GPS?



DESCRIPTION:



   This system variable is 0 if no gps receiver is available on this harware platform.



   SEE ALSO:       GPS,GPS"_ALT,GPS"_LAT.  GPS"_LON,SENSOR



232

     ______________________________________________________________________________________5.8.__G__________



  Variable:             GPS_ALT



 Syntax:        a=GPS_ALT



DESCRIPTION:



  This system variable returns the measured Altitude from the GPS in meters.



  SEE ALSO:       GPS,GPS"_LAT.  GPS"_LON



                                                                                              233

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             GPS_LAT



  Syntax:      a=GPS_LAT



DESCRIPTION:



   This system variable returns the measured Lattitude from the GPS in Degrees.



   SEE ALSO:       GPS,GPS"_ALT.  GPS"_LON



234

     ______________________________________________________________________________________5.8.__G__________



  Variable:             GPS_LON



 Syntax:        a=GPS_LON



DESCRIPTION:



  This system variable returns the measured Longitude from the GPS in Degrees.



  SEE ALSO:       GPS,GPS"_ALT.  GPS"_LAT



                                                                                              235

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             GRAPHMODE



  Syntax:      GRAPHMODE  <n>



DESCRIPTION:



   Sets the graphic mode:

   <n>=0 default <n>=1 replace <n>=2 transparent <n>=3 xor <n>=4 reverse transparent



236

     ______________________________________________________________________________________5.8.__G__________



  Function:             GRAY()



 Syntax:        <num-result>=GRAY(<num-expression>)



DESCRIPTION:



  This function calculates the Gray-code of a given positive integer number. If the number is

negative, the inverse Graycode is calculated.



EXAMPLE:


PRINT GRAY(34)
        Result: 51



                                                                                              237

5.__X11-Basic_command_reference___________________________________________________________________



5.9.    H



238

     ______________________________________________________________________________________5.9.__H__________



  Command:             HELP



 Syntax:        HELP  <string-pattern>



DESCRIPTION:



  Gives information of built in commands and functions.



EXAMPLE:


HELP CL*

Result:

CLEAR [,...]
CLEARW [,i%]
CLOSE [,...]
CLOSEW [,i%]
CLR [,...]
CLS



                                                                                              239

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             HEX$()



  Syntax:      <string-result>=HEX$(<x>[,<n>])



DESCRIPTION:



   Changes the value of <x> into a string expression which contains the value in hexadecimal

form. The optional parameter <n> specioes the number of characters to be used.



   SEE ALSO:       STR"$(),BIN"$()



240

     ______________________________________________________________________________________5.9.__H__________



  Command:             HIDEM



 Syntax:        HIDEM



DESCRIPTION:



  Switches ooe the mouse pointer.



  SEE ALSO:       SHOWM,DEFMOUSE



                                                                                              241

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             HOME



  Syntax:      HOME



DESCRIPTION:



   moves text cursor home. (upper left corner)



   SEE ALSO:       PRINT  AT()



242

     ______________________________________________________________________________________5.9.__H__________



  Command:             HTAB



 Syntax:        HTAB  <num-expression>



DESCRIPTION:



  Positions the text cursor to the specioed column.



  SEE ALSO:       PRINT  AT(),VTAB



                                                                                              243

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             HYPOT()



  Syntax:      <num-result>=HYPOT(<num-expression:x>,<num-expression:y>)



DESCRIPTION:



   The hypot() function returns the sqrt(x*x+y*y).  This is the length of the hypotenuse of a

right-angle triangle with sides of length x and y, or the distance of the point (x,y) from the

origin.



   SEE ALSO:       SQRT()



EXAMPLE:


PRINT HYPOT(3,4)     Result: 5



244

     _____________________________________________________________________________________5.10.__I__________



5.10.    I



                                                                                              245

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             IF



  Syntax:      IF  <condition>  [...  ELSE  [IF  <expression>  ...]  ...  ENDIF



DESCRIPTION:



   Divides a program up into dioeerent blocks depending on how it relates to the 'condition'.



   SEE ALSO:       ELSE,ENDIF



246

     _____________________________________________________________________________________5.10.__I__________



  Operator:             IMP



 Syntax:        <num-result>=<num-expression>  IMP  <num-expression>



DESCRIPTION:



  The operator IMP (implication) corresponds to a logical consequence. The result is FALSE

if a FALSE expression follows a TRUE one. The sequence of the argument is important.

  Table: A _ B _ A IMP B ++ -1 _ -1 _ -1 -1 _ 0 _ 0 0 _ -1 _ -1 0 _ 0 _ -1



  SEE ALSO:       TRUE,FALSE,NOT,XOR,EQV


                           ______________________*_______________________



  Function:             IMP()



 Syntax:        <num-result>=IMP(<num-expression>,<num-expression>)



DESCRIPTION:



  Binary Function of logical operator IMP.



  SEE ALSO:       IMP



EXAMPLE:


            PRINT BIN$(IMP(13,14),4)
    Result:  1110



                                                                                              247

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             INC



  Syntax:      INC  <num-variable>



DESCRIPTION:



   INC increments a (numeric) variable. This command is considerably faster then the equiv-

alent statement "<variable> = <variable> + 1".



   SEE ALSO:       ADD,DEC



248

     _____________________________________________________________________________________5.10.__I__________



  Command:             INFOW



 Syntax:        INFOW  [<window-nr>],<string-expression>



DESCRIPTION:



  Links the (new) information string to the window with the number. On UNIX this Informa-

tion will be displayed in ICONIFIED state of the window.



  SEE ALSO:       TITLEW



                                                                                              249

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             INKEY$



  Syntax:      <string-result>=INKEY$



DESCRIPTION:



   Returns a string containing the ASCII characters of all keys which have been pressed on the

keyboard.



EXAMPLE:


REPEAT ! Wait until a
UNTIL LEN(INKEY$) ! Key was pressed



   SEE ALSO:       INP(),KEYEVENT



250

     _____________________________________________________________________________________5.10.__I__________



  Function:             INLINE$()



 Syntax:        <string-result>=INLINE$(<string-expression>)



DESCRIPTION:



  7Bit-ASCII to Binary conversion. This command basically does a RADIX conversion (from

64 to 256) on the contents of the string. This is intended to be used to include binary data into

the source code of a basic program.

  The inverse coding (from binary to 7 bit ASCII) is done by the program inline.bas which

comes with X11-Basic.



EXAMPLE:


         sym$=INLINE$("$$$$$$$$0$&Tc_>$QL&ZD3cccccK]UD<*%D$$$$$$$$$") ! Train
PUT_BITMAP sym$,92,92,16,16



   SEE ALSO:       PUT"_BITMAP



                                                                                              251

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             INP(),   INP"%(),   INP"&()



  Syntax:      <num-result>=INP(<channel-nr>)

               <num-result>=INP"&(<channel-nr>)

               <num-result>=INP"%(<channel-nr>)



DESCRIPTION:



   Reads one byte from a ole previously opened with OPEN (nr>0) or from the standart oles

(-1=stderr, -2=stdin, -4=stdout). INP&() reads a word (2 Bytes) and INP%() reads a long word

(4 bytes).



EXAMPLE:


"INP(-2)         ! Waits for a key beeing pressed
PRINT INP%(#1)  ! reads a long from a previously opened file



   SEE ALSO:       OUT,INPUT"$()



252

     _____________________________________________________________________________________5.10.__I__________



  Function:             INP?()



 Syntax:        <bool-result>=INP?(<channel-nr>)



DESCRIPTION:


Determine the input status of the device.  TRUE(-1) is device is ready (chars can be read)

ortherwise FALSE(0).



  SEE ALSO:       INP()



                                                                                              253

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             INV()



  Syntax:      b()=INV(a())



DESCRIPTION:


Calculate the inverse of a square matrix a(). The calculation is done using the singular value

decomposition. If the matrix is singular the algorithm tells you how many singular values are

zero or close to zero.



   SEE ALSO:       SOLVE(),DET()



254

     _____________________________________________________________________________________5.10.__I__________



  Command:             INPUT



 Syntax:        INPUT  [#<device-number>]<prompt-expression>], <variable> [, ...]_



DESCRIPTION:



  INPUT gets comma-delimited input from the standart input or from a previously opened ole

as specioed by <device-number> (use the LINEINPUT function to read complete lines from

a ole and BLOAD to load complete oles). Any input is assigned to the variable(s) specioed.

If input is expected from a terminal screen or console window, then <prompt-expression> is

printed to the console window to request input from the user.



  SEE ALSO:       LINEINPUT,FORM  INPUT  AS,PRINT



EXAMPLE:


         INPUT #1,a$
         INPUT "Enter your name:",a$



                                                                                              255

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             INPUT$()



  Syntax:      <string-result>=INPUT$(#<nr>,<len>)

               <string-result>=INPUT$(<len>)



DESCRIPTION:



   Reads <len> characters from the keyboard and assigns them to a string. Optionally, if the

device-number is specioed, the characters are read in from a previously OPENed channel

<nr>.



   SEE ALSO:       INPUT,INP()



256

     _____________________________________________________________________________________5.10.__I__________



  Function:             INSTR()



 Syntax:        <num-result>=INSTR(<a$>,<b$>[,<n>])



DESCRIPTION:



  Searches to see if b$ is present in a$ and returns its position. <n> is a numeric expression

indicating the position in a$ at which the search is to begin (default=1).  If <n> is not given

the search begins at the orst character of a$. If b$ is found in a$ the start position is returned,

otherwise 0.



  SEE ALSO:       RINSTR(),GLOB()



                                                                                              257

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             INT()



  Syntax:      <num-result>  =  INT(<num-expression>)



DESCRIPTION:



   INT() returns the largest integer number smaller than or equal to its argument.



   SEE ALSO:       CINT(),FRAC(),TRUNC(),ROUND()



EXAMPLE:


PRINT INT(1.4), INT(-1.7)
         Result: 1, -2



258

     _____________________________________________________________________________________5.10.__I__________



  Function:             IOCTL()



 Syntax:        <num-result>  =  IOCTL(#n,d%[,adr%])



DESCRIPTION:



  IOCTL() manipulates the underlying device parameters of special oles. In particular, many

operating characteristics of character special oles (e.g. terminals) may be controlled with ioctl

requests. The argument #n must refer to an open ole.

  The second argument is a device-dependent request code. The third argument is an untyped

pointer to memory.

  An ioctl request has encoded in it whether the argument is an in param- eter or out parameter,

and the size of the argument adr% refers to in bytes.

  Usually, on success zero is returned.  A few ioctls use the return value as an output pa-

rameter and return a nonnegative value on success. On error, -1 is returned, and errno is set

appropriately.



  SEE ALSO:       OPEN,CLOSE



EXAMPLE:


         OPEN "U",#1,"/dev/console"
         frequency=300
         tone=1190000/frequency
         KIOCSOUND=19247
         PRINT ioctl(#1,KIOCSOUND,tone)  ! Sounds the speaker
         CLOSE #1
         Result: 0



                                                                                              259

5.__X11-Basic_command_reference___________________________________________________________________



5.11.    J



260

     _____________________________________________________________________________________5.11.__J__________



  Function:             JULDATE$()



 Syntax:        d$=juldate$(a)



DESCRIPTION:



  Returns the date as string (see DATE$) given by the julian day number a.



  SEE ALSO:       JULIAN(),DATE"$



                                                                                              261

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             JULIAN()



  Syntax:      a=JULIAN(date$)



DESCRIPTION:



   Returns the julian date corresponding to the date given as a string in standart format. The

number which is returned is an integer number and has the unit days.



EXAMPLE:



  PRINT "Number of days since Sept. 11 2001: ";julian(date$)-julian("11.09.2001")



   SEE ALSO:       JULDATE"$(),DATE"$



262

     ____________________________________________________________________________________5.12.__K___________



5.12.    K



                                                                                              263

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             KEYEVENT



  Syntax:      KEYEVENT  kc,ks[,t$,k,x,y,xroot,yroot]



DESCRIPTION:



   Waits until Key is pressed. (graphic window) After the key event has occured, the variables

have following meaning:

   kc  Key-code ks  state of Shift/Control/Alt etc. t$  correspondig character x  x coor-

dinate of mouse pointer relative to window y  y coordinate xroot  x coordinate of mouse

pointer relative to screen yroot  y coordinate k  mouse button state



   SEE ALSO:       MOUSEEVENT



264

     _____________________________________________________________________________________5.13.__L__________



5.13.    L



                                                                                              265

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             LEFT$()



  Syntax:      <string-result>  =  LEFT$(<string-expression>  [,<characters>])



DESCRIPTION:



   LEFT$() returns the specioed number of characters from its argument, beginning at its left

side.  If the number of <characters> is not specioed then LEFT$() returns only the leftmost

character.



   SEE ALSO:       RIGHT"$(),MID"$()



EXAMPLE:


        PRINT LEFT$("Hello",1)
        Result: H



266

     _____________________________________________________________________________________5.13.__L__________



  Function:             LEN()



 Syntax:        l=LEN(t$)



DESCRIPTION:



  Returns the length of a string.



EXAMPLE:


        PRINT LEN("Hello")
        Result: 5



                                                                                              267

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             LET



  Syntax:      LET  <variable>  =  <expression>



DESCRIPTION:



   LET assigns the value of <expression> to <variable>. The interpreter also supports implicit

assignments, ie. the LET keyword before an assignment may be omitted. This works because

the orst equal sign is regarded as assignment operator.



EXAMPLE:


        LET N=1



268

     _____________________________________________________________________________________5.13.__L__________



  Command:             LINE



 Syntax:        LINE  <x1>,<y1>,<x2>,<y2>



DESCRIPTION:



  Draws a straight line from (x1,y1) to (x2,y2). The line thickness as well as other drawing

parameters can be set with DEFLINE and GRAPHMODE.



  SEE ALSO:       DRAW,PLOT,DEFLINE



                                                                                              269

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             LINEINPUT



  Syntax:      LINEINPUT  [[#]<device-number>,]  <string-variable>



DESCRIPTION:



   LINE INPUT reads an entire line from a standard input or from a previously opened ole

as specioed by <device-number> (to load a complete ole, use BLOAD). Unlike the regular

INPUT command, LINEINPUT does not stop at delimiters (commas).



   SEE ALSO:       INPUT



270

     _____________________________________________________________________________________5.13.__L__________



  Function:             LINEINPUT$()



 Syntax:        t$=LINEINPUT$([#1])



DESCRIPTION:



  LINEINPUT$() reads an entire line from a standard input or from a previously opened ole

as specioed by <device-number> (to load a complete ole, use BLOAD). Unlike the regular

INPUT command, LINEINPUT$() does not stop at delimiters (commas).



  SEE ALSO:       INPUT"$(),LINEINPUT



                                                                                              271

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             LINK



  Syntax:      LINK  #<device-nr>,<string-expression:name>



DESCRIPTION:



   LINK linkes a shared object ole/library (*.so in /var/lib) dynamically. It will from now on

be addressed via the device-nr.

   The adresses of he symbols of that library can be read with the SYM_ADR() function.

   If the Library is not used any more it can be unlinked with the UNLINK command.



   SEE ALSO:       UNLINK,SYM"_ADR(),CALL



272

     _____________________________________________________________________________________5.13.__L__________



  Command:             LIST



 Syntax:        LIST  [<line-number>[,<line-number>]



DESCRIPTION:



  LIST displays the source code or a code segment. Note that the line number of the orst line

in a ole is 1, that the second line is line 2 etc.



  SEE ALSO:       LLIST,PLIST,PRG"$()



EXAMPLE:


        LIST
        LIST 1-10
        LIST 5



                                                                                              273

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             LISTSELECT()



  Syntax:      num=LISTSELECT(title$,list$())



DESCRIPTION:


listselect opens a graphical list-selector, which enables the user to select one entry out of an

array list$(). The index of the entry is returned or -1 in case no item was selected.



   SEE ALSO:       FILESELECT



274

     _____________________________________________________________________________________5.13.__L__________



  Command:             LOAD



 Syntax:        LOAD  <string-expression:name>



DESCRIPTION:



  Loads a program into memory.



  SEE ALSO:       XLOAD,MERGE



EXAMPLE:


LOAD "testme.bas"



                                                                                              275

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             LOC()



  Syntax:      <int-result>=LOC(#<device-nre>)



DESCRIPTION:



   Returns the location of the ole pointer for the ole with the device number. The location is

given in number of bytes from the start of the ole.



   SEE ALSO:       LOF()



276

     _____________________________________________________________________________________5.13.__L__________



  Command:             LOCAL



 Syntax:        LOCAL  <var>[,<var>,...]



DESCRIPTION:



  Declares several variables to be a local variable.



EXAMPLE:


LOCAL a,b$,s()



                                                                                              277

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             LOCATE



  Syntax:      LOCATE  <row>,<column>



DESCRIPTION:



   Positions the cursor to the specioed location. The upper right corner of the screen is located

at 0,0.



   SEE ALSO:       PRINT  AT(),CRSLIN,CRSCOL



278

     _____________________________________________________________________________________5.13.__L__________



  Function:             LOF()



 Syntax:        <int-result>=LOF(#n)



DESCRIPTION:



  Returns the length of the ole with device number n.



  SEE ALSO:       LOC()



                                                                                              279

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             LOG(),   LOG10(),   LN()



  Syntax:      <num-result>=LOG(<num-expression>)

               <num-result>=LOG10(<num-expression>)

               <num-result>=LN(<num-expression>)



DESCRIPTION:



   Returns the natural logarithm (log, ln) or the logarithm base 10 (log10).



   SEE ALSO:       EXP()



280

     _____________________________________________________________________________________5.13.__L__________



  Function:             LOGB()



 Syntax:        <int-result>=LOGB(<num-expression>)



DESCRIPTION:



  Returns the logarithm base 2 in interger values.



  SEE ALSO:       LOG()



                                                                                              281

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             LOG1P()



  Syntax:      <num-result>=LOG1P(<num-expression>)



DESCRIPTION:



   Returns a value equivalent to log(1+x). It is computed in a way that is accurate even if the

value of x is near zero.



   SEE ALSO:       LOG(),EXP(),LN()



282

     _____________________________________________________________________________________5.13.__L__________



  Command:             LOOP



 Syntax:        LOOP



DESCRIPTION:



  LOOP terminates a DO loop and can be used as unqualioed loop terminator (such a loop

can only be aborted with the EXIT command). Execution continues with the DO line.



EXAMPLE:


DO
  PRINT TIME$
  PAUSE 1
LOOP



   SEE ALSO:       DO,EXIT  IF,BREAK



                                                                                              283

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             LOWER$()



  Syntax:      <string-result>=LOWER$(<string-expression>)



DESCRIPTION:



   Transforms all upper case letters of a string to lower case. Any non letter characters are left

unchanged.



   SEE ALSO:       UPPER"$()



284

     _____________________________________________________________________________________5.13.__L__________



  Function:             LPEEK()



 Syntax:        <int-result>=LPEEK(<num-expression>)



DESCRIPTION:



  Reads a 4 byte integer from address.



  SEE ALSO:       PEEK(),POKE



                                                                                              285

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             LPOKE



  Syntax:      LPOKE  <adr>,<num-expression>



DESCRIPTION:



   Writes a 4 byte integer to address <adr>.



   SEE ALSO:       DPOKE,POKE,PEEK()



286

   _____________________________________________________________________________________5.13.__L__________



LSET t$=a$



                                                                                            287

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             LTEXT



  Syntax:      LTEXT  x,y,t$



DESCRIPTION:



   Draws a Text at position x,y. The LTEXT command uses a Linegraphic-Text, which allows

the user to draw very large Fonts and be independant of the system fonts. The Font Style can

be inAEuenced with the DEFLINE and the DEFTEXT command.



   SEE ALSO:       DEFTEXT,TEXT,DEFLINE,LTEXTLEN()



288

     _____________________________________________________________________________________5.13.__L__________



  Function:             LTEXTLEN()



 Syntax:        w=LTEXTLEN(t$)



DESCRIPTION:



  Returns the with of the text t$ in pixels. The font style can be inAEuenced with the DEFLINE

and the DEFTEXT command.



  SEE ALSO:       LTEXT



                                                                                              289

5.__X11-Basic_command_reference___________________________________________________________________



5.14.    M



290

     ____________________________________________________________________________________5.14.__M___________



  Function:             MALLOC()



 Syntax:        <int-result:adr>=MALLOC(<num-expression:size>)



DESCRIPTION:



  Allocates size bytes and returns a pointer to the allocated memory.  The memory is not

cleared.



  SEE ALSO:       FREE(),MFREE(),REALLOC()



                                                                                              291

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             MAX()



  Syntax:      m=MAX(a,b[,c,...])

               m=MAX(f())



DESCRIPTION:



   Returns the largest value out of the list of arguments or the largest value of an array.



   SEE ALSO:       MIN()



292

     ____________________________________________________________________________________5.14.__M___________



  Command:             MENU



 Syntax:        MENU



DESCRIPTION:



  Performs menu check and action.  This command handles EVENTs.  Prior to use, the re-

quired action should be specioed with a MENUDEF command. For constant supervision of

events, MENU is usually found in a loop.



EXAMPLE:



MENUDEF field$(),menuaction
DO
  pause 0.05
  MENU
LOOP
PROCEDURE menuaction(k)
    ...
RETURN



   SEE ALSO:       MENUDEF



                                                                                              293

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             MENUDEF



  Syntax:      MENUDEF  array$(),<procname>



DESCRIPTION:



   This command reads text for menu-header from array"$() the string-array contains the

text for menu-titles and menu-entrys

   - end of row: empty string "" - end of menu-text: empty string ""

   <procname> The procedure to which control will be passed on selection of a menu entry is

determined.

   <procname> is a procedure with one parameter which is the number of the selected item to

call when item was selected.



EXAMPLE:



field$()=["INFO","  Menutest  ","","FILE","  new","  open ...","  save",""
save as ...","--------------","  print","--------------","  Quit","",""]
MENUDEF field$(),menuaction
DO
  pause 0.05
  MENU
LOOP
PROCEDURE menuaction(k)
  PRINT "MENU selected ";k;" contents: ";field$(k)
  IF field$(k)="  Quit"
     QUIT
  ENDIF
RETURN



   SEE ALSO:       MENU,MENUSET,MENUKILL



294

     ____________________________________________________________________________________5.14.__M___________



  Command:             MENUKILL



 Syntax:        MENUKILL



DESCRIPTION:



  Erases the menu, which prior has been deoned with MENUDEF.



  SEE ALSO:       MENUDEF



                                                                                              295

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             MENUSET



  Syntax:      MENUSET  n,x



DESCRIPTION:



   Change apperance of menu-entry n with value x.

   x=0 ' ' normal, reset marker '(HOCH)' x=1 '(HOCH)' set marker x=2 '=' set menu-point

non selectable x=3 ' ' set menue-point selectable x=4 check the menu entry '-' permanent non

selectable



   SEE ALSO:       MENU



296

     ____________________________________________________________________________________5.14.__M___________



  Command:             MERGE



 Syntax:        MERGE  <filename>



DESCRIPTION:



  MERGE appends a BASIC program to the program currently in memory. Program execu-

tion is not interrupted.  This command typically is used to append often-used subroutines at

run-time.



  SEE ALSO:       CHAIN,LOAD



EXAMPLE:


        MERGE "examples/hello.basic"



                                                                                              297

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             MFREE



  Syntax:      MFREE  adr%



DESCRIPTION:



   Frees a memory area which has been allocated with MALLOC() before. The adress mus be

the same returned by MALLOC().



   SEE ALSO:       MALLOC()



298

     ____________________________________________________________________________________5.14.__M___________



  Function:             MID$()



 Syntax:        m$=MID$(t$,s[,l])



DESCRIPTION:



  Returns l characters in a string from the positon s of the string t

:If sislargerthanthelengthof t

, then an empty string is returned. If l is omitted, then the function returns only one character

of the string from position x.



  SEE ALSO:       LEFT"$(),RIGHT"$()



                                                                                              299

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             MIN()



  Syntax:      m=MIN(a,b[,c,...])

               m=MIN(f())



DESCRIPTION:



   Returns the smallest value out of the list of arguments or the smallest value of an array.



   SEE ALSO:       MAX()



300

     ____________________________________________________________________________________5.14.__M___________



  Function:             MKI$(),   MKL$(),   MKS$(),   MKF$(),   MKD$(),   MKA$()



 Syntax:        <string-result>=MKI$(<num-expression>)

                <string-result>=MKL$(<num-expression>)

                <string-result>=MKS$(<num-expression>)

                <string-result>=MKF$(<num-expression>)

                <string-result>=MKD$(<num-expression>)

                <string-result>=MKA$(<array-expression>)



DESCRIPTION:



  Transforms a number into a character string.

MKI$ 16-bit number into a 2-byte string.

MKL$ 32-bit number into a 4-byte string.

MKS$ a number into a 4-byte AEoat format.

MKF$ same as MKS$().

MKD$ a number into a 8-byte double AEoat format. MKA$() transforms a whole Array into a

string. It can be beacktransformed with CVA().



  SEE ALSO:       CVI(),CVF(),CVL(),CVA(),CVS(),CVD()



                                                                                              301

5.__X11-Basic_command_reference___________________________________________________________________



   Operator:             MOD



  Syntax:      <num-result>=<num-expression:x>  MOD  <num-expression:y>



DESCRIPTION:



   Produces the remainder of the division of x by y.



   SEE ALSO:       DIV,MOD()


                          _______________________*______________________



   Function:             MOD()



  Syntax:      <num-result>=MOD(<num-expression:x>,<num-expression:y>)



DESCRIPTION:



   Produces the remainder of the division of x by y.



   SEE ALSO:       DIV,MOD



302

     ____________________________________________________________________________________5.14.__M___________



  Command:             MOUSE



 Syntax:        MOUSE  x,y,k



DESCRIPTION:



  Determines the mouse position (x,y) relative to the origin of the graphics window and the

status of the mouse buttons (k). k=0 no buttons pressed

k=1 left button

k=2 middle button

k=4 right buttons

or any combinations.



  SEE ALSO:       MOUSEX,MOUSEY,MOUSEK



                                                                                              303

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             MOUSEEVENT



  Syntax:      MOUSEEVENT  x,[y,k,xroot,yroot,s]



DESCRIPTION:



   Waits until a mouse button is pressed (graphic window).  Returns Mouse coorinate (x,y)

relative to window, mouse coorinate (xroot,yroot) relative to screen, mouse button and state of

the Alt/Shift/Caps keys.



   SEE ALSO:       MOUSE,MOUSEX,MOUSEY,MOUSEK,KEYEVENT



304

     ____________________________________________________________________________________5.14.__M___________



  Variable:             MOUSEX,   MOUSEY,   MOUSEK,   MOUSES



 Syntax:        <int-result:x>=MOUSEX

                <int-result:y>=MOUSEY

                <int-result:k>=MOUSEK

                <int-result:s>=MOUSES



DESCRIPTION:



  Determines the mouse position (x,y), the status of the mouse buttons (k) and the status of

the Shift and Control keys (s): k=0 no buttons pressed

k=1 left button

k=2 middle button

k=4 right buttons

or any combinations.

  s=0 no Keys

s=1 Shift

s=2 CapsLock

s=4 Control

s=8 Alt

s=16 NumLock

s=64 Windows-Key

s=128 ScrollLock

or any combination.



  SEE ALSO:       MOUSE,SETMOUSE,MOUSEEVENT



                                                                                              305

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             MOTIONEVENT



  Syntax:      MOTIONEVENT  x,y,xrrot,yroot,s



DESCRIPTION:



   Waits until the mouse has been moved.  (graphic window).  Returns new mouse coorinate

(x,y) relative to window, mouse coorinate (xroot,yroot) relative to screen and state of the

Alt/Shift/Caps keys.



   SEE ALSO:       MOUSE,MOUSEX,MOUSEY,MOUSEK,MOUSEEVENT



306

     ____________________________________________________________________________________5.14.__M___________



  Command:             MOVEW



 Syntax:        MOVEW  n,x,y



DESCRIPTION:



  Moves Wondow n to absolute screen position x,y



  SEE ALSO:       OPENW,SIZEW,TITLEW



                                                                                              307

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             MSYNC



  Syntax:      MSYNC  adr,length



DESCRIPTION:


MSYNC AEushes changes made to the in-core copy of a ole that was mapped into memory

using MAP back to disk. Without use of this call there is no guarantee that changes are written

back before UNMAP is called. To be more precise, the part of the ole that corresponds to the

memory area starting at addr and having length length is updated.



   SEE ALSO:       MAP,UNMAP



308

     ____________________________________________________________________________________5.14.__M___________



  Function:             MTFD$()



 Syntax:        b$=MTFD$(a$)



DESCRIPTION:



  This function performs a Move To Front decoding function on an input string.  The MTF

decoder keeps an array of 256 characters in the order that they have appeared.  Each time

the encoder sends a number, the decoder uses it to look up a character in the corresponding

position of the array, and outputs it. That character is then moved up to position 0 in the array,

and all the in-between characters are moved down a spot.



  SEE ALSO:       MTFE"$()



                                                                                              309

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             MTFE$()



  Syntax:      b$=MTFE$(a$)



DESCRIPTION:



   This function performs a Move To Front encoding function on an input string.  An MTF

encoder encodes each character using the count of distinct previous characters seen since the

characters last appearance. This is implemented by keeping an array of characters. Each new

input character is encoded with its current position in the array. The character is then moved

to position 0 in the array, and all the higher order characters are moved down by one position

to make roon.



   SEE ALSO:       MTFD"$()



310

     ____________________________________________________________________________________5.14.__M___________



  Command:             MUL



 Syntax:        MUL  <num-var>,<num-expression>



DESCRIPTION:



  Same as var=var*n but faster.



  SEE ALSO:       ADD,SUB,MUL(),DIV


                           ______________________*_______________________



Function:             MUL()



 Syntax:        <num-result>=MUL(<num-expression>,<num-expression>)



DESCRIPTION:



  Returns product of two numbers.



  SEE ALSO:       ADD(),SUB(),MUL,DIV()



                                                                                              311

5.__X11-Basic_command_reference___________________________________________________________________



5.15.    N



312

     ____________________________________________________________________________________5.15.__N___________



  Command:             NEW



 Syntax:        NEW



DESCRIPTION:



  NEW erases the program and all variables in memory (and stops execution of program.)



  SEE ALSO:       CLEAR



                                                                                              313

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             NEXT



  Syntax:      NEXT  [<variable>]



DESCRIPTION:



   NEXT terminates a FOR loop. FOR loops must be nested correctly: The variable name after

NEXT is for looks only and can not be used to select a FOR statement. Each NEXT jumps to

the matching FOR statement regardless if and what <variable> is specioed after NEXT.



   SEE ALSO:       FOR



EXAMPLE:


         FOR n=1 TO 2
              FOR m=10 to 11
                  PRINT "n=";n,"m=";m
              NEXT m
         NEXT n



314

     ____________________________________________________________________________________5.15.__N___________



  Command:             NOP,   NOOP



 Syntax:        NOP

                NOOP



DESCRIPTION:



  No Operation: do nothing.



                                                                                              315

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             NOROOTWINDOW



  Syntax:      NOROOTWINDOW



DESCRIPTION:



   Switches back to normal graphic output (normaly into a window), if it was switched to

ROOTWINDOW before.



   SEE ALSO:       ROOTWINDOW



316

     ____________________________________________________________________________________5.16.__O___________



5.16.    O



                                                                                              317

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             OBJC_ADD



  Syntax:      OBJC_ADD  tree,parent,child



DESCRIPTION:



   Adds an object to a given tree and pointers between the existing objects and the new object

are created. tree = address of the object tree parent = object number of the parent object child

= object number of the child to be added.



   SEE ALSO:       OBJC"_DELETE



318

     ____________________________________________________________________________________5.16.__O___________



  Command:             OBJC_DELETE



 Syntax:        OBJC_DELETE  tree,object



DESCRIPTION:



  An object is deleted from an object tree by removing the pointers. The object is still there

and can be restored by repairing the pointers.

  tree address of the object tree object Object number of the object to delete.



  SEE ALSO:       OBJC"_ADD



                                                                                              319

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             OBJC_DRAW()



  Syntax:      ret=objc_draw(tree,startob,depth,cx,cy,cw,ch)



DESCRIPTION:



   Draws any object or objects in an object tree.

   Each OBJC_DRAW call deones a new clip rectangle, to which the drawing is limited for

that call.

   Returns 0 on error.  tree address of the object tree startob number of the orst object to

be drawn depth Number of object levels to be drawn cx,cy coordinates of top left corner of

clipping rectangle cw,ch width & height of clipping rectangle



   SEE ALSO:       OBJC"_FIND()



320

     ____________________________________________________________________________________5.16.__O___________



  Function:             OBJC_FIND()



 Syntax:        idx=objc_find(tree,startob,depth,x,y)



DESCRIPTION:



  Finds an object under a specioc screen coordinate. (These may be the mouse coordinates.)

  The application supplies a pointer to the object tree, the index to the start object to search

from, the x- and y-coordinates of the mouse's position, as well as a parameter that tells

OBJC_FIND how far downthe tree to search (depth).

  This Fucntion returns the index of the found Object or -1 in case no object could be found.



  SEE ALSO:       OBJC"_DRAW()



                                                                                              321

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             OBJC_OFFSET()



  Syntax:      ret=objc_offset(tree,obj,x,y)



DESCRIPTION:



   Calculates the absolute screen coordinates of the specioed object in a specioed tree. Returns

0 on error. tree address of the object tree obj object number x,y returns the x,y coordinates to

these variables.



   SEE ALSO:       OBJC"_FIND()



322

     ____________________________________________________________________________________5.16.__O___________



  Function:             OCT$()



 Syntax:        o$=OCT$(d%,n%)



DESCRIPTION:


Converts an integer value d% into a string containing octal number representation.  SEE



ALSO:       BIN"$(),STR"$(),HEX"$()



                                                                                              323

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ON   *   GOSUB



  Syntax:      ON  a  GOSUB  proc1[,proc2,...]



DESCRIPTION:



   Calls a procedure out of the given list of procedures depending on the value of a. If a=1, the

orst procedure is used, if a=2 the second, and so on.



   SEE ALSO:       GOSUB



324

     ____________________________________________________________________________________5.16.__O___________



  Command:             ON   BREAK



 Syntax:        ON  BREAK  CONT

                ON  BREAK  GOSUB  <procedure>

                ON  BREAK  GOTO  <label>



DESCRIPTION:



  ON BREAK installs a subroutine that gets called when the BREAK condition (normally

CTRL-c) occurs.  ON BREAK CONT causes the program to continue in any case.  ON

BREAK GOTO jumps to a specioed label.



  SEE ALSO:       GOTO,ON  ERROR



                                                                                              325

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ON   ERROR



  Syntax:      ON  ERROR  CONT

               ON  ERROR  GOSUB  <procedure>

               ON  ERROR  GOTO  <label>



DESCRIPTION:



   ON ERROR installs an error handling subroutine that gets called when the next error occurs.

ON ERROR CONT will ignore any error.



   SEE ALSO:       GOSUB,ERROR



326

     ____________________________________________________________________________________5.16.__O___________



  Command:             OPEN



 Syntax:        OPEN  <mode>,<device-number>,<filename>[,<port-value>]



DESCRIPTION:



  OPEN opens the specioed ole for reading or writing or both. The <device-number> is the

number you want to assign to the ole (functions that read from oles or write to oles expect to

be given this number).  The device number must be between 0 and 99 in the current imple-

mentation of X11-Basic. When you close a ole, the device number is released and can be used

again in subsequent OPEN statements.

  <mode> is a character string which indicates the way the File should be opened. The orst

character of that String may be "O", "I", "U" or "A".  These characters correspont to the

mode for which the ole is opened: "I"  INPUT, "O" OUTPUT, "A"  APPEND and "U"

UNSPECIFIED. Open a ole for INPUT if you want to read data from the ole.  If you open

a ole for OUTPUT, you can write to the ole.  However, all data that was stored in the ole

(if the ole already exists) is lost.  If you want to write new data to a ole while keeping the

existing content, open the ole for appending to it, using the APPEND mode. When you open

a ole using the RANDOM ("U") keyword, you can both read from the ole and write to the

ole at arbitrary positions. You can, for example, seek a position in the middle of the ole and

start appending new lines of text. All ole modes but INPUT create the ole if it does not exist.

OPEN "I" fails if the ole does not exist (use the EXIST() function before OPEN to be sure that

the ole exists).

  The second character specioes the type of File which should be opened or created: "" default

opens regular ole "U" opens a datagramm socket connection "C" opens a Strem socket as client

with connection "S" opens a stream socket as server "A" Socket accept connection "X" extra

settings for a special device following: (e.g. speed and parity of transmission via serial ports)

"UX:baud,parity,bits,stopbits,AEow"

  <port-nr> The portnr is used only by the OPEN "UC" and OPEN "UU" statement. It deter-

mines the TCP/IP Port of connection (FTP, WWW, TELNET, MAIL etc.).



  SEE ALSO:       CLOSE,EXIST(),INPUT,LINEINPUT,PRINT,SEEK,LOF(),EOF(), LOC(),

BLOAD, LINK, FREEFILE(), CONNECT



EXAMPLES:


OPEN "I",#1,"data.dat"       ---- opens file "data.dat" for input
OPEN "UC",#1,"localhost",80 ---- opens port 80 of localhost for read and#



                                                                                              327

5.__X11-Basic_command_reference___________________________________________________________________



 write
OPEN "UX:9600,N,8,1,XON,CTS,DTR",#1,"/dev/ttyS1"
                   ---- open COM2 for input and output with 9600:8:N:1 with
       software flow control and hardware flow control and also
       drop DTR line and raise it again.



328

     ____________________________________________________________________________________5.16.__O___________



  Command:             OPENW



 Syntax:        OPENW  n



DESCRIPTION:



  Opens a graphic window.  There can be up to 16 graphic windows opened.  All graphic

output goes to the window which was opened latest. OPENW can be used to switch between

multiple windows. Window 1 os opened automatically on default when the orst graphic com-

mand is executed and no other window is already opened.



  SEE ALSO:       CLOSEW,MOVEW,SIZEW,TITLEW,ROOTWINDOW,USEWINDOW



                                                                                              329

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             OUT



  Syntax:      OUT  #n,a



DESCRIPTION:



   Writes a byte a to an open (output) channel or ole #n.



   SEE ALSO:       PRINT,INP()



330

     _____________________________________________________________________________________5.17.__P__________



5.17.    P



                                                                                              331

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PAUSE



  Syntax:      PAUSE  <sec>



DESCRIPTION:



   pauses <sec> seconds. The resolution of this command is microseconds (in theory).



332

     _____________________________________________________________________________________5.17.__P__________



  Command:             PBOX



 Syntax:        PBOX  x1,y1,x2,y2



DESCRIPTION:



  Draws a olled box with corners x1,y1 and x2,y2.



  SEE ALSO:       BOX,RBOX,DEFFILL,COLOR



                                                                                              333

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PCIRCLE



  Syntax:      PCIRCLE  x%,y%,r%[,a1,a2]



DESCRIPTION:



   Draws a olled circle (or sector) at center coordinates x,y with radius r and optional starting

angle a1 and ending angle a2 (in radians).



   SEE ALSO:       CIRCLE,DEFFILL,COLOR



334

     _____________________________________________________________________________________5.17.__P__________



  Function:             PEEK()



 Syntax:        <int-result>=PEEK(<address>)



DESCRIPTION:



  PEEK() reads a byte from an address in memory. The following example dumps a section

of the internal memory near a string t$.



EXAMPLE:



t$="Hallo, this is a string..."
i=varptr(t$)-2000
DO
  PRINT "$";HEX$(i,8,8)'
  FOR iu=0 TO 15
     PRINT HEX$(PEEK(i+iu) and 255,2,2)'
  NEXT iu
  PRINT '
  FOR iu=0 TO 15
     a=PEEK(i+iu)
     IF a>31
       PRINT CHR$(a);
     ELSE
       PRINT ".";
     ENDIF
  NEXT iu
  PRINT
  ADD i,16
LOOP



   SEE ALSO:       POKE



                                                                                              335

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PELLIPSE



  Syntax:      PELLIPSE  x,y,a,b[,a1,a2]



DESCRIPTION:



   Draws a olled ellipse (or or elliptic sector) at center coordinates x,y with radii a and b.



   SEE ALSO:       PCIRCLE,ELLIPSE,DEFFILL,COLOR



336

     _____________________________________________________________________________________5.17.__P__________



  Command:             PIPE



 Syntax:        PIPE  #n1,#n2



DESCRIPTION:



  PIPE links two ole channels n1 and n2 together to form a pipe. n1 is for reading, n2 is for

writing. Whatever you write to the pipe can be read from it at a dioeerent time. The content is

buoeered in the kernel. The mechanism is FIFI (0 orst in orst out). The biggest advantage is,

that you can read and write to it from dioeerent processes (created by FORK()). This allows

inter-process communication.



EXAMPLE:



PIPE #1,#2
PRINT #2,"Hello, get me out of the pipe..."
FLUSH #2
LINEINPUT #1,t$
PRINT t$



   SEE ALSO:       CLOSE,OPEN,FORK()



                                                                                              337

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PLAYSOUND



  Syntax:      PLAYSOUND  channel,s$



DESCRIPTION:



   PLAYSOUND plays a WAV sample on the sound card.  s$ must contain the data from a

sound ole.  (WAV format).  The saple is then played once on the channel c.  If c is -1 a free

channel is selected. There are 16 channels. (currently this only works in the MS WINDOWS

or SDL version.)



EXAMPLE:


         OPEN "I",#1,"sound.wav"
t$=INPUT$(#1,LOF(#1))
CLOSE #1
PLAYSOUND ,t$



   SEE ALSO:       SOUND



338

     _____________________________________________________________________________________5.17.__P__________



  Command:             PLAYSOUNDFILE



 Syntax:        PLAYSOUNDFILE  filename$



DESCRIPTION:



  PLAYSOUNDFILE play a soundole of standard ole formats like WAV, OGG, MP3.  The

sound is played in the background. Any previously played sounds will be stopped if the have

not been onished so far. (currently this only works in the ANDROID version of X11-Basic.)



EXAMPLE:


PLAYSOUNDFILE "/mnt/sdcard/bas/explosion.ogg"



   SEE ALSO:       SOUND,PLAYSOUND



                                                                                              339

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PLIST



  Syntax:      PLIST



DESCRIPTION:



   Outputs a formatted listing of the actual program in memory. Alos the internal tokens are

printed ans some internal Information. This is intended for internal use only.



EXAMPLE:



> PLIST
    0: $00001a _    0,0 _CLS
    1: $000279 _    0,0 _PRINT
    2: $000279 _    0,1 _PRINT " example how to use the ansi color spec."
    3: $000279 _    0,0 _PRINT
    4: $000279 _    0,1 _PRINT "X 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0"
    5: $310240 _  12,1 _FOR U=0 TO 3
    6: $310240 _  11,1 _  FOR J=0 TO 7
    7: $310240 _  10,1 _     FOR I=0 TO 7
    8: $000279 _    0,1 _       PRINT AT(J+6,2*I+2+16*U);CHR$(27)+"["+STR$(U)+";"+STR$(30+I)+";"+STR$(40+J)+"m *";
    9: $320266 _    7,1 _     NEXT I
  10: $320266 _    6,1 _  NEXT J
  11: $320266 _    5,1 _NEXT U
  12: $000279 _    0,0 _PRINT
  13: $00047f _    0,0 _QUIT
  14: $0008ff _    0,0 _=?=> 2303



   SEE ALSO:       LIST



340

     _____________________________________________________________________________________5.17.__P__________



  Command:             PLOT



 Syntax:        PLOT  x,y



DESCRIPTION:



  Draws a point (single pixel) at screen coordinate x,y



  SEE ALSO:       LINE,POINT(),COLOR



                                                                                              341

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             POINT()



  Syntax:      c=POINT(x,y)



DESCRIPTION:



   Returns the colour of the graphic point x,y in the current window. The color values are of

the same format than thouse used by COLOR and returned by GET_COLOR().



   SEE ALSO:       PLOT,COLOR



342

     _____________________________________________________________________________________5.17.__P__________



  Command:             POKE



 Syntax:        POKE  adr%,byte%



DESCRIPTION:



  POKE writes a byte to address adr% of the program memory.



  SEE ALSO:       PEEK(),DPOKE,LPOKE



                                                                                              343

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             POLYFILL



  Syntax:      POLYFILL  n,x(),y()[,x_off,y_off]



DESCRIPTION:



   POLYFILL draws a olled polygon with n corners. The x,y coordinates for the corner points

are given in arrays x() and y(). The optional parameters x_ooe,y_ooe will be added to each of

these coordinates.

   POLYFILL olls the polygon with the color and pattern previously deoned by COLOR and

DEFFILL.



   SEE ALSO:       COLOR,DEFFILL,POLYLINE,POLYMARK



344

     _____________________________________________________________________________________5.17.__P__________



  Command:             POLYLINE



 Syntax:        POLYLINE  n,x(),y()[,x_off,y_off]



DESCRIPTION:



  POLYLINE draws a polygon with n corners. The x,y coordinates for the corner points are

given in arrays x() and y(). The optional parameters x_ooe,y_ooe will be added to each of these

coordinates.

  To draw a closed polygon, the orst point hast to be equal to the last point.



  SEE ALSO:       LINE,DEFLINE,COLOR,POLYFILL,POLYMARK



                                                                                              345

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             POLYMARK



  Syntax:      POLYMARK  n,x(),y()[,x_off,y_off]



DESCRIPTION:



   POLYMARK marks the corner points of an invisible polygon with n corners.  The x,y

coordinates for the corner points are given in arrays x() and y().  The optional parameters

x_ooe,y_ooe will be added to each of these coordinates.

   POLYMARK marks the points with the shape deoned by DEFMARK.



   SEE ALSO:       COLOR,DEFLINE,POLYLINE,POLYFILL



346

   _____________________________________________________________________________________5.17.__P__________



POS



                                                                                            347

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PRBOX



  Syntax:      PRBOX  x1,y1,x2,y2



DESCRIPTION:



   Draws a olled box with rounded corners at x1,y1 and x2,y2.



   SEE ALSO:       BOX,PBOX,DEFFILL,COLOR



348

   _____________________________________________________________________________________5.17.__P__________



t$=PRG$(i)  Programmzeile i (Quelltext)



                                                                                            349

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PRINT   ABBREV.   ?



  Syntax:      PRINT  [[AT(),TAB(),SPC(),COLOR()]a$b_const_USING_...;',]_



DESCRIPTION:



   The print-statement writes all its arguments to the screen (standard output); after writing its

last argument, print goes to the next line (as in print "Hello ",a$," !"); to avoid this automatic

newline, place a semicolon (;) after the last argument (as in print "Please enter your Name:";).

To insert a tabulator instead of the automatic newline append a colon (,), e.g.  print "Please

enter your Name:", . Note that print can be abbreviated with a single question mark (?).

   Advanced printing: PRINT AT(), PRINT colour and PRINT USING

   PRINT AT

   For interactive programs you might want to print output at specioc locations. Try the next

example: PRINT AT(4,7);"Test"

   TAB and SPC PRINT "Hallo";TAB(30);"Test" PRINT "Hallo";SPC(30);"Test"

   PRINT COLOR PRINT COLOR(32,2);"Hallo"

   The COLOR statement takes up to three arguments. Their meaning is:

   Text Mode: Text color: Backgroud color:

   0 default setting 30 black 40 black 1 intensive 31 red 41 red 2 dark 32 green 42 green 33

yellow 43 yellow 4 underline 34 blue 44 blue 5 blink 35 magenta 45 magenta 36 cyan 46 cyan

7 reverse 37 white 47 white

   PRINT USING

   To control the way numbers are printed, use the print using statement:  print 12.34 using

"###.####" produces 12.3400. The format string ("###.####") consists of hashes (#) with one

optional dot and it pictures the appearance of the number to print.



   SEE ALSO:       GPRINT,STR"$(),INPUT



350

     _____________________________________________________________________________________5.17.__P__________



  Command:             PROCEDURE



 Syntax:        PROCEDURE  procname  [(p1  [,p2]  ...  )]  *  RETURN



DESCRIPTION:



  PROCEDURE starts a user-deoned multi-line subroutine which can be executed by the

GOSUB command. Any number of parameters may be passed to the PROCEDURE via the

parameter list. The variables in that list act like local variables inside the subroutine.

  All variables declared inside the PROCEDURE block are global variables unless you de-

clare them as local with the LOCAL command. Variables in the calling line reach the PROCE-

DURE "by-value" unless the VAR keyword is used in the calling line. In that case, the variable

is passed "by-reference" to the PROCEDURE so that the PROCEDURE "gets" the variable

and not only its value. Variables passed "by-reference" can be changed by the PROCEDURE.

The PROCEDURE block is terminated by the RETURN statement which resumes execution

of the calling expression. Unlike a FUNCTION-subroutine, a PROCEDURE can not return a

value.

  PROCEDUREs are usually deond at the end of the program source code. The program AEow

may not hit a procedure or function deonition. In this case it would produce an error 36 - error

in program structure.  If you want them in the middle of the "main" part, use gotos to jump

over them.



EXAMPLE:


PRINT "this is the main part of the program
GOTO a
PROCEDURE b
  PRINT "this is inside the procedure..."
RETURN
a:
PRINT "go on"
GOSUB b
END



   SEE ALSO:       GOSUB,RETURN,LOCAL,FUNCTION



                                                                                              351

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             PTST()



  Syntax:      c=PTST(x,y)



DESCRIPTION:



   PTST returns the colour of the graphic point x,y in the current window.  It is the same as

POINT().



   SEE ALSO:       POINT(),PLOT



352

     _____________________________________________________________________________________5.17.__P__________



  Command:             PUT



 Syntax:        PUT  <x>,<y>,<var$>[,<scale>[,<transparency>[,xs,ys,w,h]]]



DESCRIPTION:



  Maps a graphic bitmap contained in var$ into the graphic window at coordinate x,y.  The

picture can be scaled by <scale> factor (default: 1).  If you want to paint only a portion of

the image you can specify the coordinates, width and hight of a rectangular area of the image

(after scaling). If transparency is given and the picture has a color table, this is interpreted as

a color index, which will be treated as transparent.

  If an alpha channel is present, this is used as a threshold for the alpha value (0-255). Default

is 32. If the coordinates xs,ys,w,h are given, only a rectangular part of the image is mapped.

The ole or data format used in var$ is a BMP ole format. It can contain uncompressed bitmaps

optionally with alpha channel of 1,8,16,24, or 32 bit depth. If you want to use .png oles for

your icons to be mapped with PUT, orst convert them with ImageMagic to BMP: e.g. convert

in.png -depth 32 out.bmp Also the alpha channel can be preserved.  The images also can be

included into the sourcecode of the program.  See the tool inline.bas on how to make inline

data.



EXAMPLE:



       OPEN "I",#1,"picture.bmp"
       t$=INPUT$(#1,lof(#1))
       CLOSE #1
       CLEARW
       PUT 0,0,t$,2                 ! scaled by a factor of 2
       PUT 100,0,t$,,,0,0,20,20    ! put only a 20x20 area
       SHOWPAGE



   SEE ALSO:       GET,PUT"_BITMAP



                                                                                              353

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             PUTBACK



  Syntax:      PUTBACK  [#n,]a



DESCRIPTION:


Puts a character back into an input channel #n.



   SEE ALSO:       OUT



354

     _____________________________________________________________________________________5.17.__P__________



  Command:             PUT_BITMAP



 Syntax:        PUT_BITMAP  bitmp$,x,y,w,h



DESCRIPTION:



  Maps a monochrome bitmap contained in bitmp$ into the graphic window at coordinate x,y.

Tne bitmap is stored in raw format, so you must specify the size of the bitmap with w (width)

and h (height) in pixels. The Bitmap is drawn with the color set by COLOR and transparency

if set with GRAPHMODE.



  SEE ALSO:       PUT,COLOR,GRAPHMODE



                                                                                              355

5.__X11-Basic_command_reference___________________________________________________________________



5.18.    Q



356

     ____________________________________________________________________________________5.18.__Q___________



  Command:             QUIT



 Syntax:        QUIT  [<return-code>]



DESCRIPTION:



  QUIT exits the interpreter. You may set a <return-code> which will be passed to the pro-

gram running the interpreter.



  SEE ALSO:       END



                                                                                              357

5.__X11-Basic_command_reference___________________________________________________________________



5.19.    R



358

     _____________________________________________________________________________________5.19.__R__________



  Function:             RANDOM()



 Syntax:        <num-result>  =  RND(<maximum>)



DESCRIPTION:



  RANDOM() returns a pseudo-random integer number between 0 (inclusive) and <maxi-

mum> (exclusive). The sequence of pseudo-random numbers is identical each time you start

the interpreter unless the RANDOMIZE statement is used prior to using RANDOM(): RAN-

DOMIZE seeds the pseudo-random number generator to get a new sequence of numbers from

RANDOM().



  SEE ALSO:       RND(),RANDOMIZE,GASDEV



EXAMPLE:


         PRINT RANDOM(10)
         Result: 8



                                                                                              359

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             RANDOMIZE



  Syntax:      RANDOMIZE  [<seed-expression>]



DESCRIPTION:



   RANDOMIZE seeds the pseudo-random number generator to get a new sequence of num-

bers from RND(). Recommended argument to RANDOMIZE is a "random" number to ran-

domly select a sequence of pseudo-random numbers.  If RANDOMIZE is not used then the

sequence of numbers returned by RND() will be identical each time the interpreter is started.

If no argument is given, the TIMER value will be used as a seed.



   SEE ALSO:       RND(),TIMER



360

     _____________________________________________________________________________________5.19.__R__________



  Command:             RBOX



 Syntax:        RBOX  x1,y1,x2,y2



DESCRIPTION:



  Draws a rectangle with rounded corners from the two diagonally opposite corner points

'x1,y1' and 'x2,y2'



  SEE ALSO:       BOX,PBOX,PRBOX



                                                                                              361

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             READ



  Syntax:      READ  var[,var2,  ...]



DESCRIPTION:



   Reads constant values from a DATA command and assigns them to a variable 'var'. Reading

is taken from the last point a RESTORE was done (if any).



   SEE ALSO:       DATA,RESTORE



362

     _____________________________________________________________________________________5.19.__R__________



  Command:             RECEIVE



 Syntax:        RECEIVE  #n,t$[,a]



DESCRIPTION:



  RECEIVE is used to receive messages t$ from a socket #n, which has been opened with

OPEN before. If a is given, this variable will take the host address of the sender (IPv4 32 bit

format).



  SEE ALSO:       OPEN,SEND



                                                                                              363

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             RELSEEK



  Syntax:      RELSEEK  [#]n,d



DESCRIPTION:



   Place ole pointer on new relative position d which means it moves the ole pointer forward

(d>0) or backwards (d<0) d bytes.



   SEE ALSO:       SEEK,LOC(),LOF(),EOF()



364

     _____________________________________________________________________________________5.19.__R__________



  Command:             REM   ABBREV.   '



 Syntax:        REM  This  is  a  comment

                '  This  also  is  a  comment



DESCRIPTION:


This command reserves the entire line for a comment.

  COMMENT:

  Note, that rem is an abbreviation for remark.

  Do use comments in your programs, the more the better.  Yes, the program will become

longer, but it's nice to be able to understand a well- documented program that you've never

seen before.  Or one of your own masterpieces that you haven't looked at for a couple of

years.  Don't worry about the speed of your program, except in loops or often called Proce-

dures/Functions. There a comment-line (beginning with REM or ') will slow the interpreter

down. A comment after '!' has no inAEuence on the speed of a program, so you can use these

everywhere.



  SEE ALSO:       !



                                                                                              365

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             REPEAT



  Syntax:      REPEAT  ...  UNTIL  <expression>



DESCRIPTION:



   REPEAT initiates a REPEAT...UNTIL loop.  The loop ends with UNTIL and execution

reiterates until the UNTIL <expression> is not FALSE (not null). The loop body is executed

at least once.



   SEE ALSO:       DO,LOOP,UNTIL,EXIT  IF,BREAK,WHILE



EXAMPLE:


         REPEAT
              INC n
         UNTIL n=10



366

     _____________________________________________________________________________________5.19.__R__________



  Function:             REPLACE$()



 Syntax:        <string-result>  =  REPLACE$(<string-expression>,  <search  string>,  <replace  string>  )



DESCRIPTION:



  REPLACE$() returns string-expression where all <search string> have been replaced by

<replace string>.



  SEE ALSO:       INSTR(),WORT"_SEP



EXAMPLE:


        PRINT REPLACE$("Hello","l","w")
        Result: Hewwo



                                                                                              367

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             RESTORE



  Syntax:      RESTORE  [<label>]



DESCRIPTION:



   RESTORE sets the position DATA is read from to the orst DATA line of the program (or to

the orst DATA line after <label> if RESTORE is used with an argument).



   SEE ALSO:       DATA,READ



EXAMPLE:


         READ  a, b, c
         RESTORE
         READ  a, b, c
         DATA  1, 2, 3



368

     _____________________________________________________________________________________5.19.__R__________



  Command:             RESUME



 Syntax:        RESUME

                RESUME  NEXT

                RESUME  <label>



DESCRIPTION:



  The RESUME command is especially meaningful with error capture (ON ERROR GOSUB)

where it allows a reaction to an error. Anyway, X11-Basic allows the us of RESUME <label>

everywhere in the program (instead of GOTO <label>), and can be used to jump out of a

subroutine. If you jump into another Subroutine, you must not reach its RETURN statement.

RESUME is a bad command and I dislike it very much.

  RESUME repeats the erroneous command. RESUME NEXT resumes program execution

after an incorrect command. RESUME <label> branches to the <label>. If a fatal error occurs

only RESUME <label> is possible

  **** RESUME is still not working. If you use ON ERROR GOSUB to a subroutine then

RESUME NEXT is the default if the subroutine reaches a RETURN. If you want to resume

somwhere else you can just GOTO out of the subroutine.  This is possible, but leaves the

internal stack pointer incremented, so you should not do this too often during runtime. other-

wise there will be a stack overAEow after 200 events.  **** looks like this also happens with

ON ERROR GOTO. *** In future versions of X11-Basic there might be a RESUME <label>

command which properly resets the stack.  If you want this to be oxed, please send me an

email with your test program.



  SEE ALSO:       ON  ERROR,GOTO,ERROR



                                                                                              369

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             RETURN



  Syntax:      RETURN

               RETURN  <expression>



DESCRIPTION:



   RETURN terminates a PROCEDURE reached via GOSUB and resumes execution after the

calling line.  Note that code reached via ON ERROR GOSUB should be terminated with a

RESUME NEXT, not with RETURN.

   RETURN <expression> states the result of the expression as a result of a user deoned

function. This can not be used in PROCEDURES but in FUNCTIONS. The expression must

be of the type the function was.



   SEE ALSO:       PROCEDURE,FUNCTION,ENDFUNCTION,RESUME,GOSUB,@,ON  ERROR



EXAMPLE:


         PROCEDURE testroutine
              PRINT "Hello World !"
         RETURN
         FUNCTION givemefive
              RETURN 5
         ENDFUNCTION



370

     _____________________________________________________________________________________5.19.__R__________



  Function:             REVERSE$()



 Syntax:        a$=REVERSE$(t$)



DESCRIPTION:



  Reverses a String.



EXAMPLE:


print reverse$("Markus Hoffmann")
Result: nnamffoH sukraM



   SEE ALSO:       UPPER"$(),TRIM"$()



                                                                                              371

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             RINSTR()



  Syntax:      <int-result>=RINSTR(s1$,s2$[,n])



DESCRIPTION:



   Operates in same way as INSTR except that search begins at the right end of s1$. tests if

s2$ is contained in s1$, then returns start-position of s2$, else 0. start comparison at pos. n

(default=1) start comparison at right



   SEE ALSO:       INSTR()



372

     _____________________________________________________________________________________5.19.__R__________



  Function:             RLD$()



 Syntax:        a$=RLD$(a$)



DESCRIPTION:



  Does a run length decoding of string a$. This function reverses the Run Length Encoding

function on a string.

  In the input string, any two consecutive characters with the same value AEag a run. A byte

following those two characters gives the count of additional(!)  repeat characters, which can

be anything from 0 to 255.



EXAMPLE:


PRINT RLD$("1233"+CHR$(8)+"456")
Result: 123333333333456



   SEE ALSO:       RLE"$()



                                                                                              373

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             RLE$()



  Syntax:      a$=RLE$(a$)



DESCRIPTION:



   Does a run length encoding of string a$. In the output string, any two consecutive characters

with the same value AEag a run.  A byte following those two characters gives the count of

additional(!)  repeat characters, which can be anything from 0 to 255.  The resulting String

might be shorter than the input string if there are many equal characters following each other.

In the worst case the resulting string will be 50% longer.



EXAMPLE:


PRINT RLE$("123.....................................456")
Result: 123..#456



   SEE ALSO:       RLD"$()



374

     _____________________________________________________________________________________5.19.__R__________



  Function:             RND()



 Syntax:        <num-result>  =  RND([<dummy>])



DESCRIPTION:



  RND() returns a pseudo-random number between 0 (inclusive) and 1 (exclusive). The se-

quence of pseudo-random numbers is identical each time you start the interpreter unless the

RANDOMIZE statement is used prior to using RND():  RANDOMIZE seeds the pseudo-

random number generator to get a new sequence of numbers from RND().  The optional

dummy parameter is ignored.



  SEE ALSO:       RANDOMIZE,GASDEV(),RANDOM()



EXAMPLE:


         PRINT RND(1)
         Result: 0.3352227557149



                                                                                              375

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             ROOTWINDOW



  Syntax:      ROOTWINDOW



DESCRIPTION:



   Directs all following graphic output to the root window of the screen.  (root window =

desktop background).



   SEE ALSO:       USEWINDOW



376

     _____________________________________________________________________________________5.19.__R__________



  Function:             ROUND()



 Syntax:        <num-result>=ROUND(<num-expression:b>[,n])



DESCRIPTION:



  Rounds ooe a value to n fractional digits. n<0: round to digits in front of the decimal point.



  SEE ALSO:       INT(),FIX(),FLOOR(),TRUNC()



                                                                                              377

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             RSRC_FREE



  Syntax:      RSRC_FREE



DESCRIPTION:



   RSRC_FREE unloads the graphical resources loaded with RSRC_LOAD and frees any

memory assigned to it.



   SEE ALSO:       RSRC"_LOAD



378

     _____________________________________________________________________________________5.19.__R__________



  Command:             RSRC_LOAD



 Syntax:        RSRC_LOAD  filename$



DESCRIPTION:



  RSRC_LOAD loads a GEM resource ole (*.rsc)-File (ATARI ST format) into memory and

prepares it to be used.



  SEE ALSO:       RSRC"_FREE,OBJ"_DRAW(),FORM"_DO()



                                                                                              379

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             RUN



  Syntax:      RUN



DESCRIPTION:



   starts program execution (RUN)



   SEE ALSO:       STOP,CONT,LOAD



380

     _____________________________________________________________________________________5.20.__S__________



5.20.    S



                                                                                              381

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SAVE



  Syntax:      SAVE  [a$]



DESCRIPTION:



   SAVE writes the BASIC-program into a ole with the name a$. If no olename is specioed

the program will be saved to the ole which was loaded before.



   SEE ALSO:       LOAD



382

     _____________________________________________________________________________________5.20.__S__________



  Command:             SAVESCREEN



 Syntax:        SAVESCREEN  t$



DESCRIPTION:



  Saves the whole Graphic-Screen (Desktop) into a ole with name t$. The graphics format is

XWD (X Window Dump image data) on UNIX systems and BMP (device independent bitmap

image) else.



  SEE ALSO:       SAVEWINDOW



                                                                                              383

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SAVEWINDOW



  Syntax:      SAVEWINDOW  t$



DESCRIPTION:



   Saves the actual X11-Basic Graphic-Window into a ole with name t$. The graphics format

is XWD (X Window Dump image data) on UNIX systems and BMP (device independent

bitmap image) else.



   SEE ALSO:       SAVESCREEN,SGET



384

     _____________________________________________________________________________________5.20.__S__________



  Command:             SCOPE



 Syntax:        SCOPE  a(),typ,yscale,yoffset

                SCOPE  y(),x(),typ,yscale,yoffset,xscale,xoffset



DESCRIPTION:



  SCOPE performes an extended polyline on one or two dimensional data.  Drawing and

scaling is done very fast. It is possible to plot a million points and lines at once.

  Type specioed the type of plot: 0  draw a polyline 1  draw points (without lines) 2  draw

impulses

  With xscale, yscale, xooeset and yooeset you can specify a scaling function to the data.



  SEE ALSO:       LINE,POLYLINE



                                                                                              385

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SCREEN



  Syntax:      SCREEN  n



DESCRIPTION:


This commands select the Screen-Resolution in SVGA-Mode.  It is only available in the

SVGA-Version of X11-Basic and has no eoeect on the X11-Version or WINDOWS-Version.

   Following Screen modes are supported: n Mode ===============================================

0 TEXT-Mode, no graphics 1 320x 200 16 colors 2 640x 200 16 colors 3 640x 350 16 colors

4 640x 480 16 colors 5 320x 200 256 colors 6 320x 240 256 colors 7 320x 400 256 colors 8

360x 480 256 colors 9 640x 480 monochrome 10 640x 480 256 colors 11 800x 600 256 colors

12 1024x 768 256 colors

   13 1280x1024 256 colors

   14 320x200 15Bit colors 15 320x200 16Bit colors 16 320x200 24Bit colors

   17 640x480 15Bit colors 18 640x480 16Bit colors 19 640x480 24Bit colors

   20 800x600 15Bit colors 21 800x600 16Bit colors 22 800x600 24Bit colors

   23 1024x768 15Bit colors 24 1024x768 16Bit colors 25 1024x768 24Bit colors

   26 1280x1024 15Bit colors 27 1280x1024 16Bit colors 28 1280x1024 24Bit colors

   29 800x 600 16 colors 30 1024x 768 16 colors 31 1280x1024 16 colors

   32 720x 348 monochrome Hercules emulation mode 33-37 32-bit per pixel modes. 38-74

additional resolutions



   SEE ALSO:       VGA-Version  of  X11-Basic



386

     _____________________________________________________________________________________5.20.__S__________



  Command:             SEEK



 Syntax:        SEEK  #n[,d]



DESCRIPTION:



  Place ole pointer of channel n on new absolute position d (Default on Position 0 which is

the beginning of File.)



  SEE ALSO:       RELSEEK,LOC(),EOF(),LOF()



                                                                                              387

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SEND



  Syntax:      SEND  #n,msg$[,adr%,port%]



DESCRIPTION:



   SEND is used to transmit a message via fast UDP datagramms to another socket which may

be on another host.  Send with only two parameters may be used only when the socket is in

a connected state (see CONNECT), otherwise the destination adress and the port has to be

specioed.

   The address of the target is given by adr%, which usually contains a IP4 adress (e.g.

cvl(chr$(127)+chr$(0)+chr$(0)+chr$(1)) which corresponds to 127.0.0.1).  msg$ can be an

arbitrary message with any data in it. The length of the message must not exceed 1500 Bytes.

If the message is too long to pass atomically through the underlying protocol, an error occurs,

and the message is not transmitted.

   No indication of failure to deliver is implicit in a send.

   When the message does not ot into the send buoeer of the socket, send blocks. The OUT?()

function may be used to determine when it is possible to send more data.



   SEE ALSO:       OPEN,CLOSE,CONNECT,RECEIVE,OUT?()



388

     _____________________________________________________________________________________5.20.__S__________



  Command:             SENSOR



 Syntax:        SENSOR  ON

                SENSOR  OFF



DESCRIPTION:



  Switches the the sensor phallanx on or ooe.  Sensors can be accelerometer, temperature,

pressure, light, humidity, gyroscope, etc... They need to be switched on or ooe, before you can

use them.



  SEE ALSO:       GPS,SENSOR?,SENSOR()



                                                                                              389

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             SENSOR?



  Syntax:      a=SENSOR?



DESCRIPTION:



   This system variable is 0 if no sensors are available on this hardware platform, otherwise

the number of usable sensors is returned. Sensors can be accelerometer, temperature, pressure,

light, humidity, gyroscope, etc...



   SEE ALSO:       GPS,SENSOR,SENSOR()



390

     _____________________________________________________________________________________5.20.__S__________



  Function:             SENSOR()



 Syntax:        a=SENSOR(n)



DESCRIPTION:



  Readout the n-th value of the sensor-fallanx. Usually n=0 > Temperature 1 > Abient light

3 > Proximity 4 > Battery 6 > Accelerometer x 7 > Accelerometer y 8 > Accelerometer

z 9 > Gyroscope x 10 > Gyroscope y 11 > Gyroscope z



  SEE ALSO:       GPS,SENSOR,SENSOR?,ANDROID?



                                                                                              391

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SELECT



  Syntax:      SELECT  <expression>



DESCRIPTION:



   Divides a program up into dioeerent blocks depending on the result of the expression. Only

the integer part of the result of the expression is used to compare with the values given by

CASE statements.  Program AEow branches to the block of code, given by the CASE state-

ment which matches the value of expression.  If no CASE block matches, it branches to the

DEFAULT block. If no DEFAULT block is given and none of the CASE blocks match, the pro-

grame resumes after the ENDSELECT. Also after the CASE block is onished, the programe

resumes after the ENDSELECT. You must not use GOTO out of the SELECTENDSELECT

block. (al though in the Interpreter this works, the compiler will not compile it correctly.) You

can leave the block any time with BREAK.

   COMMENT:

   The statement after SELECT will be evaluated/calculated only once, then compared to all

the values given by the CASE statements, one by one in the order given. If the orst matches,

the others will not be evaluated anymore.  The DEFAULT section will always match, if no

other match before was found. BREAK can be used, but there is no way to CONTINUE with

the SELECT after one (CASE) BLOCK was entered.



EXAMPLE:



i=5
SELECT i
  CASE 1
     PRINT 1
  CASE 2,3,4
     PRINT "its 2,3, or 4"
  CASE 5
     PRINT 5
  DEFAULT
     PRINT "default"
ENDSELECT



   SEE ALSO:       CASE,DEFAULT,ENDSELECT,BREAK,IF



392

     _____________________________________________________________________________________5.20.__S__________



  Command:             SETENV



 Syntax:        SETENV  t$,a$



DESCRIPTION:



  Sets environmentvariable t$ using value a$ (This command is not yet implemented)



EXAMPLE:


SETENV "LASTLAUNCHED",DATE$+" "+time$



   SEE ALSO:       ENV"$()



                                                                                              393

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SETFONT



  Syntax:      SETFONT  t$



DESCRIPTION:



   Loads and sets a Font for graphical text commands.  t$ may be "SMALL" or "5x7" for

a small font "MEDIUM or "8x8 for a medium sized font "BIG" or "8x16" for a big font.

"LARGE" or "16x32" for an even bigger font.

   With UNIX and the X-WINDOW system, the fontname may be any valid Font name or

pattern. On other platforms true type font olenames can be used. This way, also proportional

fonts can be used.



EXAMPLE:


SETFONT "BIG"
TEXT 100,100,"Hi, this is a big font"
SETFONT "5x7"
TEXT 100,150,"The small variant"
SETFONT "-*-lucidatypewriter-medium-r-*-*-10-*-*-*-m-*-*-*"
TEXT 100,200,"This may work on a UNIX system."
SETFONT "C:"Arial.ttf"
TEXT 100,200,"This may work on some other platform."



   SEE ALSO:       TEXT



394

     _____________________________________________________________________________________5.20.__S__________



  Command:             SETMOUSE



 Syntax:        SETMOUSE  x,y[,k]



DESCRIPTION:



  The SETMOUSE command permits the positioning of the mouse cursor under program

control. The optional parameter k can simulate the mouse button being pressed or released.



  SEE ALSO:       MOUSE



                                                                                              395

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SGET



  Syntax:      SGET  screen$



DESCRIPTION:



   SGET stores the content of the Graphics window or screen in screen$. The data format is

BMP (in case you want to write this into a ole).



   SEE ALSO:       SPUT,SAVEWINDOW



396

     _____________________________________________________________________________________5.20.__S__________



  Function:             SGN()



 Syntax:        a=SGN(b)



DESCRIPTION:



  SGN returns the sign of a number b. It may be -1 if b is negative 0 if b equals 0 1 if b is

positive.



  SEE ALSO:       ABS()



                                                                                              397

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             SHM_ATTACH()



  Syntax:      adr=SHM_ATTACH(id)



DESCRIPTION:



   SHM_ATTACH() attaches the shared memory segment identioed by id (see SHM_MALLOC())

to the programs address space. The adress is returned.

   You can also attach shared memory segments, which are originally created by another pro-

cess, but you must know the id, and the process must have read and write permission for the

segment..



   SEE ALSO:       SHM"_MALLOC(),SHM"_DETACH,SHM"_FREE



398

     _____________________________________________________________________________________5.20.__S__________



  Command:             SHM_DETACH



 Syntax:        SHM_DETACH  adr



DESCRIPTION:



  SHM_DETACH detaches the shared memory segment located at the address specioed by

adr from the address space of the program.  The to-be-detached segment must be currently

attached with adr equal to the value returned by the attaching SHM_ATTACH() call.



  SEE ALSO:       SHM"_MALLOC(),SHM"_ATTACH()



                                                                                              399

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SHM_FREE



  Syntax:      SHM_FREE  id



DESCRIPTION:



   Mark the shared memory segment identoed by id to be destroyed. The segment will only

actually be destroyed after the last process detaches it.  You can only free a shared memory

segment, if you are the owner, means, you mus have created it with SHM_MALLOC().



   SEE ALSO:       SHM"_MALLOC()



400

     _____________________________________________________________________________________5.20.__S__________



  Function:             SHM_MALLOC()



 Syntax:        id=SHM_MALLOC(size,key)



DESCRIPTION:



  SHM_MALLOC() returns the identioer of the shared memory segment associated with key.

A new shared memory segment, with size equal to the value of size rounded up to a multiple of

the operating system internal page size, is created if no shared memory segment corresponding

to key exists.

  Open the shared memory segment - create if necessary.

  Return value is the id of the shared memory segment.  The id can be used by dioeerent

processes to attach and access the segment (read and write). In case of an error, -1 is returned.



  SEE ALSO:       SHM"_FREE,SHM"_ATTACH()



                                                                                              401

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SHOWPAGE



  Syntax:      SHOWPAGE



DESCRIPTION:



   SHOWPAGE refreshes the graphic output. Usually the drawing to the graphic output win-

dow or screen is not visible until SHOWPAGE is performed. (Only on Tomtom devices this

command has no eoeect, because all graphics drawn is immediately visible).



   SEE ALSO:       VSYNC



402

     _____________________________________________________________________________________5.20.__S__________



  Function:             SIN()



 Syntax:        <num-result>=SIN(<num-expression>)



DESCRIPTION:



  Returns the sinus of the expression in radians.



EXAMPLE:


PRINT SIN(PI/2)      Result: 1



   SEE ALSO:       COS(),TAN(),ACOS()



                                                                                              403

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             SINH()



  Syntax:      <num-result>=SINH(<num-expression>)



DESCRIPTION:



   Returns the sinus hyperbolicus of the expression in radians.



   SEE ALSO:       SIN(),ASINH()



404

     _____________________________________________________________________________________5.20.__S__________



  Command:             SIZEW



 Syntax:        SIZEW  nr,w,h



DESCRIPTION:



  Resizes the graphic window #nr with width w and heigth h.



  SEE ALSO:       OPENW,MOVEW



                                                                                              405

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SORT



  Syntax:      SORT  <array-name>()[,<n>[,<2nd  array>()]]



DESCRIPTION:



   SORT sorts the one-dimensional array specioed as argument.  Numeric arrays and string

arrays can be sorted. If <n> is given, only the orst <n> values are sorted. If <2nd array> is

given, this (numerical) array will also be sorted corresponding to the orst. This is useful for

creating an index table.



406

     _____________________________________________________________________________________5.20.__S__________



  Command:             SOUND



 Syntax:        SOUND  <channel>,<frequency>[,volume[,duration]]



DESCRIPTION:


SOUND sets a tone for the sound generator for channel c%.  There are 16 sound channels

which are mixed together, so c may be between 0 and 15. If c is ommitted or -1, a free channel

(which is quiet at that time) will be used.

  The tone has frequency $[$Hz$]$, volume $[$0-1$]$ and a duration $[$s$]$. If frequency=0

(or volume=0) the channel will be switched ooe.  If duration is ommitted or -1 a permanent

sound will be played (inonite duration, until it is cleared by the next SOUND command to

that channel).

  Each of the 16 channels also support sound samples, which can be set via PLAYSOUND.

Volume can be 0 (ooe) to 1 (maximum). The duration is counted in seconds. The parameteres

of the sound synthezsizer of this channel can be set with WAVE (enveloppe and wave form).

Also noise can be set for a channel.

  COMMENT: On systems without ALSA/PCM sound the internal speaker is used.  The

internal speaker has only one channel (and produces sort of a quare wave).  The internal

speaker is accessed via a console device and needs privileges.  Except for on ANDROID

devices, the sound currently does not work under UNIX/LINUX.



EXAMPLE:


         WAVE 1,1,0.05,0.1,0.5,0.1     ! set the instrument parameters
         DO
           MOUSEEVENT                   ! wait for mouseclick
           SOUND 1,2*MOUSEX+50,1,0.3  ! play a nice sound
         LOOP
' Also this is possible:
SOUND 1,500     ! SOUND ON
PAUSE 0.1
SOUND 1,0       ! SOUND OFF



   SEE ALSO:       WAVE,PAUSE,PLAYSOUND



                                                                                              407

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             SP



Syntax <int-value>=SP

   DESCRIPTION:



   The variable SP represents the internal X11-Basic Stack Pointer.  Do not name any other

variable SP (or PC) since no value can be assigned to it.



   SEE ALSO:       PC



408

     _____________________________________________________________________________________5.20.__S__________



  Function:             SPACE$()



 Syntax:        t$=SPACE$(n)



DESCRIPTION:



  Returns a string containing n spaces.



  SEE ALSO:       STRING"$()



                                                                                              409

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SPAWN



  Syntax:      SPAWN  procedure



DESCRIPTION:



   Spawns a new pthread using the given procedure as an entry point. This entry point can be

considered the "main" function of that thread of execution. The new thread will run in parallel

to the main thread and can access the same memory (unlike a process which was forked with

fork()).

   This command is not fully implemented and at the moment messes up the program excecu-

tion stack of the interpreter since all internal control structures are accessed by two threads.

Anyway, in a natively compiled program this can work as expected.



EXAMPLE:



   SEE ALSO:       FORK()



410

     _____________________________________________________________________________________5.20.__S__________



  Function:             SOLVE()



 Syntax:        x()=SOLVE(m(),d())



DESCRIPTION:



  Soves a set of linear equations d()=M()*x().  M() has to be a 2 dim Array not necessarily

a square matrix.  d() must be a 1 dim Array with exactly as many elements as lines of M().

x() will be a 1 dim Array with exactly as many elements as rows of M(). Internally a singular

value decomposition is used to solve the equation. If singular values found to be smaller than

1e-10 of the largest value they are set to zero.



  SEE ALSO:       INV(),DET()



                                                                                              411

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SPEAK



  Syntax:      SPEAK  t$[,pitch,rate,locale$]



DESCRIPTION:


Reads text t$ loud. (It uses Text-to-speach synthesis if it is available). You can adjust a factor

for pitch (<1 male, >1 female) and rate (<1 slow, >1 fast).

   The locale can be: "de" for german pronounciation, "en" for english pronounciation, "us"

for english pronounciation, "fr" for french pronounciation, "es" for spanish pronounciation,

"it" for italian pronounciation.

   COMMENT: This command is implemnted in the Android version of X11-Basic only. Not

all locales might be installed. If a locale is missing, you will be asked to install it.



EXAMPLE:


SPEAK ""     ! The first SPEAK command initializes the text-to-speach engine
SPEAK "Are you hungry?"
SPEAK "Ich glaube nicht.",1,1,"de"



   SEE ALSO:       PLAYSOUND,WAVE



412

     _____________________________________________________________________________________5.20.__S__________



  Command:             SPLIT



 Syntax:        SPLIT  t$,d$,mode%,a$[,b$]



DESCRIPTION:



  Splits up string t$ into two parts a$ and b$ concerning a delimiter string d$.  So that

t$=a$+d$+b$.

  mode can be: 0  default 1  do not search in parts of t$ which are in brackets.

  Quoted parts of the string are not spit up.



EXAMPLE:


SPLIT "Hello, this is a string."," ",0,a$,b$



   SEE ALSO:       WORT"_SEP,WORD"$()



                                                                                              413

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SPUT



  Syntax:      SPUT  screen$



DESCRIPTION:


(xwd) Graok in screen$ auf Window SEE ALSO:       SGET,PUT"_BITMAP



414

     _____________________________________________________________________________________5.20.__S__________



  Function:             SQR(),   SQRT()



 Syntax:        <num-result>  =  SQR(<num-expression>)

                <num-result>  =  SQRT(<num-expression>)



DESCRIPTION:



  SQR() and SQRT() return the square root of its argument.



EXAMPLES:



PRINT SQR(25)
Result: 5

PRINT "Calculate square root of a number."
INPUT "Number=",z
r124=1
105:
r123=r124
r124=(r123^2+z)/(2*r123)
IF ABS(r124-r123)-0.00001>0
  PRINT r124
  GOTO 105
ENDIF
PRINT "Result of this algorithm:"'r124
PRINT "Compare with: sqrt(";z;")=";SQRT(z)
PRINT "Deviation:"'ABS(SQRT(z)-r124)



   SEE ALSO:       Operator  ^



                                                                                              415

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             SRAND()



  Syntax:      VOID  SRAND(b)



DESCRIPTION:



   The SRAND() function sets its argument as the seed for a new sequence of pseudo-random

integers to be returned by RAND(), RANDOM() or RND(). These sequences are repeatable

by calling SRAND() with the same seed value.



   SEE ALSO:       RANDOMIZE,RANDOM(),RND(),RAND()



416

     _____________________________________________________________________________________5.20.__S__________



  Variable:             STIMER



 Syntax:        <int-result>=STIMER



DESCRIPTION:



  STIMER returns the integer part of TIMER. So the resolution is 1 second and the value ots

in 32 bit integers. (And it is a bit faster than TIMER).



  SEE ALSO:       TIMER,CTIMER



                                                                                              417

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             STOP



  Syntax:      STOP



DESCRIPTION:



   STOP halts program execution and sets the interpreter to interactive mode. The execution

can be continued with the CONT command.



   SEE ALSO:       CONT,END,QUIT



418

     _____________________________________________________________________________________5.20.__S__________



  STR$(1-4) t$=STR$(a$[$,b,c$]$)  convert number to String of length b with c signiokant

digits STRING$(1-2)



                                                                                              419

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SUB



  Syntax:      SUB  <num-variable>,<num-expression>



DESCRIPTION:



   Decrease the value of the variable by the result of <num-expression>.



EXAMPLE:


a=0.5
SUB a,5
Result: -4.5



   SEE ALSO:       ADD,MUL,DIV



420

   _____________________________________________________________________________________5.20.__S__________



SUCC(1)



                                                                                            421

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             SWAP



  Syntax:      SWAP  a,b

               SWAP  a$,b$

               SWAP  a(),b()



DESCRIPTION:


Exchanges the values of the variables a and b. A and b can be of any type, but the types of a

and be mut be equal.



EXAMPLE:



a=4
b=5
SWAP a,b
print a
Result: 5



   SEE ALSO:       LET,Operator:  =



422

     _____________________________________________________________________________________5.20.__S__________



  Function:             SWAP()



 Syntax:        <num-result>=SWAP(<num-expression:b>)



DESCRIPTION:



  Swaps High and Low words of b and returns the result.  B is always treated as a 32 bit

unsigned integer.



  SEE ALSO:       BYTE(),CARD(),WORD()



                                                                                              423

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             SYM_ADR()



  Syntax:      adr=SYM_ADR(#n,sym_name$)



DESCRIPTION:



   SYM_ADR() resolves the adress of a symbol name of a given shared object library which

has been linked before.



EXAMPLE:



t$="/usr/lib/libreadline.so"     !  If the readline shared object file
IF EXIST(t$)                      !  exist,
  LINK #1,t$                      !  link it, resolve the symbol "readline"
  DUMP "#"                         !  and execute that subroutine with
  promt$=">>>"                    !  one string parameter.
  adr=EXEC(SYM_ADR(#1,"readline"),L:VARPTR(promt$))
  r=adr
  WHILE PEEK(r)>0                 ! Print the result
     PRINT CHR$(PEEK(r));
     INC r
  wend
  PRINT
  UNLINK #1 ! Unlink the dynamic lib
  FREE adr
ENDIF



   SEE ALSO:       LINK,UNLINK



424

     _____________________________________________________________________________________5.20.__S__________



  Command:             SYSTEM



 Syntax:        SYSTEM  <string-expression>



DESCRIPTION:



  Passes a command to the shell. Executes the shell command. SYSTEM provides a way to

use alle commands like rm, rmdir, mkdir etc. which are not implemented in X11-Basic, but

which are available from a command shell. (This is usually sh or busybox on UNIX/LINUX/ANDROID

and TomTom systems and DOS on MS WINDOWS).



EXAMPLE:


SYSTEM "mkdir folder"



   SEE ALSO:       SYSTEM"$()



                                                                                              425

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             SYSTEM$()



  Syntax:      <string-result>=SYSTEM$(<string-expression>)



DESCRIPTION:



   Passes a command to the shell.  Executes shell command.  The function returns a string

containing the stdout of the command executed.



EXAMPLE:



d$=SYSTEM$("ls")
PRINT d$



   SEE ALSO:       SYSTEM



426

     _____________________________________________________________________________________5.21.__T__________



5.21.    T



                                                                                              427

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             TERMINALNAME$



  Syntax:      a$=TERMINALNAME$



DESCRIPTION:



   Returns the device name of the terminal connected to the stdout standard output (if a termi-

nal device is connected).



EXAMPLE:



PRINT TERMINALNAME$
Result: /dev/pts/0



428

     _____________________________________________________________________________________5.21.__T__________



  Function:             TERMINALNAME$()



 Syntax:        t$=TERMINALNAME$(#n)



DESCRIPTION:



  Returns the device name of the terminal connected to ole #n if it is a terminal device.



                                                                                              429

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             TEXT



  Syntax:      TEXT  x,y,t$



DESCRIPTION:



   Draws text t$ in graphics window at position x,y.



EXAMPLE:



' Show the complete ASCII Font
SETFONT "*writer*18*"
COLOR GET_COLOR(65535,10000,10000)
FOR x=0 to 15
  FOR y=0 to 15
     TEXT 320+16*y,20+24*x,CHR$(y+16*x)
  NEXT y
NEXT x
SHOWPAGE



   SEE ALSO:       SETFONT,DEFTEXT



430

     _____________________________________________________________________________________5.21.__T__________



  Variable:             TIMER



 Syntax:        TIMER



DESCRIPTION:



  Returns actual time in number of seconds since 01.01.1970 00:00 GMT.



  SEE ALSO:       STIMER,CTIMER,TIME"$,DATE"$,UNIXTIME"$(),UNIXDATE"$()



                                                                                              431

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             TITLEW



  Syntax:      TITLEW  n,title$



DESCRIPTION:



   Gives the window #n the new title title$.



   SEE ALSO:       OPENW,INFOW



432

     _____________________________________________________________________________________5.21.__T__________



  Command:             TOPW



 Syntax:        TOPW  [n]



DESCRIPTION:



  Activates the windows number n and moves it to the front of the screen.



  SEE ALSO:       BOTTOMW,MOVEW



                                                                                              433

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             TRIM$()



  Syntax:      b$=TRIM$(a$)



DESCRIPTION:



   TRIM$(a$) returns a modioed string taken a$

   1.  replace Tabs by space 2.  replace double spaces by single ones 3.  remove leading and

trailing spaces 4. Parts of the string which are in quotes ("") will not be changed



   SEE ALSO:       XTRIM"$(),REPLACE"$()



434

     _____________________________________________________________________________________5.21.__T__________



  Command:             TROFF



 Syntax:        TROFF



DESCRIPTION:



  TROFF disables tracing output. This command is meant to be used during program devel-

opment.



  SEE ALSO:       TRON,ECHO



                                                                                              435

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             TRON



  Syntax:      TRON



DESCRIPTION:


TRON enables tracing output:  each program line is displayed on the console before it is

executed. This command is meant to be used during program development.



   SEE ALSO:       TROFF,ECHO



436

     _____________________________________________________________________________________5.21.__T__________



  Variable:             TRUE



 Syntax:        TRUE



DESCRIPTION:



  Constant -1. This is simply another way of expressing the value of a condition when it is

true and is equal to -1 (all bits not zero).



  SEE ALSO:       FALSE



                                                                                              437

5.__X11-Basic_command_reference___________________________________________________________________



5.22.    U



438

     ____________________________________________________________________________________5.22.__U___________



  Function:             UCASE$()



 Syntax:        <string-result>=UCASE$(<string-expression>)



DESCRIPTION:



  Transforms all lower case letters of a string to upper case. Any non letter characters are left

unchanged.



  SEE ALSO:       UPPER"$(),LOWER"$()



                                                                                              439

5.__X11-Basic_command_reference___________________________________________________________________



   Variable:             UNCOMPRESS$()



  Syntax:      t$=UNCOMPRESS$(c$)



DESCRIPTION:



   Uncompresses the content of a string which has been compressed with the COMPRESS$()

function before.



   SEE ALSO:       COMPRESS"$()



440

     ____________________________________________________________________________________5.22.__U___________



  Variable:             UNIX?



 Syntax:        <bool-result>=UNIX?



DESCRIPTION:



  Returns TRUE (-1) If the program is running under a UNIX evironment.



  SEE ALSO:       WIN32?,TT?,ANDROID?



                                                                                              441

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             UNIXTIME$(),   UNIXDATE$()



  Syntax:      t$=UNIXTIME$(i)

               d$=UNIXDATE$(i)



DESCRIPTION:



   These functions return the date and time as a string which has the same format as DATE$

and TIME$ given by a TIMER value.



EXAMPLE:


PRINT UNIXDATE$(1045390004.431), UNIXTIME$(1045390004.431)
Result:    16.02.2003    11:06:44



   SEE ALSO:       DATE"$,TIME"$,TIMER



442

     ____________________________________________________________________________________5.22.__U___________



  Command:             UNLINK



 Syntax:        UNLINK  #n



DESCRIPTION:



  Unlinks a shared object which has been linked before and occupies ole channel #n.



  SEE ALSO:       LINK,CLOSE



                                                                                              443

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             UNMAP



  Syntax:      UNMAP  adr%,len%



DESCRIPTION:



   Unmap oles or devices out of memory.

   The UNMAP command deletes the mappings for the specioed address range.  Further

PEEK() and POKEs to addresses within the old range will produce an error (crash).  The

region is also automatically unmapped when X11-Basic is terminated.  On the other hand,

closing the ole does not unmap the region.



   SEE ALSO:       MAP



444

     ____________________________________________________________________________________5.22.__U___________



  Command:             UNTIL



 Syntax:        UNTIL  <expression>



DESCRIPTION:



  UNTIL terminates a REPEAT...UNTIL loop.



  SEE ALSO:       REPEAT,DO



EXAMPLE:


        REPEAT
            N=N+1
        UNTIL (N=10)



                                                                                              445

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             UPPER$()



  Syntax:      <string-result>=UPPER$(<string-expression>)



DESCRIPTION:



   Transforms all lower case letters of a string to upper case. Any non letter characters are left

unchanged.



   SEE ALSO:       UCASE"$(),LOWER"$()



446

     ____________________________________________________________________________________5.22.__U___________



  Command:             USEWINDOW



 Syntax:        USEWINDOW  #n



DESCRIPTION:



  Use the window n for all following graphic commands.



  SEE ALSO:       OPENW,ROOTWINDOW



                                                                                              447

5.__X11-Basic_command_reference___________________________________________________________________



5.23.    V



448

     ____________________________________________________________________________________5.23.__V___________



  Function:             VAL()



 Syntax:        <num-result>  =  VAL(<string-expression>)



DESCRIPTION:



  VAL() converts String representing a AEoating point number into a numeric value.  If the

string does not represent a valid number 0 is returned.



  SEE ALSO:       VAL?(),STR"$()



EXAMPLE:


         a=VAL("3.1415926")



                                                                                              449

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             VAL?()



  Syntax:      a=val?(t$)



DESCRIPTION:


Returns number of characters forim string which can be converted to a number. (This function

is not yet working).



EXAMPLE:


print val?("12345.67e12Hallo")  Result: 11



   SEE ALSO:       VAL()



450

     ____________________________________________________________________________________5.23.__V___________



  Function:             VARPTR()



 Syntax:        <adr>=VARPTR(<variable>)



DESCRIPTION:



  Determines the address of a variable and returns a pointer.  Usually this is used together

with PEEK() and POKE to modify the content of the variable. VARPTR() can also be used to

determine the address of an array index.



EXAMPLE:


PRINT VARPTR(t$), VARPTR(a(2,4))
POKE VARPTR(t$),ASC("A")



   SEE ALSO:       ARRPTR(),PEEK(),POKE



                                                                                              451

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             VERSION



  Syntax:      VERSION



DESCRIPTION:



   Shows X11-Basic version number and date.



EXAMPLE:


VERSION
Result: X11-BASIC Version: 1.08 Sat Feb 15 12:00:38 CET 2003



452

     ____________________________________________________________________________________5.23.__V___________



  Command:             VOID   ABBREV.   "



 Syntax:        VOID  <expression>



DESCRIPTION:



  This command performs a calculation and forgets the result.  Sounds silly but there are

occasions when this command is required, eg. when you want to execute a function but you

are not really interested in the return value. e.g. waiting for a keystroke (inp(-2)).



  SEE ALSO:       GOSUB,@



EXAMPLE:


"INP(-2)
VOID FORM_ALERT(1,"[1][Hello][OK]")



                                                                                              453

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             VSYNC



  Syntax:      VSYNC



DESCRIPTION:



   Enables synchronization with the screen.  Actually this is a synonyme for SHOWPAGE.

Graphic output will not be shown in the window until SHOWPAGE (or VSYNC). (This com-

mand has no eoeect on the TomTom Device.)



   SEE ALSO:       SHOWPAGE



454

     ____________________________________________________________________________________5.24.__W___________



5.24.    W



                                                                                              455

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             WATCH



  Syntax:      WATCH  filename$



DESCRIPTION:



   WATCH can be used to monitor individual oles, or to monitor directories. When a directory

is monitored, FILEEVENT$ will return events for the directory itself, and for oles inside the

directory. Note that WATCH is not available on every operating system.



EXAMPLE:


WATCH "/tmp"
DO
  a$=FILEEVENT$
  IF LEN(a$)
     PRINT a$
  ENDIF
LOOP



   SEE ALSO:       FILEEVENT"$



456

     ____________________________________________________________________________________5.24.__W___________



  Command:             WAVE



 Syntax:        WAVE  c%,form%[,attack,decay,sustain,release]



DESCRIPTION:



  WAVE controls the internal sound synthesizer. You can specify a waveform generator and

an enveloppe for each of the 16 sound channels.

  Set the given parameters for channel c%.  There are 16 sound channels which are mixed

together, so c may be between 0 and 15.

  If c is ommitted or -1, the parameters are set for all channels.

  form% specioes the tone generator for the specioed channel:

  Tone Generators: 0 - silence (default for channels 1-15) 1 - sin wave (default for channel 0)

2 - square wave 3 - triangular wave 4 - sawtooth wave 5 - white noise

  The envelope of the tones are specioed using 4 parameters attack,decay,sustain and release.

attack, decay and release values are specioed in seconds. sustain level values are between 0

and 1.

  * "Attack time" is the time taken for initial run-up of level from nil to peak, beginning when

the SOUND command is excecuted. * "Decay time" is the time taken for the subsequent run

down from the attack level to the designated sustain level, after the attack part of the enveloppe

is over. * "Sustain level" is the level during the main sequence of the sound's duration, until

duration time is reached (e.g. 0.8). * "Release time" is the time taken for the level to decay

from the sustain level to zero after the duration time is over.

  If you want a permanent tone, set attack to 0, sustain to 1 and decay as well as release to

any value.

  The WAVE commands allow to simulate real instruments, e.g.  strings, trompet or piano.

A realistic sound can only be acheived by also using higher harmonics. To simulate this, you

will have to use more than one channel and play them simultaneously.

  Volume, frequency and duration for the specioed sound channel are set by the SOUND

command.



  SEE ALSO:       SOUND,PLAYSOUND



EXAMPLE:


WAVE 1,1,0,,1      ! set sine wave, no attack
SOUND 1,500,1      ! play a permanent tone on channel 1



                                                                                              457

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             WHILE



  Syntax:      WHILE  <num-expression>



DESCRIPTION:



   WHILE initiates a WHILE...WEND loop. The loop ends with WEND and execution reiter-

ates while the WHILE <num-expression> is not FALSE (not null). Unlike a REPEAT...UNTIL

loop, the loop body is not necessarily executed at least once.



   SEE ALSO:       WEND,DO



EXAMPLE:


        WHILE NOT EOF(#1)
            LINEINPUT #1,a$
        WEND



458

     ____________________________________________________________________________________5.24.__W___________



  Command:             WEND



 Syntax:        WEND



DESCRIPTION:



  WEND terminates a WHILE...WEND loop. SEE ALSO:       WHILE,DO



EXAMPLE:


        WHILE NOT EOF(#1)
            LINEINPUT #1,a$
        WEND



                                                                                              459

5.__X11-Basic_command_reference___________________________________________________________________



   Function:             WORD()



  Syntax:      a=WORD(b)



DESCRIPTION:



   Returns lower 16 bits of b and expands sign. B is always treated as an integer.



   SEE ALSO:       BYTE(),CARD(),SWAP()



460

     ____________________________________________________________________________________5.24.__W___________



  Function:             WORD$()



 Syntax:        a$=WORD$(b$,n)



DESCRIPTION:



  Returns the n'th word of b$. Words must be separated by space.



EXAMPLE:


a$=WORD$("Hallo, this is a string.",3)



   SEE ALSO:       SPLIT,WORT"_SEP()



                                                                                              461

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             WORT_SEP



  Syntax:      WORT_SEP  t$,d$,mode,a$,b$



DESCRIPTION:



   Splits up string t$ into two parts a$ and b$ concerning a delimiter string d$.  So that

t$=a$+d$+b$.

   mode can be: 0  default 1  do not serch parts of t$ which are in brackets.

   Quoted parts of the string are not spit up.



EXAMPLE:


WORT_SEP "Hello, this is a string."," ",0,a$,b$



   SEE ALSO:       SPLIT,WORT"_SEP()



462

     ____________________________________________________________________________________5.24.__W___________



  Function:             WORT_SEP()



 Syntax:        <num-result>=WORT_SEP(t$,d$,mode,a$,b$)



DESCRIPTION:



  Splits up string t$ into two parts a$ and b$ concerning a delimiter string d$.  So that

t$=a$+d$+b$.

  mode can be: 0  default 1  do not serch parts of t$ which are in brackets.

  Quoted parts of the string are not spit up.

  The return value can be: 2  The string has been split up. 1  The string did not contain d$,

a$=t$, b$="" 0  The string was empty. a$="",b$=""



  SEE ALSO:       SPLIT



                                                                                              463

5.__X11-Basic_command_reference___________________________________________________________________



5.25.    X



464

     ____________________________________________________________________________________5.25.__X___________



  Command:             XLOAD



 Syntax:        XLOAD



DESCRIPTION:



  Opens a oleselector where the user can select a basic source ole which then will be load

into memory.



  SEE ALSO:       XRUN,LOAD



                                                                                              465

5.__X11-Basic_command_reference___________________________________________________________________



   Operator:             XOR



  Syntax:      <num-expression1>  XOR  <num-expression2>



DESCRIPTION:



   Logical exclusive OR operator. XOR returns FALSE (0) if both arguments have the same

logical value.

   Table:  A _ B _ A XOR B -++ -1 _ -1 _ 0 -1 _ 0 _ -1 0 _ -1 _

-1 0 _ 0 _ 0



EXAMPLE:



PRINT 3=3 XOR 4>2  Result:    0 (false)
        PRINT 3>3 XOR 5>3  Result:  -1 (true)

PRINT (4 XOR 255)         Result:    251



   SEE ALSO:       NAND,OR,NOT,AND



466

     ____________________________________________________________________________________5.25.__X___________



  Function:             XOR()



 Syntax:        <num-result>=XOR(<num-expression>,<num-expression2>)



DESCRIPTION:



  XOR(a,b) returns FALSE (0) if both arguments have the same logical value.  Otherwise

TRUE (-1) is returned.

  Table:  A _ B _ XOR(A,B) -++ -1 _ -1 _ 0 -1 _ 0 _ -1 0 _ -1 _

-1 0 _ 0 _ 0



  SEE ALSO:       OR(),AND,XOR



                                                                                              467

5.__X11-Basic_command_reference___________________________________________________________________



   Command:             XRUN



  Syntax:      XRUN



DESCRIPTION:



   Opens a oleselector where the user can select a basic source ole which then will be load

into memory and executed.



   SEE ALSO:       XLOAD,RUN



468

     ____________________________________________________________________________________5.25.__X___________



  Function:             XTRIM$()



 Syntax:        b$=XTRIM$(a$)



DESCRIPTION:



  XTRIM$(a$) returns a modioed string taken a$

  1.  replace Tabs by space 2.  replace double spaces by single ones 3.  remove leading and

trailing spaces 4. Parts of the string which are in quotes ("") will not be changed 5. convert all

parts of the string, which are outside quotes ("") to upper case.



  SEE ALSO:       TRIM"$(),REPLACE"$(),UPPER"$()



                                                                                              469





6.     Frequently  asked  Questions



How easy is it to hack into my programs?


Well, orst of all: it is possible. The basic source oles (.bas) are of course readable by any text

editor and such modifyable.  The bytecode compiled code (.b) is already harder to read and

nearly impossible to convert back into source code. However, since X11-basic is open source,

everybody who wants to can look into the sourcecode and can read all information necessary

to decode the bytecode and also modify it. Its possible but a real big job to do. On the level

of bytecode translated to C source also here someone could modify it. Once the bytecode is

compiled into real machine language, the code is as safe from hackers as any other code is

(means that there is nearly no way back).

   Even if you incorporate the bytecode into the virtual machine, your program should be safe

from snoopers, they might not even know your program is byte-code generated. You can also

instruct the bytecode compiler not to attach any symbol table or extra debugging information.



Do I need a license to distribute my programs?


No. You don't need a license to use X11-Basic (it's free), and you deonitely don't need any

license to distribute or sell your programs.  The only agreement you have to worry about is

that if you choose to use X11-Basic, you assume any and all consequences, direct or indirectly

from the use of X11-Basic. Which means: don't blame me if it doesn't work as you think it

should. X11-Basic can be used for any task, whether it's proot-seeking or otherwise. I do not

want to know, and you don't pay me a cent.  You don't even have to acknowledge that your

program was created with X11-Basic (although this would be a nice gesture). You're allowed

to bundle X11-Basic along with your program(s), as long as the user is well informed that it's

not buying into X11-Basic, but rather, buying into your program. How is that done? By not

even advertising that your distribution includes a copy of X11-Basic.  However, if you want

to distribute or modify X11-Basic itself, or if you want to incorporate parts of the X11-Basic

sourcecode, you will need to follow the GNU public licence.



                                                                                              471




7.     Compatibility



7.1.    General remarks


X11-Basic deviates in numerous aspects from ANSI BASIC. It in event is also dioeerent from

Gfa-Basic (Atari ST) all though it really looks similar:



ELSE IF vs. ELSEIF


This interpreter uses the ELSE IF form of the "else if" statement with a space between ELSE

and IF. In contrast, ANSI BASIC uses ELSEIF and END IF. Other interpreters may also use

the combination ELSEIF and END IF.



Local variables


Local variables must be declared local in the procedure/function.  Any other variables are

treated as global.



Call By-Value vs. By-Reference


Variables in a GOSUB statement as in GOSUB  test(a) are passed "by-value" to the PROCE-

DURE: the subroutine gets the value but can not change the variable.  To pass the variable

"by-reference", use the VAR keyword as in "GOSUB test(VAR a)": the subroutine then not

only gets the value but the variable itself and can change it (for more information, see the doc-

umentation of the GO SUB statement). The same rules apply to FUNCTION: VAR in the pa

rameter list of a function call allows a FUNCTION to get a vari able parameter "by-reference".

In contrast, traditional BASIC in terpreters always pass variables in parameter lists "by-refer

ence". The problem with "by-reference" parameters is that you must be fully aware of what

happens inside the subroutine: as signments to parameter variables inside the subroutine might

change the values of variables in the calling line.



Assignment operator


X11-BASIC does not have an assignment operator but overloads the equal sign to act as the

assignment operator or as comparison operator depending on context: In a regular expression,

all equal signs are considered to be the comparison operator, as in IF  (a=2).  However, in



472

     _____________________________________________________________7.2.__GFA-Basic_compatibility_____________



an "assignment-style" expression (as in LET  a=1), the orst equal sign is considered to be the

assignment operator. Here is an example which assigns the result of a comparison (TRUE or

FALSE) to the variable <a> and thus shows both forms of usage of the equal sign:



a=(b=c)



Assignments to modioable lvalue


Some implementations of BASIC allow the use of functions on the left side of assignments

as in MID$(a$,5,1)="a". X11-Basic does not support this syntax but requires a variable (a

"modioable lvalue") on the left side of such expressions.



TOS/GEM implementation


Because Gfa-Basic on ATARI-ST makes much use of the built in GUI functions of the ATARI

ST, the X11-Basic interpreter can only have limited compatibility. GEM style (and compat-

ible) ALERT boxes, menus and object trees are included in X11-Basic and can be used in

a similar way.  Even ATARI ST *.rsc oles can be loaded.  But Other functions like LINEA

functions, the VDISYS, GEMSYS, BIOS, XBIOS and GEMDOS calls are (of course) not

possible. Also many other commands are not implemented because the author thinks that they

have no useful eoeect on UNIX platforms. Some might be included in a later Version of X11-

Basic (see the list below). Since many GfA-Basic programs make use of more or less of these

functions, they will have to be modioed before they can be run with X11-Basic.



The INLINE statement


The INLINE statement is not supported, because the source code of X11-Basic programs is

pure ASCII text. But an alternative has been implemented. (see INLINE$()).



7.2.    GFA-Basic compatibility


Following GFA-Basic Commands and functions are not supported and probably never will be.

Most of them are obsolete on unix systems. When porting from GFA-Basic to X11-Basic they

have to be removed or replaced by an alternative routine:



obsolete, because there is an alternative function in X11-Basic:



==                              Comparison operator for approximately equal > =

ARECT,  ATEXT,  HLINE       LINE-A functions> LINE, BOX, TEXT

ACHAR,  ACLIP,  ALINE,  APOLY> TOTEXT,CLIP,LINE, POLY



                                                                                              473

7.__Compatibility_________________________________________________________________________________



COSQ(),SINQ()               quick cosine/sine using an internal table > COS(),SIN()

DIR                            Lists the oles on a disc. > system "ls"

DIR$()                        Names the active directory > env$("PWD")

FILES                          Lists the oles on a disk. > system "ls -l"

FRE()                          Returns the amount of memory free (in bytes). > see below

KILL                           Deletes a ole > system "rm -f ..."

MSHRINK()                    Reduces the size of a storage area > REALLOC()

NAME  AS                       Renames an existing ole. > system "mv ..."

RC_COPY                       Copies rectangular screen sections (> COPYAREA)

RENAME  AS                    Rename a ole.   ! SYSTEM  "mv  ..."

RESERVE                       Increases or decreases the memory used by basic (obsolete)

SHEL_FIND()                   ! SYSTEM  "find  ..."

SYSTEM                        obsolete  ! QUIT

SHEL_ENVRN()                  ! ENV$()

SHEL_READ                    obsolete  ! PARAM$()

THEN                           keyword in If statements (obsolete)



   For some GFA-Basic commands you can construckt replacement functions in X11-Basic
like:


' Get the free memory available (in Bytes)
' n=0 physical memory
' n=1 Swap space
FUNCTION fre(n)
  LOCAL i,a,t$,a$
  a=FREEFILE()
  OPEN "I",#a,"/proc/meminfo"
  LINEINPUT #a,t$
  IF n=1
     LINEINPUT #a,t$
  ENDIF
  LINEINPUT #a,t$
  t$=TRIM$(t$)
  FOR i=0 to 3
     WORT_SEP t$," ",0,a$,t$
  NEXT i
  CLOSE #a
  RETURN val(a$)
ENDFUNCTION



obsolete, because TOS-Specioc, and no similar function on other OSes exist:



ADDRIN,  ADDROUT            address of the AES Address Input/Output blocks

APPL_EXIT()                  Declare program has onished

APPL_INIT()                  Announce the program as an application.

APPL_TPLAY()                Plays back a record of user activities

APPL_TRECORD()              makes a record of user activities



474

     _____________________________________________________________7.2.__GFA-Basic_compatibility_____________



BIOS()                        call BIOS routies

CONTRL                        Address of the VDI control table.

FGETDTA()                    Returns the DTA (Disk Transfer Address).

FSETDTA                       Sets the address of the DTA

GB,  GCONTRL                  Address of the AES Parameter/control Block

GDOS?                          Returns TRUE (-1) if GDOS is resident

GEMDOS()                      call the GEMDOS routines.

GEMSYS                        call the AES routinen

GINTIN,  GINTOUT            Address of the AES Integer input/output block.

HIMEM                          address of the area of memory which is not allocated by interpreter

INTIN,  INTOUT               Address of the VDI integer Input/output block.

L"A                            Returns base address of the LINE-A variables.

MENU_REGISTER()            Give a desk accessory a name

MONITOR                       Calls a monitor resident in memory.

SHEL_GET,  SHEL_PUT        obsolete

SHEL_WRITE                   obsolete

VDIBASE,  VDISYS            VDI functions

VQT_EXTENT                   coordinates of a rectangle which surround the text

VQT_NAME()                   VDI function

VSETCOLOR                    TOS specioc

VST_LOAD_FONTS(),  VST_UNLOAD_FONTS()

V_CLRWK(),  V_CLSVWK(),  V_CLSWK(),  V_OPNVWK()

V_OPNWK(),  V_UPDWK()      VDI-GDOS functions

V"H                            Returns the internal VDI handle

W_HAND(#n)                   Returns the GEM handle of the window

W_INDEX()                    Returns the window number of the specioed GEM handle.

WORK_OUT()                   Determines the values from OPEN_WORKSTATION.

XBIOS()                       call XBIOS system routines.



Obsolete, because ATARI-ST-Hardware-Specioc, and no similar function exists on UNIX

or SDL platforms:



CHDRIVE                       Sets the default disk drive

DMACONTROL,  DMASOUND      Controls the DMA sound (see PLAYSOUND)

INPMID$                       read data from the MIDI port

LPENX,  LPENY                Returns the coordinates of a light pen.

PADT(),  PADX(),  PADY()   Reads the paddle on the STE

SDPOKE,  SLPOKE,  SPOKE    Supervisor mode memory access



                                                                                              475

7.__Compatibility_________________________________________________________________________________



Not supported because of other reasons:



APPL_READ()                  read from the event buoeer.

APPL_WRITE()                write to the event buoeer.

BASEPAGE                      address of the basepage

BITBLT                        Raster copying command

CFLOAT()                      Changes integer into a AEoating point number.

DEFBIT,  DEFBYT,  DEFWRD,  DEFFLT,  DEFSTR                sets the varaible type

DFREE()                       free space on a disc

GETSIZE()                    return the number of Bytes required by a screen area

HARDCOPY                      Prints the screen > savescreen

INPAUX$                       read data from the serial port

KEYDEF                        Assign a string to a Function Key.

LLIST                          Prints out the listing of the current program.

LPOS()                        column in which the printer head is located

LPRINT                        prints data on the printer.

PSAVE                          save with protection

RCALL                          Calls an assembler routine

SCRP_READ(),  SCRP_WRITE()communication between GEM programs.

SETCOLOR  i,r,g,b           set rgb value of color cell (>GET_COLOR())

SETTIME                       Sets the time and the date.

WINDTAB                       Gives the address of the Window Parameter Table.

WIND_CALC(),  WIND_CLOSE(),  WIND_CREATE(),  WIND_DELETE(),  WIND_FIND(),

WIND_GET(),  WIND_OPEN(),

WIND_SET(),  WIND_UPDATE()                                 GEM-Wondow-Function



These GFA-Basic commands may be supported in a later versions of X11-Basic:



ABSOLUTE  x,y                Assigns the address y to the variable x.

APPL_FIND(fname$)          Returns the ID of the sought after application.

BYTE-x"                       read the contents of the address x

C:                              Calls a C or assembler program with parameters as in C

CARD-x"                       Reads/writes a 2-byte unsigned integer

CHAR-x"                       Reads a string of bytes until a null byte is encountered

CHDIR                          Changes the current directory.

CRSCOL   CRSLIN              Returns current cursor line and column.

CURVE  x0,y0,x1,y1,x2,y2,x3,y3The BEZIER-Curve

DEFLIST  x                    Deones the program listing format.

DEFNUM  n                      Aoeects output of numbers by the PRINT command



476

     _____________________________________________________________7.2.__GFA-Basic_compatibility_____________



DELETE  x(i)                  Removes the ith element of array x.

DO  UNTIL                      extention

DO  WHILE                      extention

DOUBLE-x"                    reads/writes an 8-byte AEoating point variable

DRAW                           Draws points and lines

EVNT_BUTTON()               Waits for one or more mouse clicks

EVNT_DCLICK()               Sets the speed for double-clicks of a mouse button.

EVNT_KEYBD()                Waits for a key to be pressed and returns a word

EVNT_MESAG()                Waits for the arrival of a message in the event buoeer.

EVNT_MOUSE()                Waits for the mouse pointer to be located inside

EVNT_MULTI()                Waits for the occurence of selected events.

EVNT_TIMER()                waits for a period of time

FATAL                          Returns the value 0 or -1 according to the type of error

FIELD                          Divides records into oelds.

FILL                           Fills a bordered area with a pattern

FORM  INPUT                   Enables the insertion of a character string

FORM  INPUT  AS               the current value of a$ is displayed, and can be edited.

FORM_BUTTON()               Make inputs in a form possible using the mouse.

FORM_ERROR()                Displays the ALERT associated with the error numbered

FORM_KEYBD()                Allows a form to be edited via the keyboard.

FSEL_INPUT()                Calls the AES oleselect library

FSFIRST()                    Searches for the orst ole to fuloll the criteria

FSNEXT()                      Search for the next ole which fulolls the conditions

GET  #                          Reads a record from a random access ole.

GRAF_DRAGBOX()              a rectangle to be moved about the screen

GRAF_GROWBOX()              Draws an expanding rectangle.

GRAF_HANDLE()               supplies the size of a character from the system set

GRAF_MKSTATE()              supplies the current mouse coordinates

GRAF_MOUSE)                  allows the mouse shape to be changed.

GRAF_MOVEBOX()              a moving rectangle with constant size

GRAF_RUBBERBOX()           draws an outline of a rectangle

GRAF_SHRINKBOX()           Draws an shrinking rectangle.

GRAF_SLIDEBOX()            moves one rectangular object within another

GRAF_WATCHBOX()            monitors an object tree while a mouse button is pressed

HIDEM                          Switches ooe the mouse pointer.

HTAB                           Positions the cursor to the specioed column.

OUT?()                        output to device

INSERT                        Inserts an element into an array.

INT-x"                        Reads/writes a 2 byte signed integer from/to address x.

KEYGET  n                      similar to INKEY$ but wait

KEYLOOK  n                    similar to INKEY$ but putback chars

KEYTEST  n                    similar to INKEY$



                                                                                              477

7.__Compatibility_________________________________________________________________________________



KEYPAD  n                      Sets the usage of the numerical keypad.

KEYPRESS  n                   This simulates the pressing of a key.

LOCATE                        Positions the cursor to the specioed location.

LONG-x"                       Reads/writes a 4 byte integer from/to address x. Abbrev

LOOP  UNTIL  condition      extention

LOOP  WHILE  condition      extention

LSET  var=string            Puts the 'string' in the string variable 'var' leoet justioed

MAT  ADD  a(),b()

MAT  ADD  a(),x

MAT  CLR  a()

MAT  CPY  a([i,j])=b([k,l])[,h,w]

MAT  DET  x=a([i,j])[,n]

MAT  INPUT  #i,a()

MAT  INV  a()=b()

MAT  MUL

MAT  MUL  a(),x

a()=b()*c()

MAT  MUL  x=a()*b()

MAT  MUL  x=a()*b()*c()

MAT  NORM  a(),-0/1"

MAT  ONE  a()

MAT  PRINT  [#i]a[,g,n]

MAT  QDET  x=a([i,j])[,n]

MAT  RANG  x=a([i,j])[,n]

MAT  READ  a()

MAT  SET  a()=x

MAT  SUB  a(),b()

MAT  SUB  a(),x

MAT  TRANS  a()[=b()]

MAT  XCPY  a([i,j])=b([k,l])[,h,w]

MAT  BASE  -0/1"

MAX(x  [,y,z,...])   orRetMAX(a$[,y$,z$....])urns the greatest value (or largest string)

MENU(x)                       Returns the information about an event in the variable

MENU  OFF                      Returns a menu title to 'normal' display.

MENU_BAR()                   Displays/erases a menu bar (from a resource ole)

MENU_ICHECK()               Deletes/displays a tick against a menu item.

MENU_IENABLE()              Enables/disables a menu entry.

MENU_TEXT()                  Changes the text of a menu item.

MENU_TNORMAL()              Switches the menu title to normal/inverse video.

MID$(a$,x[,y])              (as a command/lvalue)

MIN(expression  [  ,expression...Re])turns the smallest value (or smallest string)

MODE                           representation of decimal point, date and oles



478

     _____________________________________________________________7.2.__GFA-Basic_compatibility_____________



OBJC_CHANGE()               Changes the status of an object.

OBJC_EDIT()                  Allows input and editing

OBJC_ORDER()                re-positions an object within a tree.

OB_ADR()                      Gets the address of an individual object.

OB_FLAGS()                   Gets the status of the AEags for an object.

OB_H()                        Returns the height of an object

OB_HEAD()                    Points to the object's orst child

OB_NEXT()                    Points to the following object on the same level

OB_SPEC()                    Returns the address of the the data structure

OB_STATE()                   returns the status of an object

OB_TAIL()                    Points to the objects last child

OB_TYPE()                    Returns the type of object specioed.

OB_W()                        Returns the width of an object

OB_X(),  OB_Y()              relative coordinates of the object

OCT$()                        value in octal form

ON  BREAK                      inAEuence behavior of CTRL-C

OPTION  BASE                  determine whether an array is to contain a zero element

QSORT                          Sorts the elements of an array.

RCALL                          Calls an assembler routine

RC_INTERSECT()              Detects whether two rectangles overlap.

RECALL                        Inputs n lines from a text ole

RECORD                        Sets the number of the next record (GET#, PUT#)

RND  as  a  sysvar            see RND()

ROL(),  ROL&(),  ROL%()    Rotates a bit pattern left.

ROR(),  ROR&(),  ROR%()    Rotates a bit pattern right.

RSET  a$=b$                   Moves a string expression, right justioed to a string.

RSRC_OBFIX()                converts the coordinates of an object

RSRC_SADDR()                sets the address of an object.

RUN  <filname>               see RUN

SETDRAW                       see DRAW

SHL(),  SHL&(),  SHL%()    Shifts a bit pattern left

SHOWM                          Makes the mouse pointer appear.

SHR(),  SHR&(),  SHR%()    Shifts a bit pattern left

SINGLE-x"                    Reads/writes a 4 byte AEoating point

SPRITE                        Puts a sprite

SSORT                          Sorts using the Shell-Metzner method.

STORE                          Fast save of a string array as a text ole.

TOUCH                          Updates the date and time stamps of a ole.

TRON#                          Tron to ole

TRON  proc                    procedure is called before the execution of each command

VARIAT()                      Returns the number of permutations of n elements to the kth order

VTAB                           positions the cursor to the specioed line number



                                                                                              479

7.__Compatibility_________________________________________________________________________________



WAVE                           Produces noises from the sound channels.

WRITE                          Stores data in a sequential ole

_DATA                          Specioes the position of the DATA pointer.

STICK                          control the joystick (via SDL only)

MKDIR                          Creates a new directory. > system "mkdir ..."

RMDIR                          Deletes empty directories  ! SYSTEM  "rmdir  "



Following commands have a dioeerent meaning and/or syntax in X11-Basic:
                             _________________________________________
                             |  GFA-BASIC               X11-Basic  |
                             |_____________________________________|__
                             |  SYSTEM                  QUIT        |
                             |                                      |
                             |  LINE  INPUT             LINEINPUT  |
                             |                                     |
                             |  SOUND                   -             |
                             |                                        |
                             |  WAVE                    -             |
                             |                                        |
                             |  VSYNC                   -             |
                             |                                        |
                             |  ON  MENU                MENU        |
                             |                                      |
                             |  ON  MENU  GOSUB  ...    MENUDEF    |
                             |                                     |
                             |  MENU  a$()              MENUDEF    |
                             |                                     |
                             |  MENU  OFF               -             |
                             |                                        |
                             |  MENU  KILL              MENUKILL   |
                             |                                     |
                             |  MENU()                  -             |
                             |                                        |
                             |  MONITOR                 SYSTEM      |
                             |______________________________________|_



7.3.    Ideas for future releases of X11-Basic


These are some ideas for new commands, which are not GFA-commands and which might be

implemented in X11-Basic in future:



Tally:   returns  number  of  occurances  of  matchstring

a=TALLY(t$,s$[,start])



DECLOSE$(t$)



and



ENCLOSE$(str[,  pair])



Encloses  a  string.

The  default  pair  is  ""



480

     ________________________________________________7.3.__Ideas_for_future_releases_of_X11-Basic___________



Example:

?  enclose$("abc","()")



Result:

(abc)

========================

 LEFTOF$(s1,s2),

 RIGHTOF$(s1,s2)



   Returns  the  left/right  part

   of  s1  at  the  position  of  the

   first  occurrence  of  the

   string  s2  into  string  s1

========================

SPRINT  var$;[USING...;]...

 PRINT  anweisung,  aber  in  var$  (Statt  Print  #1,...)



========================



          CRSCOL  n.n.

          CRSLIN  n.n.



========================

implemention  of  mmap  in  x11basic:



open  "I",#1,"myfile"

adr%=map("I_O_U",#1,len,offset)



msync  adr%,len



unmap  adr%,len

close  #1



          offset   should   be  a  multiple  of  the  page  size  as  returned

          by  getpagesize(2).



"I"    entspricht  PROT_READ  MAP_PRIVATE

"O"    entspricht  PROT_WRITE  MAP_SHARED

"U"    entspricht  PROT_READ  PROT_WRITE  MAP_SHARED



                                                                                              481

7.__Compatibility_________________________________________________________________________________



"*L"  entspricht  MAP_LOCKED



=============================================



modifyable  lvalues:

MID$()=

CHAR-"=

SELECT  ...  CASE   ...   ENDSELECT

neues  Kommando  (fuer  threads):



EXSUB  (statt  gosub)  procedure



alternativ:

FIRE  procedure()

oder

KICK  procedure()



man  muss  aber  sicherstellen,  dass  die  Programmablaufkontrolle,  der  Zugriff  auf

variablen  etc,  thread-safe  ist.  Das  koennte  schwierig  werden.



Man  kann  das  Kommando  aber  schonmal  (experimentell)  implementieren.



-----------------------

SHOWM

HIDEM

(nuetzlich  vor  allem  im  Fullscreen-modus)

------------------------



482




A.      GNU  Free  Documentation  License



GNU Free Documentation License
  Version 1.2, November 2002



 Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
      51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.



0. PREAMBLE


The purpose of this License is to make a manual, textbook, or other
functional and useful document "free" in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.


This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.


We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.



1. APPLICABILITY AND DEFINITIONS


This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The "Document", below,
refers to any such manual or work.  Any member of the public is a



                                                                                              483

A.__GNU_Free_Documentation_License________________________________________________________________



licensee, and is addressed as "you".  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.


A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.


A "Secondary Section" is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (Thus, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.


The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.


The "Cover Texts" are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.


A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not "Transparent" is called "Opaque".


Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG.  Opaque formats



484


     _______________________________________________________________________________________________________



include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.


The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.


A section "Entitled XYZ" means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as "Acknowledgements",
"Dedications", "Endorsements", or "History".)  To "Preserve the Title"
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.


The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.



2. VERBATIM COPYING


You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.


You may also lend copies, under the same conditions stated above, and
you may publicly display copies.



3. COPYING IN QUANTITY


If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the



                                                                                              485

A.__GNU_Free_Documentation_License________________________________________________________________



copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.


If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.


If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.


It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.



4. MODIFICATIONS


You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:


A. Use in the Title Page (and on the covers, if any) a title distinct
    from that of the Document, and from those of previous versions
    (which should, if there were any, be listed in the History section
    of the Document).  You may use the same title as a previous version
    if the original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities
    responsible for authorship of the modifications in the Modified
    Version, together with at least five of the principal authors of the



486


     _______________________________________________________________________________________________________



   Document (all of its principal authors, if it has fewer than five),
   unless they release you from this requirement.
C. State on the Title page the name of the publisher of the
   Modified Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modifications
   adjacent to the other copyright notices.
F. Include, immediately after the copyright notices, a license notice
   giving the public permission to use the Modified Version under the
   terms of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections
   and required Cover Texts given in the Document's license notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled "History", Preserve its Title, and add
   to it an item stating at least the title, year, new authors, and
   publisher of the Modified Version as given on the Title Page.  If
   there is no section Entitled "History" in the Document, create one
   stating the title, year, authors, and publisher of the Document as
   given on its Title Page, then add an item describing the Modified
   Version as stated in the previous sentence.
J. Preserve the network location, if any, given in the Document for
   public access to a Transparent copy of the Document, and likewise
   the network locations given in the Document for previous versions
   it was based on.  These may be placed in the "History" section.
   You may omit a network location for a work that was published at
   least four years before the Document itself, or if the original
   publisher of the version it refers to gives permission.
K. For any section Entitled "Acknowledgements" or "Dedications",
   Preserve the Title of the section, and preserve in the section all
   the substance and tone of each of the contributor acknowledgements
   and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document,
   unaltered in their text and in their titles.  Section numbers
   or the equivalent are not considered part of the section titles.
M. Delete any section Entitled "Endorsements".  Such a section
   may not be included in the Modified Version.
N. Do not retitle any existing section to be Entitled "Endorsements"
   or to conflict in title with any Invariant Section.
O. Preserve any Warranty Disclaimers.


If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.


You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has



                                                                                              487

A.__GNU_Free_Documentation_License________________________________________________________________



been approved by an organization as the authoritative definition of a
standard.


You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.


The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.



5. COMBINING DOCUMENTS


You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.


The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.


In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications".  You must delete all sections
Entitled "Endorsements".



6. COLLECTIONS OF DOCUMENTS


You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.



488


     _______________________________________________________________________________________________________



You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.



7. AGGREGATION WITH INDEPENDENT WORKS


A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.


If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.



8. TRANSLATION


Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.


If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.



9. TERMINATION



                                                                                              489

A.__GNU_Free_Documentation_License________________________________________________________________



You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.



10. FUTURE REVISIONS OF THIS LICENSE


The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.


Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.



ADDENDUM: How to use this License for your documents


To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:


     Copyright (c)  YEAR  YOUR NAME.
     Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.2
     or any later version published by the Free Software Foundation;
     with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
     A copy of the license is included in the section entitled "GNU
     Free Documentation License".


If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the "with...Texts." line with this:


     with the Invariant Sections being LIST THEIR TITLES, with the
     Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.


If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.



490


     _______________________________________________________________________________________________________



If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.



                                                                                              491





Acknowlegements



Thanks to all people, who helped me to realize this package.

   Many thanks to the developers of GFA-Basic.  This basic made me start programming in

the 1980s. Many ideas and most of the command syntax has been taken from the ATARI ST

implementation.

   Thanks to sourceforge.net for hosting this project on the web.

   Unfortuantely derivates of the routines of the famous book "numerical recepies in C" are

not allowed to be distributed as part of the X11-Basic program. So I have not included all of

the mathematics features of X11-Basic in this distribution. (see mathemat_dummy.c). If you

own the book and have a licence you may ask me for the sources of the routines.



                                                                                              493

4. FAQ frequently asked questions
=================================

Q: Why can't I compile X11Basic on my Computer with Zintorola 86060 processor 
   and Sluggix 0.8 Beta O.S.?
A: If you have GNU-C and X11R5/6 for this system, and X11Basic still won't 
   compile, please let me know as soon as possible, I will try to fix it.

Q: How do I leave the interpreter `gently'?
A: type quit or press ctrl-c (twice)

Q: What do all the warnings mean?
A: Well, isn't proper ported to your (any?) system. 

Q: Why do the graphics look funny?
A: Some X-Servers do not clean newly allocated Pixmaps. So rubbish is displayed 
   if the window is maped. Please do a clearw 1 as a first command.

Q: Is there a GUI-Designer for the graphical user unterface functions 
   of X11Basic ?
A: Well, so far nobody has made a real efford to write a real graphical 
   GUI_designer. But the program gui2bas may help creating GUI forms. The input
   is a very siple ASCII-File (*.gui) which defines the interface. So far 
   many GEM object types are supportet (and even Atart ST *.rsc-files may
   be converted to *.gui files with the rsc2gui program.) but support for 
   listboxes, popup-menues and Tooltips may be included in future.

Q: My old ANSI Basic Programs (with line-Numbers) produce lots of errors in the
   interpreter. How can I run classic (ANSI) Basic programs?
A: Classic Basic programs have to be converted before they can be run with 
   X11-Basic. With the bas2x11basic converter program most of this convertion
   will be done automatically. 

F: Kann ich meine alten Atari Programme "einfach" rberziehen oder mssen
   die noch irgendwie ( speziell Gem Programme ) angepasst werden?
A: Die mssen noch angepasst werden. Es gibt kleinere Unterschiede in der
   Syntax, Systemaufrufe (XBIOS,BIOS,VDISYS etc), Inline-Blcke gehen
   natrlich nicht, short int
   Variablen gibt es nicht etc. Also man muss nochmal mit der Hand
   drbergehen. Aber es gibt nichts, was nicht irgendwie auch geht.
   Bei kleinen Programmen (ca. 100 Zeilen) ist es ein Kinderspiel. Bei
   greren (mehere 1000 Zeilen) ist es schon was arbeit. 10000-Zeilen
   Programme habe ich noch nicht portiert. Es lohnt wahrscheinlich nicht.
   Fr Programme, an denen man nichts mehr machen will, empfehle ich dann
   doch lieber STonX oder sowas.

Q: Program XXX doesn't run, what should I do?
A: Well this question is too difficult to answer. 

Q: Can I use X11-Basic as a shell ? 
A: Yes, simply copy the xbasic executable to /usr/bin .
   The basic programs then should have in their first line
   #!/usr/bin/xbasic 

Q: Can I use X11-Basic as an internet daemon ? 
A: Yes, start xbasic with the option -daemon .
   This feature is still experimental. So use it on your own risk since this 
   opens several security holes to your system.

Q: Can X11-Basic generate stand-alone programs, which may run 
   without the xbasic executable ?
A: Yes and No. X11-Basic does not translate its input into assembly, you 
   always need the xbasic executable. On the other hand: the xbasic 
   executable is rather small (< 200 kB), so you might spread it around 
   with your X11-Basic programs. If you really need stand alone programs 
   try the pseudo-compiler (xbc). It can link the x11basic-library to your 
   programs. The result is a stand alone binary.
   
Q: May I charge for my X11-Basic programs ?
A: Yes, you may. But you should state clearly, that xbasic itself is available 
   free of charge. Refer to the File COPYING for details.

Q: Where can I get the newest version of X11-Basic? 
A: Probably at 
   http://x11-basic.sourceforge.net/
   Don't bet on it though! :-) 

Q: What can I do to speed up the development of X11-Basic?
A: You can try to bribe me with any amount of money, any type of hardware or
   software (no pirated stuff please).
   A nice postcard might suffice too. :-)
   If you like to implement some new features and/or commands to x11basic,
   please send me your new sources with description. But I only will implement
   this stuff if I like it .-)

--------------------------------------------------------------------------------



Things left to do:
==================
- Optimize a bit more
- The WIndows-Version needs more work
- Fix the bugs
- work on the sound system
- work on the SDL-Graphics implementation (fill styles etc...)
- documentation needs more work
- find someone who can port it to apple mac/ipad/iphone
(etc. etc.)

BUGS:
=====	- still some bugs


Version history of X11-Basic
============================

In the beginning there were absurd plans, long sleepless nights, and incredible
boredom.

Very First Version (1990)
--------------------------
It was a Mailbox-Program with Basic features (only character-Graphics with
Vt100EMU) on my ATARI ST (!).

Version 0.1 First version with a version number    (1997)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Mailbox-Program was rewritten in c on my Linux-PC
- first X11-Commands

Version 0.2 Alpha (1998)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- improved X11-Basic for use at the physics institute in Bonn
- Fixed last Problems of the Parser (didn't like -1*(4-3) )
- Added more X-features (redraw)
- First portation to a HP-Workstation
- Readline library in use

Version 1.00 Beta (Mar 1999)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Makefile and configure script adapted from STonX
- True-color Displays
- X rootwindow, multiple windows
- INKEY$
- First GPL-Distribution
- FILESELECT,ALERT

Version 1.01 (Jun 1999)
~~~~~~~~~~~~~~~~~~~~~~
- POINT()

Version 1.02 (Jun 2000)
~~~~~~~~~~~~~~~~~~~~~~
- rsrc_load
- shell, daemon

Version 1.03 (Mar 2001)
~~~~~~~~~~~~~~~~~~~~~~~
- copyarea, sget, sput, get,put
- fill-Patterns
- drop down menues
- String-Variables may now contain nul-characters.
- POKE,DPOKE,LPOKE,EVEN(),ODD()
- LINK,UNLINK
- CVI(),CVD(),CVF(),CVL()
- MKI$(),MKD$(),MKL$(),MKF$()
- ON x GOSUB proc1,proc2,...
- ON x GOTO label1,label2,...
- INSTR(),RINSTR()

Version 1.04 (Apr. 2001)
~~~~~~~~~~~~~~~~~~~~~~~~
- splitted off shared library libx11basic.so (300kB)
- bug fixed which caused print a,b to segmentation fault
- DUMP "#"
- SYM_ADR()
- CALL, EXEC, EXEC()  with parameter list
- DUMP "K" DUMP "F"

Version 1.05 (Aug. 2001)
~~~~~~~~~~~~~~~~~~~~~~~~
- PRINT USING
- SYSTEM$()
- GLOB()
- RBOX, PRBOX
- EDIT, SAVE
- HELP
- new system errors
- started to translate everything into english

Version 1.06 (Jan. 2002)
~~~~~~~~~~~~~~~~~~~~~~~~

- included serial device support
- improved FILESELECT
- modified ALERT
- improved COLOR
- FORM_DIAL(), FORM_DO(), OBJC_DRAW()
- GPRINT

Version 1.07 (Aug. 2002)
~~~~~~~~~~~~~~~~~~~~~~~~
- Fehler mit Exponentialdarstellungen von Zahlen mit negativem Exponent
  ist nun endlich behoben !!!
- Anbindung an tine-Bibliothek und Kontrollsystem ist nun moeglich

Version 1.08 (Jan. 2003)
~~~~~~~~~~~~~~~~~~~~~~~~
- Support for tine-library
- a first MS-WINDOWS version is now available
- some new functions
- FIT and FIT_LINEAR
- SORT command
There was a bug introduced in the MENU command. Fixed it in release 1.08-4.

Version 1.09 (June 2003)
~~~~~~~~~~~~~~~~~~~~~~~~
- ANSI-Basic to X11-Basic converter included
- New example programs
- updated man-page and documentation
- new SOUND command
- EVAL, EVAL()
- modified serial line support
- modified the configure procedure
- some modifications for portability
- will now compile on FreeBSD and CYGWIN

Version 1.10 (Feb 2004)
~~~~~~~~~~~~~~~~~~~~~~~~
- new REPLACE$() function 
- improved speed 
- bug fixed in ROUND() function
- fixed bug in PUT_BITMAP
- fixed bug in serial device handling
- added sysvars COLS and ROWS
- new INODE/DEVICE/MODE/NLINK/SIZE file functions

Version 1.11 (Oct 2004)
~~~~~~~~~~~~~~~~~~~~~~~~
- Parser now accepts unique short commands
- fixed little bug in INPUT
- new chapters in manual
- new commands: TOPW, BOTTOMW, INFOW, FULLW, CLIP
- found bug in ON ERROR and ON BREAK
- new FILL command
- changed TAB treatement in sourcecode
- worked on TINE implementation
- worked on the ARRAY functions
- new SHL(), SHR() function

Version 1.12 (Mar 2005)
~~~~~~~~~~~~~~~~~~~~~~~~
- fixed bug with DEFMARK
- experimental LISTSELECT
- worked on MATRIX functions: SOLVE(),INV(),DET()
- OPEN "UU"  UDP-Sockets
- CONNECT, SEND, RECEIVE
- New String Functions: REVERSE$(), MTFE$(), MTFD$(), RLD$(), RLE$()
- CRC()
- New Code Engines: BETE$(), BWTD$(), COMPRESS$()

Version 1.13 (Feb 2006)
~~~~~~~~~~~~~~~~~~~~~~~~
- fixed bug in INPUT$()
- woked in the TINE implementation (TINELISTEN, TINEBROADCAST)
- new MKA$(), CVA()
- fixed bug in PAUSE/DELAY
- implemented ioctl() function

Version 1.14 (Apr 2007)
~~~~~~~~~~~~~~~~~~~~~~~~
- improved the init_program routines
- woked on the bytecode compiler
- new programs xbbc and xbvm  + man pages
- the bytecodecompiler and virtual machine are still full of bugs
- some sample programs can already be compiled to bytecode, 
  they run 4 to 10 times faster 
- Bug fixed which caused "Command  not allowed in interactive mode" errors
  This bug was introduced in Version 1.14 since release 1
- worked on the control system routines (DOOCS)
- fixed bug with fgetc
- crosscompiled it with arm-linux for embedded linux
- new CHDIR command
- new SPAWN command (does still not work as wanted)
- created doocsxbasic modification to use the FLASH control system at DESY


Release notes for Version 1.15 (Feb 2008)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- New command: PIPE
- New commands: GET_SCREENSIZE, GET_GEOMETRY
- Implemented BMP file format (for PUT)
- produced a framebuffer-graphics version of X11-basic


Release notes for Version 1.16 (Feb 2010)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Bugfix in SORT (Feb 2010)
- new function word$() June 2010
- Improved DATA/RESTORE handling Dez 2010
- Improved xbbc/bytecode/xbvm
- Fixed memory leak accuring in varptr()
- added xbbc and xbvm to windows distribution
- started xb2c project
- new psydocompiler for MS-WINDOWS, can produce standalone .exe files 
- Bug fixed: LINEINPUT and LINEINPUT$() now can read arbitrary long lines
- fixed bug with PBOX: now 2nd coordinate is inside the filled area.
- new commands WATCH/(UNWATCH)/FILEEVENT$
- fixed bug with bitmaps (PUT)
- added support for bitmaps with transparency/alpha channel
- fixed bug in DEFFILL
- fixed bug in objc_draw()

Release notes for Version 1.17 (May 2011)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Adapted windows version to use the SDL library (2011-04)
- added PLAYSOUND command (works only in SDL and WINDOWS version) 2011-05
- modifyed syntax of SOUND command 2011-05
- added ALSA sound support for SOUND command. 2011-05
- made syntax a bit more tolerant against extra blanks
- bugfix with BOX (confusion with curses library, segfault)
- worked on the xb2c compiler/translator 2011-08

Release notes for Version 1.18 (Sept 2011)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Reworked variable management
- Reworked xb2c compiler, produced code is now much(!) faster.
- interpreter is now 8% faster
- virtual machine is 20 times faster than interpreter
- compiled code is 30 times faster than interpreter
- improved detection of const expressions.
- improved detection of fieldindex too large (less segfaults now)
- fixed a memory leak
- updated the documentation
- changed DIM behavior: DIM a(10) means elements a(0) to a(9) are there.
- fixed some bugs. 
- New command: CURVE
- Implemented DEFFN
- Optimized Compiler: simple math functions and Square

--------------------------------------------------------------------------------

Release notes for Version 1.19 (Mai 2012)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Android version
- virtual machine now included in library
- new GPS and SENSOR commands (for Android version)
- new SPEAK kommand (for Android version)
- improved framebuffer graphics routines
- new command: PLAYSOUNDFILE (for Android version)
- new command: GET_LOCATION
- BUGFIX: SOUND, WAVE, AND(), OR(), XOR(), NOT()
- BUGFIX: FOR with integer variable
- BUGFIX: SELECT CASE ENDSELECT
- NEW: "!" is now allowed at the beginning of a line
- BUGFIX: SELECT/CONTINUE
          Last change to this file:  So 4. Nov 15:41:16 CET 2012
